<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASL flight simulator</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; user-select: none; }
        
        /* ä»ªè¡¨ç›˜å¸ƒå±€ */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            padding: 25px; box-sizing: border-box; z-index: 10;
        }

        .hud-top-left { display: flex; gap: 20px; }
        
        .instrument {
            background: rgba(10, 20, 30, 0.75); 
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-left: 4px solid #00aaff;
            backdrop-filter: blur(8px); 
            padding: 10px 18px; 
            color: #eee; 
            min-width: 100px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        
        .label { font-size: 10px; color: #88ccff; font-weight: 600; letter-spacing: 1px; margin-bottom: 4px; display:block; text-transform: uppercase;}
        .value { font-size: 26px; font-weight: 700; font-family: 'Consolas', monospace; letter-spacing: -1px; }
        .unit { font-size: 12px; color: #888; margin-left: 4px; font-weight: 400;}

        /* æ²¹é—¨æ¨æ† */
        #throttle-wrapper {
            position: absolute; left: 30px; bottom: 120px; width: 12px; height: 240px;
            background: rgba(0,0,0,0.6); border: 1px solid #555; border-radius: 8px;
            padding: 2px;
        }
        #throttle-fill {
            position: absolute; bottom: 2px; left: 2px; width: 12px; height: 0%;
            background: linear-gradient(to top, #4caf50, #ffeb3b, #ff5722);
            border-radius: 4px; transition: height 0.1s;
        }
        #throttle-label {
            position: absolute; left: 50px; bottom: 120px; color: #fff; font-size: 12px; font-weight: bold;
            transform: rotate(-90deg); transform-origin: left bottom; opacity: 0.7;
        }

        /* è­¦å‘Šä¿¡æ¯ */
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.2; }
        }

        #center-warning {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff3333; font-size: 24px; font-weight: bold; border: 2px solid #ff3333;
            padding: 10px 30px; background: rgba(0,0,0,0.7); display: none;
            /* ä¼˜åŒ–ï¼šæ–°å¢é—ªçƒæ•ˆæœ */
            animation: blink 0.5s step-end infinite;
        }

        /* å¯åŠ¨ç”»é¢ */
#splash {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    /* ğŸ¨ å¤©è“è‰²ç«‹ä½“èƒŒæ™¯ */
    background: linear-gradient(135deg, #0093E9 0%, #80D0C7 100%);
    z-index: 999; 
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    color: white;
    /* æŠ•å½±æ•ˆæœ */
    text-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); 
}

h1 { 
    font-size: 32px; 
    margin: 0; 
    font-weight: 400; 
    letter-spacing: 5px; 
    text-transform: uppercase;
    color: #fff;
    /* æŠ•å½±æ•ˆæœ */
    text-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); 
}

/* æ ‡é¢˜æ ·å¼ï¼šChoose Your Plane */
#plane-chooser-title {
    font-size: 20px; 
    margin-bottom: 20px; 
    font-weight: 600; 
    color: #f0f0f0; 
    letter-spacing: 3px;
}

/* 3D æ¨¡å‹å®¹å™¨æ ·å¼ */
#plane-model-container {
    width: 600px;
    height: 300px;
    margin: 20px 0 10px; /* è°ƒæ•´ margin */
    /* ç°ä»£è¾¹æ¡†å’ŒèƒŒæ™¯ */
    background: rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    overflow: hidden;
    position: relative;
}

/* æ¨¡å‹åˆ‡æ¢æŒ‰é’®æ ·å¼ */
.model-nav-button {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(0, 0, 0, 0.4);
    border: none;
    color: white;
    padding: 10px;
    cursor: pointer;
    font-size: 24px;
    z-index: 10;
    transition: background 0.2s;
}

.model-nav-button:hover {
    background: rgba(0, 0, 0, 0.7);
}

#prev-plane { left: 10px; border-radius: 50%; }
#next-plane { right: 10px; border-radius: 50%; }

/* é£æœºå‚æ•°å±•ç¤ºåŒºæ ·å¼ (æ–°å¢) */
#plane-info-display {
    text-align: center;
    margin-top: 15px;
    padding: 15px 30px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    min-width: 450px;
}

.plane-title {
    font-size: 18px;
    font-weight: 700;
    color: #fff;
    margin-bottom: 10px;
    letter-spacing: 1px;
    text-transform: uppercase;
}

.stats-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 5px 20px;
    font-size: 13px;
    color: #c0e0f0;
}

.stat-value {
    font-family: 'Consolas', monospace;
    font-weight: bold;
    color: #80D0C7;
    margin-left: 5px;
}


/* æŒ‰é’®å’Œæ§åˆ¶ç½‘æ ¼æ ·å¼æ›´æ–° */
.controls-grid {
    display: grid; grid-template-columns: auto auto; gap: 10px 20px; 
    margin-top: 20px;
    text-align: left; 
    background: rgba(0,0,0,0.3); /* æ·±è‰²é€æ˜èƒŒæ™¯ */
    padding: 20px; 
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.2);
    font-size: 14px;
}

.key-box { 
    font-family: 'Consolas', monospace; 
    color: #80D0C7; /* åŒ¹é…ä¸»é¢˜è‰² */
    font-weight: bold; 
    margin-right: 8px;
    background: rgba(255, 255, 255, 0.15);
    padding: 2px 6px;
    border-radius: 4px;
    border: 1px solid #80D0C7;
}

button#start-button {
    margin-top: 40px; 
    padding: 14px 50px; 
    font-size: 16px; 
    font-weight: 700; 
    border: none; /* ç§»é™¤è¾¹æ¡† */
    background: #0093E9; 
    color: #fff; 
    cursor: pointer; 
    letter-spacing: 2px;
    transition: all 0.3s; 
    text-transform: uppercase;
    border-radius: 30px; /* åœ†è§’æŒ‰é’® */
    box-shadow: 0 6px 20px rgba(0, 147, 233, 0.6);
}
button#start-button:hover { 
    background: #80D0C7; 
    color: #000; 
    box-shadow: 0 6px 25px rgba(128, 208, 199, 0.8); 
}
/* ä¼˜åŒ–ï¼šæŒ‰é’®æŒ‰ä¸‹æ•ˆæœ */
button#start-button:active {
    transform: translateY(2px);
    box-shadow: 0 3px 10px rgba(0, 147, 233, 0.6);
}

        /* ğŸš€ æ ·å¼ï¼šç”»è´¨é€‰æ‹©é¢æ¿ */
#quality-selector {
    position: absolute; 
    right: 25px; 
    bottom: 25px; 
    z-index: 10;
    pointer-events: all; /* ç¡®ä¿å¯ä»¥ç‚¹å‡» */
    background: rgba(10, 20, 30, 0.75); 
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-right: 4px solid #00aaff; /* åŒ¹é…ä»ªè¡¨ç›˜æ ·å¼ */
    backdrop-filter: blur(8px); 
    padding: 10px 18px; 
    color: #eee; 
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
}

#quality-selector .label {
    display: block;
    font-size: 10px; 
    color: #88ccff; 
    font-weight: 600; 
    letter-spacing: 1px; 
    margin-bottom: 8px;
    text-transform: uppercase;
}

.button-group button {
    /* é‡ç½®é»˜è®¤æŒ‰é’®æ ·å¼ */
    all: unset; 
    cursor: pointer;
    font-size: 14px;
    padding: 4px 10px;
    margin-left: 5px;
    border: 1px solid #00aaff;
    color: #00aaff;
    background-color: rgba(0, 170, 255, 0.1);
    transition: all 0.2s;
}

.button-group button:first-child {
    margin-left: 0;
}

/* é€‰ä¸­çŠ¶æ€ */
.button-group button.active,
.button-group button:hover {
    background-color: #00aaff;
    color: #1a2a3a;
    font-weight: bold;
}

/* ğŸš€ æ–°å¢ï¼šLoading ç•Œé¢æ ·å¼ */
#loading-screen {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.95);
    z-index: 1000; /* æ¯” splash é«˜ */
    display: none; /* é»˜è®¤éšè—ï¼Œåœ¨ startGame ä¸­æ˜¾ç¤º */
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 20px;
}

#loading-progress-bar {
    width: 300px;
    height: 10px;
    margin-top: 20px;
    background: #555;
    border-radius: 5px;
    overflow: hidden;
}

#loading-progress-fill {
    height: 100%;
    width: 0%;
    background: #00aaff;
    transition: width 0.3s;
}
    </style>
</head>
<body>

    <div id="splash">
        <h1>ASL <b>FLIGHT SIMULATOR</b></h1>
        <p id="plane-chooser-title">CHOOSE YOUR PLANE</p>
    
        <div id="plane-model-container">
            <button id="prev-plane" class="model-nav-button" onclick="changePlane(-1)">&#9664;</button> 
            <button id="next-plane" class="model-nav-button" onclick="changePlane(1)">&#9658;</button> 
        </div>
        
        <div id="plane-info-display">
            <p class="plane-title" id="plane-name">Future Aircraft</p>
            <div class="stats-grid">
                <div>Mass: <span id="stat-mass" class="stat-value">0</span> KG</div>
                <div>Max Thrust: <span id="stat-thrust" class="stat-value">0</span> kN</div>
                <div>Lift Coeff: <span id="stat-lift" class="stat-value">0.0</span></div>
                <div>Ground Clearance: <span id="stat-height" class="stat-value">0.0</span> m</div>
            </div>
        </div>

        <div class="controls-grid">
            <div><span class="key-box">SHIFT</span> Increase engine power/thrust.</div>
            <div><span class="key-box">SPACE</span> Apply wheel brakes or air brakes.</div>
            <div><span class="key-box">W / S</span> Pitch the nose up or down (elevator control).</div>
            <div><span class="key-box">A / D</span> Roll the aircraft left or right using ailerons</div>
            <div><span class="key-box">Q / E</span> Steer left or right using the rudder. </div>
            <div><span class="key-box">V</span> Change camera view. </div>
        </div>
    
        <div style="margin-top:20px; color:#c0e0f0; font-size:13px; opacity: 0.8;">
            âš  made by Zhanyi Zhou
            <br> Â© 2025 Zhanyi Zhou (ASL) All rights reserved
        </div>
    
        <button id="start-button" onclick="startGame()">INITIALIZE SYSTEMS</button>
    </div>
    
    <div id="loading-screen">
        <p>Loading Game Assets...</p>
        <div id="loading-progress-bar">
            <div id="loading-progress-fill"></div>
        </div>
        <p id="loading-status" style="margin-top:10px; font-size:14px;">(0%)</p>
    </div>

    <div id="hud-layer">
        <div class="hud-top-left">
            <div class="instrument">
                <span class="label">Airspeed</span>
                <span class="value" id="hud-spd">0</span> <span class="unit">KTS</span>
            </div>
            <div class="instrument">
                <span class="label">Altitude</span>
                <span class="value" id="hud-alt">0</span> <span class="unit">FT</span>
            </div>
            <div class="instrument">
                <span class="label">Heading</span>
                <span class="value" id="hud-hdg">000</span> <span class="unit">DEG</span>
            </div>
            <div class="instrument" style="border-left-color: #ff9900;">
                <span class="label" style="color:#ff9900">Vert Speed</span>
                <span class="value" id="hud-vs">0</span> <span class="unit">FT/S</span>
            </div>
            <div class="instrument" style="border-left-color: #ffcc00;">
                <span class="label" style="color:#ffcc00">Thrust</span>
                <span class="value" id="hud-rpm">0</span> <span class="unit">%</span>
            </div>
        </div>
    
        <div id="quality-selector">
            <span class="label">Graphics Quality</span>
            <div class="button-group">
                <button id="btn-sd" onclick="setQuality('SD')" class="active">SD (Smooth)</button>
                <button id="btn-hd" onclick="setQuality('HD')">HD (High)</button>
            </div>
        </div>

        <div id="throttle-wrapper">
            <div id="throttle-fill"></div>
        </div>
        <div id="throttle-label">THRUST</div>
        
        <div id="center-warning">STALL WARNING</div>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script> 
    
    <script>
        // --- å¸¸é‡é…ç½® (çœŸå®ç‰©ç†å‚æ•°) ---
        const CONFIG = {
            runwayZ: 4000,       // è·‘é“èµ·ç‚¹Zåæ ‡
            runwayX: -2000,      // è·‘é“ä¸­å¿ƒXåæ ‡
            
            // ç‰©ç†å‚æ•° - é»˜è®¤ä½¿ç”¨ F-35 çš„å‚æ•°ï¼Œå°†åœ¨ changePlane ä¸­è¢«è¦†ç›–
            mass: 18000,         
            maxThrust: 420000,   
            dragCoeff: 0.035,    
            liftCoeff: 0.6,      
            wingArea: 75,        
            gravity: 9.81,       
            
            // æ“æ§å“åº” (ç”±äºè´¨é‡å¤§ï¼Œå“åº”ä¼šå˜æ…¢ï¼Œæ¨¡æ‹Ÿæƒ¯æ€§)
            rotDamping: 2.5,     
            pitchSpeed: 1.2,
            rollSpeed: 2.0,
            yawSpeed: 0.8
        };
        
        // ä¼˜åŒ–ï¼šæ–°å¢é£æœºç»Ÿè®¡æ•°æ®ï¼Œç”¨äºæ›´æ–° UI å’Œç‰©ç†å‚æ•°
        const PLANE_STATS = [
            {
                name: "BOEING 777ER COMMERCIAL",
                mass: 18000, // KG
                maxThrust: 420000, // N
                liftCoeff: 0.6,
                groundHeight: 2.8, // m
                path: 'plane1.glb'
            },
            {
                name: "F-35B GERMANY FIGHTER JET",
                mass: 10000, // KG
                maxThrust: 250000, // N
                liftCoeff: 0.8,
                groundHeight: 9.5, // m
                path: 'plane2.glb'
            }
        ];


        // --- å¸§ç‡/ç‰©ç†ä¼˜åŒ–å¸¸é‡ ---
        const PHYSICS_STEP = 1/120; // ç‰©ç†æ­¥é•¿ï¼š120 Hz
        let physicsTimeAccumulator = 0; // ç‰©ç†æ—¶é—´ç´¯åŠ å™¨

        // --- å…¨å±€ç”»è´¨é¢„è®¾ ---
        const QUALITY_PRESETS = {
            SD: {
                shadowMapSize: 2048,
                pixelRatio: 1.0, 
                shadowFar: 20000,
                dirLightIntensity: 1.2,
                hemiLightIntensity: 0.5
            },
            HD: {
                shadowMapSize: 8192,
                pixelRatio: window.devicePixelRatio, 
                shadowFar: 40000,
                dirLightIntensity: 1.8,
                hemiLightIntensity: 0.7
            }
        };

        let currentQuality = 'SD'; // é»˜è®¤è®¾ç½®ä¸º SD

        let splashScene, splashCamera, splashRenderer, splashClock;
        let splashPlaneGroup;
        let planeModels = [];
        let currentPlaneIndex = 0;
        const planeModelPaths = PLANE_STATS.map(stat => stat.path);

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, clock;
        let planeGroup; 
        let propL, propR; 
        let shadowPlane; 
        
        let input = { w:0, s:0, a:0, d:0, q:0, e:0, shift:0, space:0 };
        let cameraMode = 0; // 0: Chase (å°¾éš), 1: Cockpit (åº§èˆ±), 2: Orbital (å…¨æ™¯/å¡”å°)

        // é¼ æ ‡æ§åˆ¶å˜é‡
        let isDragging = false;
        let mouseX = 0, mouseY = 0;
        let orbitAlpha = 0; // æ°´å¹³æ—‹è½¬è§’åº¦
        let orbitBeta = 0.4; // å‚ç›´æ—‹è½¬è§’åº¦
        const orbitDistance = 150; // ç¯ç»•åŠå¾„
        
        // ğŸš€ FIX: æ¨¡å‹æœ¬åœ°æ—‹è½¬åç§»é‡ å’Œ åŠ¨æ€ç¦»åœ°é«˜åº¦
        let modelOffsetQuat = new THREE.Quaternion(); 
        let dynamicGroundHeight = 2.8; 

        // ç‰©ç†çŠ¶æ€å¯¹è±¡
        const physics = {
            // ğŸš€ FIX: åˆå§‹ä½ç½®ä½¿ç”¨åŠ¨æ€é«˜åº¦
            pos: new THREE.Vector3(CONFIG.runwayX, dynamicGroundHeight, CONFIG.runwayZ), 
            vel: new THREE.Vector3(0, 0, 0),
            acc: new THREE.Vector3(0, 0, 0),
            quat: new THREE.Quaternion(),
            rotVel: new THREE.Vector3(0, 0, 0), // è§’é€Ÿåº¦
            throttle: 0,
            brake: false,
            grounded: true,
            crashed: false
        };

        // âš ï¸ æ–°å¢ LoadingManager
        let loadingManager;
        
        function startGame() {
            document.getElementById('splash').style.display = 'none';
            document.getElementById('loading-screen').style.display = 'flex'; // æ˜¾ç¤ºåŠ è½½å±å¹•
            
            // ç¡®ä¿åˆ›å»ºæ­£ç¡®çš„é£æœºæ¨¡å‹
            const selectedModelPath = PLANE_STATS[currentPlaneIndex].path;
            
            // å¯åŠ¨æ¸¸æˆå‰ï¼Œå°†å½“å‰é£æœºçš„ç‰©ç†å‚æ•°å†™å…¥ CONFIG
            const currentStats = PLANE_STATS[currentPlaneIndex];
            CONFIG.mass = currentStats.mass;
            CONFIG.maxThrust = currentStats.maxThrust;
            CONFIG.liftCoeff = currentStats.liftCoeff;
            dynamicGroundHeight = currentStats.groundHeight;

            // é‡ç½®ç‰©ç†çŠ¶æ€åˆ°æ–°çš„é«˜åº¦
            physics.pos.set(CONFIG.runwayX, dynamicGroundHeight, CONFIG.runwayZ);
            physics.vel.set(0, 0, 0);
            physics.quat.identity();
            physics.rotVel.set(0, 0, 0);
            physics.throttle = 0;
            physics.grounded = true;
            physics.crashed = false;
            
            // ç¡®ä¿ HUD è­¦å‘Šéšè—
            document.getElementById('center-warning').style.display = 'none';

            init(selectedModelPath);
        }
        
        window.startGame = startGame; 

        let dirLight, hemiLight; // âš ï¸ å£°æ˜ä¸ºå…¨å±€å˜é‡æˆ–æ–‡ä»¶çº§å˜é‡ï¼Œä»¥ä¾¿ setQuality è®¿é—®
        
        // ğŸš€ FIX: æ–°å¢ï¼šæ ¹æ®å½“å‰é£æœºæ¨¡å‹æ›´æ–°ç‰©ç†ç¦»åœ°é«˜åº¦
        function updatePlanePhysicsHeight(height) {
            dynamicGroundHeight = height;
            
            // ç¡®ä¿ç‰©ç†ä½ç½®ç«‹å³æ›´æ–°åˆ°æ–°çš„æ­£ç¡®ç¦»åœ°é«˜åº¦
            if (physics.grounded) {
                physics.pos.y = height;
            }
            // ç¡®ä¿åˆå§‹ä½ç½®ä¹Ÿåœ¨æ–°çš„é«˜åº¦ä¸Š
            if (physics.pos.y < height) {
                physics.pos.y = height;
            }
        }

        // æ¥å—é€‰ä¸­çš„é£æœºæ¨¡å‹è·¯å¾„
        function init(modelPath) {
            clock = new THREE.Clock();
            
            // âš ï¸ åˆå§‹åŒ– LoadingManager
            loadingManager = new THREE.LoadingManager();
            loadingManager.onProgress = function(url, itemsLoaded, itemsTotal) {
                const percent = Math.floor(itemsLoaded / itemsTotal * 100);
                document.getElementById('loading-progress-fill').style.width = percent + '%';
                document.getElementById('loading-status').innerText = `(${percent}%) Loading: ${url.split('/').pop()}`;
            };

            loadingManager.onLoad = function() {
                // æ‰€æœ‰èµ„äº§åŠ è½½å®Œæ¯•åï¼Œéšè—åŠ è½½å±å¹•ï¼Œå¯åŠ¨åŠ¨ç”»å¾ªç¯
                console.log('All assets loaded. Starting game...');
                document.getElementById('loading-screen').style.display = 'none';
                animate();
            };

            // ... (æ¸²æŸ“å™¨è®¾ç½®) ...
            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0; 
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            scene.fog = new THREE.Fog(0x87CEEB, 2000, 50000); 

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.5, 300000);

            // ç¯å¢ƒå…‰
            hemiLight = new THREE.HemisphereLight(0xffffff, 0x3b4c5a, 0.7); 
            scene.add(hemiLight);

            // å¤ªé˜³å…‰
            dirLight = new THREE.DirectionalLight(0xfff0dd, 1.8); 
            dirLight.position.set(3000, 5000, 2000);
            dirLight.castShadow = true;
            
            const d = 5000;
            dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
            dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
            
            dirLight.shadow.bias = -0.0001;
            scene.add(dirLight);
            
            setQuality('HD'); // é»˜è®¤ä½¿ç”¨ HD

            // æ„å»ºä¸–ç•Œ (ä½¿ç”¨ LoadingManager çš„ GLTFLoader)
            createRealisticWorld();
            createDetailedPlane(modelPath); // ä½¿ç”¨ä¼ å…¥çš„æ¨¡å‹è·¯å¾„

            // ç›‘å¬
            window.addEventListener('resize', onResize);
            document.addEventListener('keydown', (e) => handleKey(e, 1));
            document.addEventListener('keyup', (e) => handleKey(e, 0));
            
            // é¼ æ ‡ç›‘å¬å™¨
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('wheel', onMouseWheel);
        }
        // --- ç‰©ç†å¼•æ“æ ¸å¿ƒ (ä½¿ç”¨å›ºå®šæ­¥é•¿è¿­ä»£) ---
        function updatePhysics(dt) {
            
            // ç´¯åŠ æ—¶é—´
            physicsTimeAccumulator += dt;
            
            while (physicsTimeAccumulator >= PHYSICS_STEP) {
                // ç¡®ä¿ dt ä½¿ç”¨å›ºå®šçš„ç‰©ç†æ­¥é•¿
                performPhysicsStep(PHYSICS_STEP);
                physicsTimeAccumulator -= PHYSICS_STEP;
            }
        }

        // --- å®é™…çš„ç‰©ç†è®¡ç®—å‡½æ•° (å·²åº”ç”¨ dynamicGroundHeight ä¿®å¤) ---
function performPhysicsStep(dt) {
     // 1. è¾“å…¥å¤„ç†
    if (input.shift) physics.throttle = Math.min(1.0, physics.throttle + dt * 0.4);
    if (input.space) physics.throttle = Math.max(0.0, physics.throttle - dt * 1.5);
    
    // 2. åŸºç¡€çŸ¢é‡è·å–
    const pos = physics.pos;
    const vel = physics.vel;
    const rot = physics.quat;
    
    let speed = vel.length();

    // æœºèº«åæ ‡ç³»æ–¹å‘
    const vForward = new THREE.Vector3(0, 0, -1).applyQuaternion(rot).normalize();
    const vUp = new THREE.Vector3(0, 1, 0).applyQuaternion(rot).normalize();
    
    // 3. é€Ÿåº¦å’Œè¿è§’è®¡ç®—
    physics.grounded = (pos.y <= dynamicGroundHeight + 0.1); 

    // è®¡ç®—å‰å‘ç©ºé€Ÿ (æŠ•å½±åˆ°æœºå¤´æ–¹å‘çš„é€Ÿåº¦)
    const forwardSpeed = vel.dot(vForward); 
    
    // è®¡ç®—è¿è§’ï¼ˆAngle of Attack, AoAï¼‰
    const velDir = vel.clone().normalize();
    let aoa = Math.acos(vForward.dot(velDir));
    
    if (velDir.dot(vUp) > 0) { 
        aoa = -aoa;
    }
    
    aoa = THREE.MathUtils.clamp(aoa, -0.26, 0.26); 
    
    let liftFactor = aoa * 3.0; 
    liftFactor = Math.max(liftFactor, 0.1); 

    // VR é€Ÿåº¦é˜ˆå€¼ï¼š140 KTS (çº¦ 72 m/s)
    const V_R_SPEED = 72; 

    // --- æ ¸å¿ƒä¿®å¤ï¼šæ¶ˆé™¤æ¼‚ç§» (æ°”åŠ¨ç¨³å®šæ€§) ---
    if (!physics.grounded && speed > 1.0) {
        const targetVel = vForward.clone().multiplyScalar(speed);
        const stability = Math.min(speed / 300, 1.0) * 0.15;
        vel.lerp(targetVel, stability);
    }

    // --- åŠ›å­¦ç´¯åŠ  ---
    const force = new THREE.Vector3(0, 0, 0);
    const airDensity = 1.225;

    // A. é‡åŠ›
    force.add(new THREE.Vector3(0, -CONFIG.gravity * CONFIG.mass, 0));

    // B. æ¨åŠ›
    const thrust = vForward.clone().multiplyScalar(physics.throttle * CONFIG.maxThrust);
    force.add(thrust);

    // C. å‡åŠ› (Lift) - å‚ç›´äºæœºç¿¼
    const speedSq = forwardSpeed * forwardSpeed;
    let liftForce = 0;
    if (forwardSpeed > 0) {
        liftForce = 0.5 * airDensity * speedSq * CONFIG.liftCoeff * CONFIG.wingArea * liftFactor;
    }
    
    const liftVec = vUp.clone().multiplyScalar(liftForce);
    force.add(liftVec);


    // D. é˜»åŠ› (Drag)
    const dragMag = 0.5 * airDensity * (speed * speed) * CONFIG.dragCoeff * CONFIG.wingArea;
    if (speed > 0) {
        const dragDir = vel.clone().normalize().negate();
        const brakeDrag = input.space ? 5.0 : 1.0; 
        force.add(dragDir.multiplyScalar(dragMag * brakeDrag));
    }

    // åœ°é¢æ¥è§¦åä½œç”¨åŠ›
    const groundDelta = pos.y - dynamicGroundHeight; 
    if (groundDelta <= 0.1) { 
        const springForce = CONFIG.mass * CONFIG.gravity * 3.0 * (0.1 - groundDelta); 
        const dampForce = -vel.y * CONFIG.mass * 0.5; 
        
        const reactionForce = new THREE.Vector3(0, springForce + dampForce, 0);
        force.add(reactionForce);

        // åœ°é¢æ‘©æ“¦
        const friction = vel.clone().multiplyScalar(-2000);
        friction.y = 0; // åªå½±å“æ°´å¹³é€Ÿåº¦
        force.add(friction);
        
        // ç¡®ä¿ä¸ç©¿é€åœ°é¢
        if (pos.y < dynamicGroundHeight) { 
            pos.y = dynamicGroundHeight;
        }
    }


    // --- ç§¯åˆ†è®¡ç®— (F=ma) ---
    physics.acc.copy(force.divideScalar(CONFIG.mass));
    physics.vel.add(physics.acc.clone().multiplyScalar(dt));
    physics.pos.add(physics.vel.clone().multiplyScalar(dt));
    
    // â­ æ–°å¢é€»è¾‘ï¼šé£æœºåœ¨åœ°é¢ä¸”é€Ÿåº¦ < 50 knots æ—¶ç¦ç”¨wsadqe
    const V_50_KTS_MPS = 25.7; // 50 èŠ‚ â‰ˆ 25.7 m/s

    if (physics.grounded && speed < V_50_KTS_MPS) {
        // ç¦ç”¨ä¿¯ä»°ã€æ»šè½¬å’Œåèˆªè¾“å…¥
        input.w = 0;
        input.s = 0;
        input.a = 0;
        input.d = 0;
        input.q = 0;
        input.e = 0;
    }
    // â­ æ–°å¢é€»è¾‘ç»“æŸ

    // --- æ—‹è½¬æ§åˆ¶ ---
    const aeroFactor = Math.min(Math.max((forwardSpeed / 100), 0.5), 1.0); 

    let targetRoll = (input.a - input.d) * CONFIG.rollSpeed * aeroFactor;
    let targetYaw = (input.q - input.e) * CONFIG.yawSpeed * aeroFactor;

    if (physics.grounded && forwardSpeed < V_R_SPEED) {
        // å¦‚æœä½äº VR é€Ÿåº¦ï¼Œä»ç„¶å…è®¸é¼»è½®è½¬å‘ï¼Œä½†ç¦ç”¨æ»šè½¬
        targetRoll = 0; 
        // æ³¨æ„ï¼šå› ä¸ºä¸Šé¢å·²ç»å°† input.q/e ç½®é›¶ï¼Œæ‰€ä»¥è¿™è¡Œä»£ç å¦‚æœé€Ÿåº¦ä½äº 50kts ä¹Ÿä¸ä¼šç”Ÿæ•ˆ
        targetYaw = (input.q - input.e) * 0.5; 
    } else if (physics.grounded) {
        // å¦‚æœé«˜äº VR é€Ÿåº¦ï¼Œæ··åˆè½¬å‘ï¼Œä½†ä»ç¦ç”¨æ»šè½¬
        targetRoll = 0; 
        targetYaw = (input.q - input.e + (input.a - input.d) * 0.5); 
    }
    

    const targetRot = new THREE.Vector3(
        (input.s - input.w) * CONFIG.pitchSpeed * aeroFactor, 
        targetYaw,   
        targetRoll   
    );

    physics.rotVel.lerp(targetRot, dt * CONFIG.rotDamping);

    const deltaRot = new THREE.Quaternion().setFromEuler(new THREE.Euler(
        physics.rotVel.x * dt,
        physics.rotVel.y * dt,
        physics.rotVel.z * dt,
        'XYZ'
    ));
    physics.quat.multiply(deltaRot).normalize();


    // --- UI é€»è¾‘ & å æ¯åˆ¤å®š ---
    const centerWarn = document.getElementById('center-warning');
    const speedKnots = Math.floor(speed * 1.94); 

    const inRunwayArea = (pos.x > CONFIG.runwayX - 1000 && pos.x < CONFIG.runwayX + 1000 && pos.y < dynamicGroundHeight + 1.0); 
    
    if (physics.crashed) {
        // å¦‚æœå·²ç»å æ¯ï¼Œä¿æŒè­¦å‘ŠçŠ¶æ€
    }
    else if (physics.grounded && speedKnots > 20 && !inRunwayArea) {
        centerWarn.style.display = 'block';
        centerWarn.innerText = "CRASH: OFF-RUNWAY LANDING";
        
        physics.vel.set(0, 0, 0);
        physics.throttle = 0;
        physics.crashed = true;
    } 
    else if (!physics.grounded && speedKnots < 135 && speedKnots > 20) {
        centerWarn.style.display = 'block';
        centerWarn.innerText = `STALL WARNING (V=${speedKnots} KTS)`;
        
    } else {
        centerWarn.style.display = 'none';
    }
}

        function initSplashModel() {
            splashClock = new THREE.Clock();

            // 1. è®¾ç½®æ¸²æŸ“å™¨
            splashRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            splashRenderer.setPixelRatio(window.devicePixelRatio);
            const container = document.getElementById('plane-model-container');
            splashRenderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(splashRenderer.domElement);
            
            // 2. åœºæ™¯å’Œç›¸æœº
            splashScene = new THREE.Scene();
            splashCamera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 1, 1000);
            splashCamera.position.set(0, 10, 50); 
            splashCamera.lookAt(0, 0, 0);

            // 3. å…‰ç…§
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.5); // ç¯å¢ƒå…‰
            splashScene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 2.0); // æ–¹å‘å…‰
            dirLight.position.set(50, 50, 50);
            splashScene.add(dirLight);

            // 4. åŠ è½½æ‰€æœ‰æ¨¡å‹
            const loader = new THREE.GLTFLoader();
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/draco/');
            loader.setDRACOLoader(dracoLoader);
            
            // å¼‚æ­¥åŠ è½½æ‰€æœ‰é£æœºæ¨¡å‹
            planeModelPaths.forEach((path, index) => {
                loader.load(
                    path,
                    (gltf) => {
                        const model = gltf.scene;
                        
                        // ğŸš€ FIX: æ ¹æ® index æ§åˆ¶åˆå§‹æ–¹å‘å’Œå¤§å°
                        if (index === 1) {
                            // ç¬¬äºŒä¸ªé£æœºæ¨¡å‹ (plane2.glb)
                            model.scale.set(0.3, 0.3, 0.3);       // è®¾ç½®å¤§å°ä¸º 100%
                            model.rotation.set(0, Math.PI * 0.75, 0); // è®¾ç½®åˆå§‹æ–¹å‘ä¸º Y è½´æ—‹è½¬ 135 åº¦ 
                        } else {
                            // ç¬¬ä¸€ä¸ªé£æœºæ¨¡å‹ (plane1.glb) 
                            model.scale.set(0.8, 0.8, 0.8); 
                            model.rotation.set(0, Math.PI / 2, 0); 
                        }
                        
                        model.visible = (index === currentPlaneIndex); 
                        splashScene.add(model);
                        planeModels.push(model);
                        console.log(`Plane model ${path} loaded.`);
                        
                        // ç¡®ä¿åŠ è½½å®Œååˆå§‹åŒ– UI
                        if(planeModels.length === planeModelPaths.length) {
                             changePlane(0);
                        }
                    },
                    undefined,
                    (error) => {
                        console.error(`Error loading plane model ${path}:`, error);
                        const box = new THREE.Mesh(
                            new THREE.BoxGeometry(10, 10, 30),
                            new THREE.MeshStandardMaterial({ color: 0xaaaaaa })
                        );
                        box.visible = (index === currentPlaneIndex);
                        splashScene.add(box);
                        planeModels.push(box);
                    }
                );
            });
            
            // å¼€å§‹æ¨¡å‹åŠ¨ç”»å¾ªç¯
            animateSplashModel();
            window.addEventListener('resize', onSplashResize);
        }

        // å¯åŠ¨ç•Œé¢çš„åŠ¨ç”»å¾ªç¯
        function animateSplashModel() {
            requestAnimationFrame(animateSplashModel);
            
            const dt = splashClock.getDelta();

            // æ—‹è½¬å½“å‰æ¨¡å‹
            if (planeModels.length > 0 && planeModels[currentPlaneIndex]) {
                planeModels[currentPlaneIndex].rotation.y += 0.2 * dt; // æ…¢é€Ÿæ—‹è½¬
            }
            
            splashRenderer.render(splashScene, splashCamera);
        }

        // åˆ‡æ¢é£æœºæ¨¡å‹ (å·²æ›´æ–° UI é€»è¾‘)
        function changePlane(direction) {
            if (planeModels.length === 0) return;
            
            // éšè—å½“å‰æ¨¡å‹
            if (planeModels[currentPlaneIndex]) {
                 planeModels[currentPlaneIndex].visible = false;
            }

            // è®¡ç®—æ–°çš„ç´¢å¼•
            currentPlaneIndex = (currentPlaneIndex + direction + planeModels.length) % planeModels.length;

            // æ˜¾ç¤ºæ–°æ¨¡å‹
            if (planeModels[currentPlaneIndex]) {
                 planeModels[currentPlaneIndex].visible = true;
            }
            
            // â­ UI/UX ä¼˜åŒ–ï¼šæ›´æ–°å‚æ•°æ˜¾ç¤ºåŒº
            const currentStats = PLANE_STATS[currentPlaneIndex];
            document.getElementById('plane-name').innerText = currentStats.name;
            document.getElementById('stat-mass').innerText = currentStats.mass.toLocaleString();
            // è½¬æ¢ä¸º kN æ˜¾ç¤º
            document.getElementById('stat-thrust').innerText = (currentStats.maxThrust / 1000).toLocaleString(); 
            document.getElementById('stat-lift').innerText = currentStats.liftCoeff;
            document.getElementById('stat-height').innerText = currentStats.groundHeight;


            console.log(`Switched to Plane Index: ${currentPlaneIndex}`);
        }
        window.changePlane = changePlane; // æš´éœ²ç»™ HTML çš„ onclick

        // å¯åŠ¨ç•Œé¢çª—å£å¤§å°è°ƒæ•´
        function onSplashResize() {
            const container = document.getElementById('plane-model-container');
            splashCamera.aspect = container.clientWidth / container.clientHeight;
            splashCamera.updateProjectionMatrix();
            splashRenderer.setSize(container.clientWidth, container.clientHeight);
        }

        // âš ï¸ é‡è¦ï¼šåœ¨é¡µé¢åŠ è½½æ—¶è°ƒç”¨åˆå§‹åŒ–å‡½æ•°
        document.addEventListener('DOMContentLoaded', initSplashModel);

        // âš ï¸ ä¹Ÿè¦æ›´æ–°ä¸»æ¸¸æˆçš„ onResize å‡½æ•°ï¼Œä»¥é¿å…å†²çª
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // ç¡®ä¿åœ¨ä¸»æ¸¸æˆå¯åŠ¨åï¼Œä¸å†å½±å“ splash æ¸²æŸ“å™¨
            if (document.getElementById('splash').style.display !== 'none') {
                onSplashResize();
            }
        }
        // --- æ ¸å¿ƒç”»è´¨æ§åˆ¶å‡½æ•° (ä¿®è®¢ç‰ˆ) ---
        function setQuality(quality) {
            // âš ï¸ ç¡®ä¿åœ¨æ¸¸æˆå¯åŠ¨å‰è°ƒç”¨æ—¶ dirLight å’Œ hemiLight å·²ç»åˆå§‹åŒ–
            if (!dirLight || !hemiLight) {
                // å¦‚æœåœ¨ init ä¹‹å‰è°ƒç”¨ï¼Œåˆ™åªæ›´æ–° UI æ ·å¼å’Œ currentQuality
                currentQuality = quality;
                const sdBtn = document.getElementById('btn-sd');
                const hdBtn = document.getElementById('btn-hd');
                if (sdBtn && hdBtn) {
                    sdBtn.classList.remove('active');
                    hdBtn.classList.remove('active');
                    document.getElementById(`btn-${quality.toLowerCase()}`).classList.add('active');
                }
                return; 
            }
            
            if (currentQuality === quality) return; 

            currentQuality = quality;
            const settings = QUALITY_PRESETS[quality];

            // 1. æ›´æ–°æ¸²æŸ“å™¨è®¾ç½®
            renderer.setPixelRatio(settings.pixelRatio);
            renderer.shadowMap.needsUpdate = true; // è§¦å‘é˜´å½±è´´å›¾æ›´æ–°

            // 2. æ›´æ–°å…‰ç…§å‚æ•°
            // **ä¿®æ­£ç‚¹**ï¼šç›´æ¥ä½¿ç”¨å…¨å±€çš„ dirLight å’Œ hemiLight
            dirLight.shadow.mapSize.width = settings.shadowMapSize; 
            dirLight.shadow.mapSize.height = settings.shadowMapSize; 
            dirLight.intensity = settings.dirLightIntensity;
            dirLight.shadow.camera.far = settings.shadowFar;
            dirLight.shadow.camera.updateProjectionMatrix();

            hemiLight.intensity = settings.hemiLightIntensity;

            // 3. æ›´æ–° UI æŒ‰é’®æ ·å¼
            document.getElementById('btn-sd').classList.remove('active');
            document.getElementById('btn-hd').classList.remove('active');
            document.getElementById(`btn-${quality.toLowerCase()}`).classList.add('active');
            
            console.log(`Quality set to: ${quality}`);
        }
        window.setQuality = setQuality; // æš´éœ²ç»™ HTML çš„ onclick

        // --- è§†è§‰æ„å»ºï¼šå†™å®é£æ ¼ (æœªä¿®æ”¹) ---
        function createRealisticWorld() {
            const simplex = new SimplexNoise();
            const size = 60000;
            const segs = 128; 
            const geo = new THREE.PlaneGeometry(size, size, segs, segs);
            const pos = geo.attributes.position;
            const colors = [];

            const cConcrete = new THREE.Color(0x606060); 
            const cGrass = new THREE.Color(0x3a5f0b);    
            const cDirt = new THREE.Color(0x5a4d3b);
            
            // å®šä¹‰è·‘é“/æœºåœºä¸­å¿ƒå’ŒåŸå¸‚æ ¸å¿ƒçš„å¤§è‡´ä½ç½®
            const airportCenterX = CONFIG.runwayX; // æœºåœºXåæ ‡
            const airportCenterZ = CONFIG.runwayZ - 4000; // æœºåœºZåæ ‡é™„è¿‘
            
            // é™åˆ¶å±±è„‰çš„æœ€å°è·ç¦»ï¼š10 km = 10000 å•ä½
            const MIN_MOUNTAIN_DISTANCE = 10000; 
            
            // åŸå¸‚ä¸­å¿ƒçš„ä¼°ç®—ä½ç½®
            const cityBlockSize = 8000; 
            const cityGridSize = 3; 
            const cityStartPosX = -cityBlockSize * Math.floor(cityGridSize / 2);
            const cityStartPosZ = -cityBlockSize * Math.floor(cityGridSize / 2);
            const cityCenterX = cityStartPosX + cityBlockSize * cityGridSize / 2;
            const cityCenterZ = cityStartPosZ + cityBlockSize * cityGridSize / 2;
            
            // å¹³å¦åŒºåŸŸçš„åŠå¾„
            const flatRadius = 10000; 

            for(let i=0; i<pos.count; i++){
                let x = pos.getX(i);
                let y = pos.getY(i); 
                
                let h = 0;
                let col = cGrass.clone(); // ä½¿ç”¨ clone é¿å…ä¿®æ”¹å¸¸é‡é¢œè‰²

                // è·ç¦»æœºåœºä¸­å¿ƒçš„æ°´å¹³è·ç¦»
                const distToAirport = Math.sqrt(Math.pow(x - airportCenterX, 2) + Math.pow(y - airportCenterZ, 2));
                
                // è·ç¦»åŸå¸‚ä¸­å¿ƒçš„æ°´å¹³è·ç¦»
                const distToCity = Math.sqrt(Math.pow(x - cityCenterX, 2) + Math.pow(y - cityCenterZ, 2));
                
                // å–ä¸¤è€…ä¸­è¾ƒå°çš„è·ç¦»ä½œä¸ºé™åˆ¶è·ç¦»
                const distToSafeZone = Math.min(distToAirport, distToCity);

                // è·‘é“åŒºåŸŸ
                const inRunway = (Math.abs(x - CONFIG.runwayX) < 1000 && Math.abs(y - CONFIG.runwayZ) < 500); 
                const inAirportGrass = (Math.abs(x - CONFIG.runwayX) < 3000 && Math.abs(y - CONFIG.runwayZ) < 6000); 

                if (inRunway) {
                    h = 0;
                    col = cConcrete; 
                } else if (inAirportGrass) {
                    h = 0;
                    col = new THREE.Color(0x4a6f1b); // æ·±è‰²è‰åœ°
                } else if (distToSafeZone < MIN_MOUNTAIN_DISTANCE) {
                    // å¹³æ»‘è¿‡æ¸¡åˆ°å±±è„‰
                    if (distToSafeZone > MIN_MOUNTAIN_DISTANCE - 4000) {
                        const transitionFactor = (distToSafeZone - (MIN_MOUNTAIN_DISTANCE - 4000)) / 4000;
                        let n = simplex.noise2D(x*0.0001, y*0.0001);
                        h = Math.max(0, n * 2500 * transitionFactor);
                        if (h > 500) col = cDirt; else col = cGrass;
                    } else {
                        // å¹³å¦åŒºåŸŸçš„è½»å¾®èµ·ä¼
                        if ((Math.sin(x*0.01) * Math.cos(y*0.01)) > 0) col = new THREE.Color(0x355515);
                    }
                } else {
                    // è¶…è¿‡å®‰å…¨åŒºåŸŸï¼Œæ­£å¸¸ç”Ÿæˆå±±è„‰
                    let n = simplex.noise2D(x*0.0001, y*0.0001);
                    h = Math.max(0, n * 2500); 
                    if (h > 500) col = cDirt;
                    else col = cGrass;
                }

                // âš ï¸ æ­¤å¤„ pos.setZ(i, h) åœ¨ three.js ä¸­æ˜¯è®¾ç½® Y è½´é«˜åº¦
                pos.setZ(i, h); 
                colors.push(col.r, col.g, col.b);
            }
            
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geo.computeVertexNormals();
            
            const terrain = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ 
                vertexColors: true, 
                roughness: 0.9, 
                metalness: 0.05 
            }));
            terrain.rotation.x = -Math.PI/2;
            terrain.receiveShadow = true;
            scene.add(terrain);

            // ğŸš€ 2. åŠ è½½æœºåœºè·‘é“ (Runway) GLTF æ¨¡å‹
            // âš ï¸ ä½¿ç”¨ LoadingManager
            const runwayLoader = new THREE.GLTFLoader(loadingManager);
            
            const dracoLoaderRunway = new THREE.DRACOLoader(loadingManager);
            dracoLoaderRunway.setDecoderPath( 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/' ); 
            runwayLoader.setDRACOLoader( dracoLoaderRunway );

            runwayLoader.load(
                'runway.glb', 
                function (gltf) {
                    const loadedRunway = gltf.scene;

                    loadedRunway.scale.set(0.1, 0.12, 0.1); 
                    loadedRunway.position.set(-760, 1, 3800); 

                    loadedRunway.traverse(c => {
                        if (c.isMesh) {
                            c.castShadow = true;
                            c.receiveShadow = true;
                        }
                    });
                    scene.add(loadedRunway);
                    console.log('Runway model runway.gltf loaded successfully!');
                },
                undefined, // ä¸å†éœ€è¦ onProgressï¼Œäº¤ç»™ LoadingManager
                function (error) {
                    console.error('An error occurred while loading the runway model (runway.gltf):', error);
                }
            );

            // 3. åŸå¸‚ç”Ÿæˆ
            createCityModel();
        }

        // --- åŸå¸‚ GLB æ¨¡å‹é‡å¤æ”¾ç½®å‡½æ•° (æœªä¿®æ”¹) ---
        function createCityModel() {
            // âš ï¸ ä½¿ç”¨ LoadingManager
            const cityLoader = new THREE.GLTFLoader(loadingManager);
            
            const cityBlockSize = 8000; 
            const cityGridSize = 3; 

            cityLoader.load('city1.glb', function(gltf) {

                const cityBlock = gltf.scene;

                // ç»Ÿä¸€è®¾ç½® cityBlock çš„å‡ ä½•ä½“ç¼©æ”¾ï¼ˆå¦‚æœéœ€è¦åœ¨æ¨¡å‹å†…éƒ¨å¤„ç†ï¼‰
                cityBlock.traverse(o => {
                    if (o.isMesh) {
                        o.castShadow = true;
                        o.receiveShadow = true;
                        // ç§»é™¤å†…éƒ¨çš„ scale è®¾ç½®ï¼Œè®©å¤–éƒ¨ç»Ÿä¸€æ§åˆ¶
                        // o.scale.set(3,3,3); 
                    }
                });

                const cityGroup = new THREE.Group();

                const startX = -cityBlockSize * Math.floor(cityGridSize / 2);
                const startZ = -cityBlockSize * Math.floor(cityGridSize / 2);

                for (let x = 0; x < cityGridSize; x++) {
                    for (let z = 0; z < cityGridSize; z++) {

                        const instance = cityBlock.clone();

                        // ç»Ÿä¸€åœ¨å®ä¾‹ä¸Šè®¾ç½®ç¼©æ”¾ï¼Œå¹¶åº”ç”¨ä½ç§»
                        instance.scale.set(20, 20, 20); 
                        instance.position.set(
                            startX + x * cityBlockSize,
                            0, // ç¡®ä¿é«˜åº¦ä¸º 0
                            startZ + z * cityBlockSize
                        );

                        cityGroup.add(instance);
                    }
                }

                scene.add(cityGroup);
            });
        }


        // --- é£æœºç»†èŠ‚æ¨¡å‹ (å·²åº”ç”¨é«˜åº¦ã€æ—‹è½¬å’Œæ‘„åƒæœºä¿®å¤) ---

        // ğŸš€ ä¿®æ”¹ä¸ºæ¥å—è·¯å¾„å‚æ•°
        function createDetailedPlane(modelPath) {
            // 1. å¦‚æœæ—§é£æœºæ¨¡å‹å­˜åœ¨ï¼Œå…ˆä»åœºæ™¯ä¸­ç§»é™¤å¹¶æ¸…ç†
            if (planeGroup) {
                scene.remove(planeGroup);
            }
            
            // 2. åˆå§‹åŒ– GLTFLoader
            const loader = new THREE.GLTFLoader(loadingManager);
            
            // *** å…³é”®ä¿®å¤ï¼šè®¾ç½® DRACOLoader ***
            const dracoLoaderPlane = new THREE.DRACOLoader(loadingManager);
            dracoLoaderPlane.setDecoderPath( 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/' ); 
            loader.setDRACOLoader( dracoLoaderPlane );
            // **********************************
            
            // 3. åŠ è½½é€‰ä¸­çš„ .glb æ¨¡å‹
            loader.load(
                modelPath,
                function (gltf) {
                    planeGroup = gltf.scene; 
                    
                    // ğŸš€ FIX: é‡ç½®æ¨¡å‹åç§»å››å…ƒæ•°
                    modelOffsetQuat.identity();

                    // æ ¸å¿ƒä¿®å¤ï¼šåœ¨æ¸¸æˆå†…æ§åˆ¶ç¬¬äºŒä¸ªé£æœºçš„ å¤§å° å’Œ æ–¹å‘
                    let scaleFactor = 1.0;
                    let rotationOffsetY = 0; // å±€éƒ¨ Y è½´æ—‹è½¬åç§»é‡ (å¼§åº¦åˆ¶)
                    
                    // ä» PLANE_STATS è·å–å½“å‰é£æœºçš„å‚æ•°
                    const currentStats = PLANE_STATS[currentPlaneIndex];
                    let requiredGroundHeight = currentStats.groundHeight; 

                    if (modelPath === 'plane2.glb') {
                        // ****** è®¾ç½®ç¬¬äºŒä¸ªé£æœºåœ¨æ¸¸æˆä¸­çš„å‚æ•° ******
                        scaleFactor = 0.35;          
                        rotationOffsetY = Math.PI * 1.5; // 270 åº¦æ—‹è½¬ä¿®æ­£ï¼šè·‘é“å¯¹é½ + æ‘„åƒå¤´å¯¹é½
                    } else {
                        // ç¬¬ä¸€ä¸ªé£æœº (plane1.glb)
                        scaleFactor = 0.8; 
                        rotationOffsetY = 0;
                    }
                    
                    // åº”ç”¨å¤§å°
                    planeGroup.scale.set(scaleFactor, scaleFactor, scaleFactor); 
                    
                    // ğŸš€ è°ƒç”¨æ–°å‡½æ•°ï¼Œæ›´æ–°å½“å‰é£æœºçš„ç‰©ç†é«˜åº¦
                    updatePlanePhysicsHeight(requiredGroundHeight); 
                    
                    // âš ï¸ æœ€ç»ˆä¿é™©ï¼šå¼ºåˆ¶é‡ç½®ç‰©ç†ä½ç½®Yè½´åˆ°æ–°çš„é«˜åº¦ï¼Œé˜²æ­¢åˆå§‹åŒ–é”™è¯¯
                    physics.pos.y = requiredGroundHeight;
                    
                    // ğŸš€ å°†æ—‹è½¬åç§»å­˜å…¥ modelOffsetQuat
                    if (rotationOffsetY !== 0) {
                        modelOffsetQuat.setFromAxisAngle(
                            new THREE.Vector3(0, 1, 0), // æ²¿ Y è½´æ—‹è½¬
                            rotationOffsetY
                        );
                    }
                    // *************************************************
                    
                    planeGroup.castShadow = true;
                    planeGroup.traverse(c => { 
                        if (c.isMesh) { 
                            c.castShadow = true; 
                            c.receiveShadow = true; 
                        }
                    });

                    // ä¿æŒé£æœºåœ¨è·‘é“èµ·ç‚¹
                    // æ­¤æ—¶ physics.pos.y å·²ç»æ˜¯æœ€æ–°çš„ requiredGroundHeight
                    planeGroup.position.copy(physics.pos);
                    planeGroup.quaternion.copy(physics.quat);
                    
                    scene.add(planeGroup);
                    console.log(`Plane model ${modelPath} loaded successfully!`);
                    
                    // å½±å­è·Ÿéšé£æœºæ·»åŠ åˆ°åœºæ™¯ä¸­
                    if (shadowPlane) {
                        scene.add(shadowPlane);
                    }
                },
                undefined, 
                function (error) {
                    console.error(`An error occurred while loading the plane model (${modelPath}):`, error);
                }
            );
            
            // å½±å­å¹³é¢åªéœ€åˆ›å»ºä¸€æ¬¡...
            if (!shadowPlane) {
                shadowPlane = new THREE.Mesh(
                    new THREE.CircleGeometry(15, 32), 
                    new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.5 })
                );
                shadowPlane.rotation.x = -Math.PI / 2;
                shadowPlane.position.y = 0.05; 
            }
        }
        
        // **ä¿®æ”¹**ï¼šV é”®åˆ‡æ¢ç›¸æœºæ¨¡å¼ (æ–°å¢ Orbit æ¨¡å¼)
        function changeCamera() {
            cameraMode = (cameraMode + 1) % 3; // 0: Chase, 1: Cockpit, 2: Orbital å¾ªç¯
        }

        function handleKey(e, val) {
            let k = e.key.toLowerCase();
            if (k === " ") k = "space";
            if (k === "v" && val === 1) changeCamera();
            if (input.hasOwnProperty(k)) input[k] = val;
        }
        
        // **æ–°å¢**ï¼šé¼ æ ‡äº‹ä»¶å¤„ç†å‡½æ•° (æœªä¿®æ”¹)
        function onMouseDown(event) {
            if (cameraMode === 2) {
                isDragging = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        }

        function onMouseMove(event) {
            if (isDragging && cameraMode === 2) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                orbitAlpha -= deltaX * 0.005; // æ°´å¹³æ—‹è½¬
                orbitBeta += deltaY * 0.005;  // å‚ç›´æ—‹è½¬

                // é™åˆ¶å‚ç›´æ—‹è½¬èŒƒå›´ï¼Œé˜²æ­¢è§†è§’ç¿»è½¬
                orbitBeta = THREE.MathUtils.clamp(orbitBeta, 0.1, Math.PI - 0.1); 

                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        }

        function onMouseUp() {
            isDragging = false;
        }
        
        function onMouseWheel(event) {
            if (cameraMode === 2) {
                const zoomFactor = event.deltaY * 0.01; 
                // âš ï¸ æ»šè½®ç¼©æ”¾åŠŸèƒ½ï¼ˆå½“å‰ç¦ç”¨ï¼‰
            }
        }


        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- åŠ¨ç”»å¾ªç¯ (å·²åº”ç”¨æ—‹è½¬ã€æ‘„åƒæœºå’Œ UI ä¿®å¤) ---
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta(); // è·å–å®é™…çš„æ¸²æŸ“æ—¶é—´å·®

            // 1. **ç‰©ç†æ›´æ–°**ï¼šä½¿ç”¨å›ºå®šæ­¥é•¿è¿­ä»£ï¼Œä¿è¯ç‰©ç†è®¡ç®—çš„ç²¾ç¡®æ€§å’Œç‹¬ç«‹äºå¸§ç‡
            updatePhysics(dt); 

            // 2. **æ¸²æŸ“/è§†è§‰æ›´æ–°**
            if (planeGroup) {
                // ç‰©ç†åŒæ­¥
                planeGroup.position.copy(physics.pos);
                
                // 180åº¦ä¿®æ­£ (å›ºå®šä¿®æ­£)
                const correctionQuat = new THREE.Quaternion().setFromAxisAngle(
                    new THREE.Vector3(0, 1, 0), 
                    Math.PI
                );
                
                // ğŸš€ FIX: æ ¸å¿ƒæ—‹è½¬ï¼šç»“åˆç‰©ç†å§¿æ€ + 180åº¦ä¿®æ­£ + æ¨¡å‹çš„æœ¬åœ°åç§»
                planeGroup.quaternion
                    .copy(physics.quat)
                    .multiply(correctionQuat)
                    .multiply(modelOffsetQuat); 
                
                // ----------------------------------------------------
                // ğŸš€ FIX: æ‘„åƒæœºåç§»ä¿®æ­£
                
                // 1. å®šä¹‰æ ‡å‡†åç§»å‘é‡ (åŸºäºæ¨¡å‹æœ¬åœ°çš„ -Z ä¸ºå‰æ–¹)
                const chaseOffset = new THREE.Vector3(0, 15, -80); 
                const cockpitOffset = new THREE.Vector3(0, 6, 39);
                
                // 2. å¦‚æœå­˜åœ¨æ¨¡å‹åç§» (plane2è¢«é€‰ä¸­)
                if (!modelOffsetQuat.equals(new THREE.Quaternion())) {
                    // å°†æ¨¡å‹åç§»å››å…ƒæ•°çš„å…±è½­ï¼ˆå³é€†æ—‹è½¬ï¼‰åº”ç”¨åˆ°æ‘„åƒæœºåç§»å‘é‡ä¸Šã€‚
                    const inverseOffsetQuat = modelOffsetQuat.clone().conjugate();
                    
                    chaseOffset.applyQuaternion(inverseOffsetQuat);
                    cockpitOffset.applyQuaternion(inverseOffsetQuat);
                }
                
                const groundHeight = dynamicGroundHeight; // â­ ä½¿ç”¨åŠ¨æ€é«˜åº¦

                // å½±å­è·Ÿéš
                shadowPlane.position.set(physics.pos.x, 0.05, physics.pos.z);
                
                const euler = new THREE.Euler().setFromQuaternion(physics.quat, 'YXZ');
                shadowPlane.rotation.z = euler.y; 

                // æ‘„åƒæœºé€»è¾‘
                if (cameraMode === 0) { // å°¾éšè§†è§’
                    
                    // å°†ä¿®æ­£åçš„åç§»å‘é‡è½¬æ¢åˆ°ä¸–ç•Œåæ ‡
                    const idealCameraPosition = chaseOffset.clone().applyMatrix4(planeGroup.matrixWorld);
                    
                    const safeBuffer = 1.5;   
                    const minCameraY = groundHeight + safeBuffer;
                    
                    if (idealCameraPosition.y < minCameraY) {
                        idealCameraPosition.y = minCameraY;
                    }

                    camera.position.lerp(idealCameraPosition, 0.1); 
                    
                    // LookAt logic is fine, as it uses physics.quat
                    const forward = new THREE.Vector3(0,0,-1).applyQuaternion(physics.quat);
                    const lookAtPos = planeGroup.position.clone().add(forward.multiplyScalar(50));
                    camera.lookAt(lookAtPos);
                } else if (cameraMode === 1) { // åº§èˆ±è§†è§’
                    
                    // å°†ä¿®æ­£åçš„åç§»å‘é‡è½¬æ¢åˆ°ä¸–ç•Œåæ ‡
                    const cockpitPos = cockpitOffset.clone().applyMatrix4(planeGroup.matrixWorld);
                    
                    camera.position.copy(cockpitPos);
                    // FIX: æ‘„åƒæœºæ—‹è½¬å¿…é¡»ä½¿ç”¨åŒ…å«æ‰€æœ‰åç§»çš„ planeGroup.quaternion
                    camera.quaternion.copy(planeGroup.quaternion); 
                    
                } else if (cameraMode === 2) { // é¼ æ ‡æ‹–åŠ¨çš„å…¨æ™¯è§†è§’
                    const target = planeGroup.position.clone();
                    
                    const sinAlpha = Math.sin(orbitAlpha);
                    const cosAlpha = Math.cos(orbitAlpha);
                    const sinBeta = Math.sin(orbitBeta);
                    const cosBeta = Math.cos(orbitBeta);
                    
                    const camX = target.x + orbitDistance * sinBeta * sinAlpha;
                    const camY = target.y + orbitDistance * cosBeta;
                    const camZ = target.z + orbitDistance * sinBeta * cosAlpha;
                    
                    camera.position.set(camX, camY, camZ);
                    camera.lookAt(target); 
                }
            }
            
            // 3. UI æ›´æ–° (åªåœ¨æ¯æ¬¡æ¸²æŸ“æ—¶æ›´æ–°ä¸€æ¬¡)
            const speedKnots = Math.floor(physics.vel.length() * 1.94);
            const vertSpeedFps = Math.floor(physics.vel.y * 3.28); // m/s è½¬æ¢ä¸º ft/s

            document.getElementById('hud-spd').innerText = speedKnots;
            document.getElementById('hud-alt').innerText = Math.floor(physics.pos.y * 3.28);
            document.getElementById('hud-rpm').innerText = Math.floor(physics.throttle * 100);
            document.getElementById('throttle-fill').style.height = (physics.throttle * 100) + '%';
            
            // ä¼˜åŒ–ï¼šæ›´æ–°å‚ç›´é€Ÿåº¦
            document.getElementById('hud-vs').innerText = vertSpeedFps;

            // èˆªå‘
            const eulerUI = new THREE.Euler().setFromQuaternion(physics.quat, 'YXZ'); // é¿å…ä¸ç‰©ç†è®¡ç®—ä¸­çš„ euler å†²çªï¼Œä½¿ç”¨ eulerUI
            let hdg = Math.floor(THREE.MathUtils.radToDeg(-eulerUI.y) % 360);
            if (hdg < 0) hdg += 360; // è½¬æ¢ä¸º 0-360 åº¦
            document.getElementById('hud-hdg').innerText = hdg.toString().padStart(3, '0');
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
