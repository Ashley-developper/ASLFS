<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASL flight simulator</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; user-select: none; }
        
        /* ä»ªè¡¨ç›˜å¸ƒå±€ */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            padding: 25px; box-sizing: border-box; z-index: 10;
        }

        .hud-top-left { display: flex; gap: 20px; }
        
        .instrument {
            background: rgba(10, 20, 30, 0.75); 
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-left: 4px solid #00aaff;
            backdrop-filter: blur(8px); 
            padding: 10px 18px; 
            color: #eee; 
            min-width: 100px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        
        .label { font-size: 10px; color: #88ccff; font-weight: 600; letter-spacing: 1px; margin-bottom: 4px; display:block; text-transform: uppercase;}
        .value { font-size: 26px; font-weight: 700; font-family: 'Consolas', monospace; letter-spacing: -1px; }
        .unit { font-size: 12px; color: #888; margin-left: 4px; font-weight: 400;}

        /* æ²¹é—¨æ¨æ† */
        #throttle-wrapper {
            position: absolute; left: 30px; bottom: 120px; width: 12px; height: 240px;
            background: rgba(0,0,0,0.6); border: 1px solid #555; border-radius: 8px;
            padding: 2px;
        }
        #throttle-fill {
            position: absolute; bottom: 2px; left: 2px; width: 12px; height: 0%;
            background: linear-gradient(to top, #4caf50, #ffeb3b, #ff5722);
            border-radius: 4px; transition: height 0.1s;
        }
        #throttle-label {
            position: absolute; left: 50px; bottom: 120px; color: #fff; font-size: 12px; font-weight: bold;
            transform: rotate(-90deg); transform-origin: left bottom; opacity: 0.7;
        }

        /* è­¦å‘Šä¿¡æ¯ */
        #center-warning {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff3333; font-size: 24px; font-weight: bold; border: 2px solid #ff3333;
            padding: 10px 30px; background: rgba(0,0,0,0.7); display: none;
        }

        /* å¯åŠ¨ç”»é¢ */
        #splash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, #1a2a3a, #000000);
            z-index: 999; display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white;
        }
        h1 { font-size: 64px; margin: 0; font-weight: 300; letter-spacing: 10px; text-transform: uppercase; }
        h1 b { font-weight: 900; color: #00aaff; }
        .controls-grid {
            display: grid; grid-template-columns: auto auto; gap: 15px 30px; margin-top: 40px;
            text-align: left; background: rgba(255,255,255,0.05); padding: 30px; border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .key-box { font-family: monospace; color: #00aaff; font-weight: bold; margin-right: 10px;}
        button {
            margin-top: 50px; padding: 16px 60px; font-size: 18px; font-weight: 600; border: 1px solid #00aaff;
            background: rgba(0, 170, 255, 0.2); color: #fff; cursor: pointer; letter-spacing: 2px;
            transition: all 0.3s; text-transform: uppercase;
        }
        button:hover { background: #00aaff; color: #000; box-shadow: 0 0 30px #00aaff; }
        
        .loader { font-size: 12px; color: #666; margin-top: 20px; }
    </style>
</head>
<body>

    <div id="splash">
        <h1>ASL <b>FLIGHT SIMULATOR</b></h1>
        <p style="color:#8899aa; letter-spacing: 2px;">BETA V 1.0</p>
        
        <div class="controls-grid">
            <div><span class="key-box">SHIFT</span> Increase engine power/thrust.</div>
            <div><span class="key-box">SPACE</span> Apply wheel brakes or air brakes.</div>
            <div><span class="key-box">W / S</span> Pitch the nose up or down (elevator control).</div>
            <div><span class="key-box">A / D</span> Roll the aircraft left or right using ailerons</div>
            <div><span class="key-box">Q / E</span> Steer left or right using the rudder. </div>
            <div><span class="key-box">V</span> Change camera view. </div>
        </div>

        <div style="margin-top:20px; color:#aa8800; font-size:13px;">
            âš  made by Zhanyi Zhou
            <br>This is a beta version
        </div>

        <button onclick="startGame()">INITIALIZE SYSTEMS</button>
    </div>

    <div id="hud-layer">
        <div class="hud-top-left">
            <div class="instrument">
                <span class="label">Airspeed</span>
                <span class="value" id="hud-spd">0</span> <span class="unit">KTS</span>
            </div>
            <div class="instrument">
                <span class="label">Altitude</span>
                <span class="value" id="hud-alt">0</span> <span class="unit">FT</span>
            </div>
            <div class="instrument">
                <span class="label">Heading</span>
                <span class="value" id="hud-hdg">000</span> <span class="unit">DEG</span>
            </div>
            <div class="instrument" style="border-left-color: #ffcc00;">
                <span class="label" style="color:#ffcc00">Thrust</span>
                <span class="value" id="hud-rpm">0</span> <span class="unit">%</span>
            </div>
        </div>

        <div id="throttle-wrapper">
            <div id="throttle-fill"></div>
        </div>
        <div id="throttle-label">THRUST</div>
        
        <div id="center-warning">STALL WARNING</div>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // --- å¸¸é‡é…ç½® (çœŸå®ç‰©ç†å‚æ•°) ---
        const CONFIG = {
            runwayZ: 4000,       // è·‘é“èµ·ç‚¹Zåæ ‡
            runwayX: -1500,      // è·‘é“ä¸­å¿ƒXåæ ‡
            
            // ç‰©ç†å‚æ•° - æ¨¡æ‹Ÿä¸€æ¶é‡å‹å–·æ°”å¼æˆ˜æ–—æœºæˆ–è½»å‹å•†åŠ¡æœº
            mass: 18000,         // 18å¨ (çœŸå®é‡é‡æ„Ÿ)
            maxThrust: 420000,   // 420kN (å¼ºå¤§çš„æ¨åŠ›ä»¥åŒ¹é…é‡é‡)
            dragCoeff: 0.035,    // é˜»åŠ›ç³»æ•°
            liftCoeff: 0.6,    // å‡åŠ›ç³»æ•° (ç¨å¾®è°ƒé«˜ä»¥ä¾¿æ›´å¥½èµ·é£)
            wingArea: 75,        // æœºç¿¼é¢ç§¯
            gravity: 9.81,       // æ ‡å‡†é‡åŠ›
            
            // æ“æ§å“åº” (ç”±äºè´¨é‡å¤§ï¼Œå“åº”ä¼šå˜æ…¢ï¼Œæ¨¡æ‹Ÿæƒ¯æ€§)
            rotDamping: 2.5,     // æ—‹è½¬é˜»å°¼
            pitchSpeed: 1.2,
            rollSpeed: 2.0,
            yawSpeed: 0.8
        };

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, clock;
        // ä¿®æ­£ 1ï¼šç§»é™¤ createDetailedPlane å‡½æ•°å†…éƒ¨çš„é‡å¤å£°æ˜
        let planeGroup; 
        let propL, propR; // propL/propR ä¼¼ä¹åœ¨ GLB æ¨¡å‹ä¸­ä¸éœ€è¦ï¼Œä½†ä¿ç•™å£°æ˜
        let shadowPlane; 
        
        let input = { w:0, s:0, a:0, d:0, q:0, e:0, shift:0, space:0 };
        let cameraMode = 0; // 0: Chase (å°¾éš), 1: Cockpit (åº§èˆ±), 2: Orbital (å…¨æ™¯/å¡”å°)

        // **æ–°å¢**ï¼šé¼ æ ‡æ§åˆ¶å˜é‡
        let isDragging = false;
        let mouseX = 0, mouseY = 0;
        let orbitAlpha = 0; // æ°´å¹³æ—‹è½¬è§’åº¦
        let orbitBeta = 0.4; // å‚ç›´æ—‹è½¬è§’åº¦
        const orbitDistance = 150; // ç¯ç»•åŠå¾„

        // ç‰©ç†çŠ¶æ€å¯¹è±¡
        const physics = {
            pos: new THREE.Vector3(CONFIG.runwayX, 2.8, CONFIG.runwayZ), // ä¿®æ­£ï¼šé«˜åº¦2.8åŒ¹é…è½®å­
            vel: new THREE.Vector3(0, 0, 0),
            acc: new THREE.Vector3(0, 0, 0),
            quat: new THREE.Quaternion(),
            rotVel: new THREE.Vector3(0, 0, 0), // è§’é€Ÿåº¦
            throttle: 0,
            brake: false,
            grounded: true,
            crashed: false
        };

        function startGame() {
            document.getElementById('splash').style.display = 'none';
            init();
            animate();
        }
        
        // ä¿®æ­£ 2ï¼šå°† startGame æ˜¾å¼æŒ‚è½½åˆ° windowï¼Œç¡®ä¿ HTML onclick èƒ½æ‰¾åˆ°å®ƒ
        window.startGame = startGame; 

        function init() {
            clock = new THREE.Clock();

            // æ¸²æŸ“å™¨è®¾ç½® - è¿½æ±‚å†™å®
            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // çœŸå®çš„å¤©ç©ºè“
            scene.fog = new THREE.Fog(0x87CEEB, 2000, 15000); // å¤§æ°”é€è§†

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.5, 100000);

            // ç¯å¢ƒå…‰ (å†·è‰²è°ƒé˜´å½±)
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x3b4c5a, 0.6); 
            scene.add(hemiLight);

            // å¤ªé˜³å…‰ (æš–è‰²è°ƒç›´å°„)
            const dirLight = new THREE.DirectionalLight(0xfff0dd, 1.4);
            dirLight.position.set(3000, 5000, 2000);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 4096; // é«˜æ¸…é˜´å½±
            dirLight.shadow.mapSize.height = 4096;
            const d = 5000;
            dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
            dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
            dirLight.shadow.camera.far = 15000;
            dirLight.shadow.bias = -0.0001;
            scene.add(dirLight);

            // æ„å»ºä¸–ç•Œ
            createRealisticWorld();
            createDetailedPlane();

            // ç›‘å¬
            window.addEventListener('resize', onResize);
            document.addEventListener('keydown', (e) => handleKey(e, 1));
            document.addEventListener('keyup', (e) => handleKey(e, 0));
            
            // **æ–°å¢**ï¼šé¼ æ ‡ç›‘å¬å™¨
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('wheel', onMouseWheel);
        }

        // --- ç‰©ç†å¼•æ“æ ¸å¿ƒ (Newtonian Physics) ---
        
        // --- ç‰©ç†å¼•æ“æ ¸å¿ƒ (æœ€ç»ˆä¿®æ­£ç‰ˆ - ä¼˜åŒ–èµ·é£å¹³ç¨³æ€§) ---
function updatePhysics(dt) {
    // 1. è¾“å…¥å¤„ç†
    if (input.shift) physics.throttle = Math.min(1.0, physics.throttle + dt * 0.4);
    if (input.space) physics.throttle = Math.max(0.0, physics.throttle - dt * 1.5);
    
    // 2. åŸºç¡€çŸ¢é‡è·å–
    const pos = physics.pos;
    const vel = physics.vel;
    const rot = physics.quat;
    
    let speed = vel.length();

    // æœºèº«åæ ‡ç³»æ–¹å‘
    const vForward = new THREE.Vector3(0, 0, -1).applyQuaternion(rot).normalize();
    const vUp = new THREE.Vector3(0, 1, 0).applyQuaternion(rot).normalize();
    const vRight = new THREE.Vector3(1, 0, 0).applyQuaternion(rot).normalize(); // ç”¨äºè¿è§’ä¿®æ­£
    
    // 3. é€Ÿåº¦å’Œè¿è§’è®¡ç®—
    const groundHeight = 2.8;
    physics.grounded = (pos.y <= groundHeight + 0.1); 

    // è®¡ç®—å‰å‘ç©ºé€Ÿ (æŠ•å½±åˆ°æœºå¤´æ–¹å‘çš„é€Ÿåº¦)
    const forwardSpeed = vel.dot(vForward); 
    
    // ******** ä¿®æ­£ 1ï¼šè®¡ç®—è¿è§’ï¼ˆAngle of Attack, AoAï¼‰ ********
    // é€Ÿåº¦çŸ¢é‡æ–¹å‘
    const velDir = vel.clone().normalize();
    // è®¡ç®—æœºå¤´æ–¹å‘ä¸é€Ÿåº¦æ–¹å‘çš„å¤¹è§’ (å¼§åº¦)
    let aoa = Math.acos(vForward.dot(velDir));
    
    // ä½¿ç”¨å‚ç›´æ–¹å‘æŠ•å½±åˆ¤æ–­è¿è§’çš„æ­£è´Ÿ (é€Ÿåº¦çŸ¢é‡åœ¨æœºå¤´ä¸Šæ–¹ä¸ºè´Ÿè¿è§’)
    if (velDir.dot(vUp) > 0) { 
        aoa = -aoa;
    }
    
    // è¿è§’é™åˆ¶åœ¨åˆç†èŒƒå›´ï¼Œå¦‚ -15åº¦ åˆ° 15åº¦ (çº¦ 0.26 å¼§åº¦)
    aoa = THREE.MathUtils.clamp(aoa, -0.26, 0.26); 
    
    // å‡åŠ›ç³»æ•°å› å­ï¼šåŸºäºè¿è§’ï¼Œæ¨¡æ‹Ÿå‡åŠ›æ›²çº¿ã€‚
    // å¢åŠ å¯¹è¿è§’çš„æ•æ„Ÿåº¦ï¼Œç¡®ä¿å°ä»°è§’ä¹Ÿèƒ½äº§ç”Ÿè¶³å¤Ÿå‡åŠ›
    let liftFactor = aoa * 3.0; 
    // ç¡®ä¿è¿è§’ä¸ºæ­£æˆ–é›¶æ—¶ï¼ŒliftFactorè‡³å°‘ä¸º 0.1 (ä¿è¯åŸºç¡€å‡åŠ›ï¼Œé˜²æ­¢æ•°å€¼æ³¢åŠ¨)
    liftFactor = Math.max(liftFactor, 0.1); 

    // VR é€Ÿåº¦é˜ˆå€¼ï¼š140 KTS (çº¦ 72 m/s)
    const V_R_SPEED = 72; 

    // --- æ ¸å¿ƒä¿®å¤ï¼šæ¶ˆé™¤æ¼‚ç§» (æ°”åŠ¨ç¨³å®šæ€§) ---
    if (!physics.grounded && speed > 1.0) {
        // é€Ÿåº¦çŸ¢é‡æœå‘æœºå¤´æ–¹å‘æ’å€¼ï¼Œæ¶ˆé™¤ä¾§æ»‘å’Œå‚ç›´æ¼‚ç§»
        const targetVel = vForward.clone().multiplyScalar(speed);
        const stability = Math.min(speed / 300, 1.0) * 0.15;
        vel.lerp(targetVel, stability);
    }

    function getCl(aoa) {
    const aoa_rad = aoa; // ä½ å·²ç»ç”¨å¼§åº¦ï¼Œå› æ­¤ä¸æ”¹
    const cl_max = 1.3;       // å…¸å‹æœºç¿¼æœ€å¤§å‡åŠ›ç³»æ•°
    const stall_aoa = 0.22;   // ~12.5Â°ï¼Œå…¸å‹å¤±é€Ÿè§’
    const slope = 2 * Math.PI; // ç†è®ºå‡åŠ›æ–œç‡ï¼ˆ2Ï€ â‰ˆ 6.28ï¼‰

    // 1) çº¿æ€§åŒº
    if (Math.abs(aoa_rad) <= stall_aoa) {
        return slope * aoa_rad;
    }

    // 2) å¤±é€ŸåŒºï¼ˆå¹³æ»‘è¡°å‡ï¼Œè€Œä¸æ˜¯çªç„¶æ‰ï¼‰
    const sign = Math.sign(aoa_rad);
    const excess = Math.abs(aoa_rad) - stall_aoa;

    return sign * cl_max * Math.exp(-excess * 15);
}

    // --- åŠ›å­¦ç´¯åŠ  ---
    const force = new THREE.Vector3(0, 0, 0);
    const airDensity = 1.225;

    // A. é‡åŠ›
    force.add(new THREE.Vector3(0, -CONFIG.gravity * CONFIG.mass, 0));

    // B. æ¨åŠ›
    const thrust = vForward.clone().multiplyScalar(physics.throttle * CONFIG.maxThrust);
    force.add(thrust);

    // C. å‡åŠ› (Lift) - å‚ç›´äºæœºç¿¼
    const speedSq = forwardSpeed * forwardSpeed;
    let liftForce = 0;
    if (forwardSpeed > 0) {
        // L = 0.5 * rho * v^2 * Cl * A * liftFactor
        liftForce = 0.5 * airDensity * speedSq * CONFIG.liftCoeff * CONFIG.wingArea * liftFactor;
    }
    
    // å‡åŠ›çŸ¢é‡ (åº”ç”¨åˆ° Local Up æ–¹å‘)
    const liftVec = vUp.clone().multiplyScalar(liftForce);
    force.add(liftVec);


    // D. é˜»åŠ› (Drag)
    const dragMag = 0.5 * airDensity * (speed * speed) * CONFIG.dragCoeff * CONFIG.wingArea;
    if (speed > 0) {
        const dragDir = vel.clone().normalize().negate();
        const brakeDrag = input.space ? 5.0 : 1.0; 
        force.add(dragDir.multiplyScalar(dragMag * brakeDrag));
    }

    // ******** ä¿®æ­£ 2ï¼šåœ°é¢æ¥è§¦åä½œç”¨åŠ›ï¼ˆæ¶ˆé™¤â€œç²˜åœ°â€å’Œâ€œå¼¹å°„â€ï¼‰ ********
    const groundDelta = pos.y - groundHeight;
    if (groundDelta <= 0.1) { // æ£€æŸ¥æ˜¯å¦æ¥è¿‘åœ°é¢æˆ–åœ¨åœ°é¢ä»¥ä¸‹
        // å¼¹ç°§åŠ›ï¼šåœ¨æ¥è¿‘åœ°é¢æ—¶ï¼Œæ¨¡æ‹Ÿèµ·è½æ¶çš„å¼¹ç°§åä½œç”¨åŠ›
        const springForce = CONFIG.mass * CONFIG.gravity * 3.0 * (0.1 - groundDelta); 
        
        // é˜»å°¼åŠ›ï¼šæŠµæ¶ˆåœ°é¢å†²å‡»å’Œå‚ç›´éœ‡è¡
        const dampForce = -vel.y * CONFIG.mass * 0.5; 
        
        // æ€»åä½œç”¨åŠ›
        const reactionForce = new THREE.Vector3(0, springForce + dampForce, 0);
        force.add(reactionForce);

        // åœ°é¢æ‘©æ“¦
        const friction = vel.clone().multiplyScalar(-2000);
        friction.y = 0; // åªå½±å“æ°´å¹³é€Ÿåº¦
        force.add(friction);
        
        // ç¡®ä¿ä¸ç©¿é€åœ°é¢
        if (pos.y < groundHeight) {
            pos.y = groundHeight;
        }
    }


    // --- ç§¯åˆ†è®¡ç®— (F=ma) ---
    physics.acc.copy(force.divideScalar(CONFIG.mass));
    physics.vel.add(physics.acc.clone().multiplyScalar(dt));
    physics.pos.add(physics.vel.clone().multiplyScalar(dt));
    
    // --- æ—‹è½¬æ§åˆ¶ï¼ˆä¿æŒä¸å˜ï¼‰ ---
    // æ°”åŠ¨æ§åˆ¶æ•ˆç‡éšç€é€Ÿåº¦å¢åŠ è€Œæé«˜
    const aeroFactor = Math.min(Math.max((forwardSpeed / 100), 0.5), 1.0); 

    let targetRoll = (input.a - input.d) * CONFIG.rollSpeed * aeroFactor;
    let targetYaw = (input.q - input.e) * CONFIG.yawSpeed * aeroFactor;

    // æ¥åœ°æ—¶ï¼Œé™åˆ¶æ»šè½¬ï¼Œå¢åŠ è½¬å‘æ•ˆç‡
    if (physics.grounded && forwardSpeed < V_R_SPEED) {
        targetRoll = 0; 
        targetYaw = (input.q - input.e) * 0.5;
    } else if (physics.grounded) {
         // é«˜é€Ÿæ»‘è¡Œæ—¶ï¼Œæ–¹å‘èˆµå’Œå‰¯ç¿¼éƒ½å¯ä»¥ç”¨æ¥åœ°é¢è½¬å‘
         targetYaw = (input.q - input.e + (input.a - input.d) * 0.5); 
    }
    

    const targetRot = new THREE.Vector3(
        (input.s - input.w) * CONFIG.pitchSpeed * aeroFactor, 
        targetYaw,   
        targetRoll   
    );

    physics.rotVel.lerp(targetRot, dt * CONFIG.rotDamping);

    const deltaRot = new THREE.Quaternion().setFromEuler(new THREE.Euler(
        physics.rotVel.x * dt,
        physics.rotVel.y * dt,
        physics.rotVel.z * dt,
        'XYZ'
    ));
    physics.quat.multiply(deltaRot).normalize();


    // --- UI é€»è¾‘ & å æ¯åˆ¤å®šï¼ˆä¿æŒä¸å˜ï¼‰ ---
    const centerWarn = document.getElementById('center-warning');
    const speedKnots = Math.floor(speed * 1.94); 

    const inRunwayArea = (pos.x > CONFIG.runwayX - 1000 && pos.x < CONFIG.runwayX + 1000 && pos.y < groundHeight + 1.0);
    
    if (physics.crashed) {
        // å¦‚æœå·²ç»å æ¯ï¼Œä¿æŒè­¦å‘ŠçŠ¶æ€
    }
    else if (physics.grounded && speedKnots > 20 && !inRunwayArea) {
        centerWarn.style.display = 'block';
        centerWarn.innerText = "CRASH: OFF-RUNWAY LANDING";
        
        physics.vel.set(0, 0, 0);
        physics.throttle = 0;
        physics.crashed = true;
    } 
    else if (!physics.grounded && speedKnots < 135 && speedKnots > 20) {
        centerWarn.style.display = 'block';
        centerWarn.innerText = `STALL WARNING (V=${speedKnots} KTS)`;
        
    } else {
        centerWarn.style.display = 'none';
    }
}

        // --- è§†è§‰æ„å»ºï¼šå†™å®é£æ ¼ (çœç•¥ä¸å˜éƒ¨åˆ†) ---
        // --- è§†è§‰æ„å»ºï¼šå†™å®é£æ ¼ (çœç•¥ä¸å˜éƒ¨åˆ†) ---
        function createRealisticWorld() {
            const simplex = new SimplexNoise();
            const size = 60000;
            const segs = 128; 
            const geo = new THREE.PlaneGeometry(size, size, segs, segs);
            const pos = geo.attributes.position;
            const colors = [];

            const cConcrete = new THREE.Color(0x606060); 
            const cGrass = new THREE.Color(0x3a5f0b);    
            const cDirt = new THREE.Color(0x5a4d3b);     
            
            const flatRadius = 5000;

            for(let i=0; i<pos.count; i++){
                let x = pos.getX(i);
                let y = pos.getY(i); 
                
                let h = 0;
                let col = cGrass; 

                const dist = Math.sqrt(x*x + y*y);
                const inAirport = (Math.abs(x - CONFIG.runwayX) < 1000 && Math.abs(y) < 4500);
                
                if (inAirport) {
                    // å¦‚æœåœ¨æœºåœºåŒºåŸŸï¼Œä»ç„¶ä¿æŒåœ°å½¢å¹³å¦ï¼Œé¿å…æ¨¡å‹å’Œåœ°å½¢ç©¿æ’
                    h = 0;
                    col = new THREE.Color(0x4a6f1b); 
                } else if (dist < flatRadius) {
                    h = 0;
                    if ((Math.sin(x*0.01) * Math.cos(y*0.01)) > 0) col = new THREE.Color(0x355515);
                } else {
                    let n = simplex.noise2D(x*0.0001, y*0.0001);
                    h = Math.max(0, n * 2500);
                    if (dist < flatRadius + 2000) {
                        h *= (dist - flatRadius) / 2000;
                    }
                    if (h > 500) col = cDirt;
                    else col = cGrass;
                }

                pos.setZ(i, h);
                colors.push(col.r, col.g, col.b);
            }
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geo.computeVertexNormals();
            
            const terrain = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ 
                vertexColors: true, 
                roughness: 0.9, 
                metalness: 0.05 
            }));
            terrain.rotation.x = -Math.PI/2;
            terrain.receiveShadow = true;
            scene.add(terrain);

            // ğŸš€ 2. åŠ è½½æœºåœºè·‘é“ (Runway) GLB æ¨¡å‹
            const runwayLoader = new THREE.GLTFLoader();
            runwayLoader.load(
                'runway.glb', // æ‚¨çš„è·‘é“æ¨¡å‹è·¯å¾„
                function (gltf) {
                    const loadedRunway = gltf.scene;

                    // æ ¹æ®æ‚¨çš„ runway.glb æ¨¡å‹éœ€è¦è¿›è¡Œè°ƒæ•´ï¼š
                    // é€šå¸¸ GLB æ¨¡å‹æ˜¯ Y è½´å‘ä¸Šï¼ŒZ è½´å‘å‰ã€‚
                    // ç¡®ä¿å®ƒä¸æ‚¨çš„ä¸–ç•Œåæ ‡ç³»å¯¹é½ (ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨çš„ GLB è·‘é“æ˜¯æ°´å¹³çš„ï¼Œ
                    // å¹¶ä¸”æ‚¨å¸Œæœ›å®ƒä½äº CONFIG.runwayX çš„ä½ç½®ï¼Œå¯èƒ½éœ€è¦è°ƒæ•´)

                    // ç¤ºä¾‹ï¼šç¼©æ”¾ã€æ—‹è½¬å’Œä½ç½®
                    loadedRunway.scale.set(9, 9, 9); // æ ¹æ®æ¨¡å‹å®é™…å¤§å°è°ƒæ•´
                    loadedRunway.position.set(-700, 0, 3300); // æ”¾ç½®åœ¨è·‘é“ä¸­å¿ƒ X åæ ‡ï¼Œåœ°é¢ Y
                    loadedRunway.rotation.y = Math.PI / 2; 

                    loadedRunway.traverse(c => {
                        if (c.isMesh) {
                            c.castShadow = true;
                            c.receiveShadow = true;
                            // å¦‚æœæ¨¡å‹æè´¨çœ‹èµ·æ¥å¤ªäº®æˆ–å¤ªæš—ï¼Œå¯ä»¥è°ƒæ•´
                            // c.material.roughness = 0.8; 
                            // c.material.metalness = 0.1;
                        }
                    });
                    scene.add(loadedRunway);
                    console.log('Runway model runway.glb loaded successfully!');
                },
                function (xhr) {
                    console.log('Runway loading: ' + (xhr.loaded / xhr.total * 100).toFixed(2) + '% loaded');
                },
                function (error) {
                    console.error('An error occurred while loading the runway model:', error);
                }
            );

            // 3. åŸå¸‚ç”Ÿæˆ
            createRealisticCity();
        }

        function createRealisticCity() {
            const count = 6000;
            const boxGeo = new THREE.BoxGeometry(1,1,1);
            boxGeo.translate(0, 0.5, 0); 
            
            const matConcrete = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.8 });
            const matGlass = new THREE.MeshStandardMaterial({ color: 0x5588aa, roughness: 0.2, metalness: 0.8 });

            const meshConcrete = new THREE.InstancedMesh(boxGeo, matConcrete, count/2);
            const meshGlass = new THREE.InstancedMesh(boxGeo, matGlass, count/2);
            
            meshConcrete.castShadow = true; meshConcrete.receiveShadow = true;
            meshGlass.castShadow = true; meshGlass.receiveShadow = true;

            const dummy = new THREE.Object3D();
            let idxC = 0, idxG = 0;

            const blockSize = 250; 
            
            for (let x = 0; x < 30; x++) {
                for (let z = -20; z < 20; z++) {
                    const px = 1000 + x * blockSize; 
                    const pz = z * blockSize;
                    const distCenter = Math.sqrt(Math.pow(px - 3000, 2) + Math.pow(pz - 0, 2));
                    const isDowntown = distCenter < 2000;

                    const buildingsInBlock = 2 + Math.floor(Math.random()*3);
                    
                    for(let k=0; k<buildingsInBlock; k++) {
                        const offX = (Math.random()-0.5) * (blockSize - 20);
                        const offZ = (Math.random()-0.5) * (blockSize - 20);
                        
                        const finalX = px + offX;
                        const finalZ = pz + offZ;

                        let w = 30 + Math.random() * 30;
                        let h; 
                        
                        if (isDowntown) {
                            h = 100 + Math.random() * 300;
                            w += 10;
                        } else {
                            h = 15 + Math.random() * 40;
                        }

                        dummy.position.set(finalX, 0, finalZ);
                        dummy.scale.set(w, h, w);
                        dummy.updateMatrix();

                        if (isDowntown && Math.random() > 0.3) {
                            if(idxG < count/2) meshGlass.setMatrixAt(idxG++, dummy.matrix);
                        } else {
                            if(idxC < count/2) meshConcrete.setMatrixAt(idxC++, dummy.matrix);
                        }
                    }
                }
            }

            scene.add(meshConcrete);
            scene.add(meshGlass);

            const roads = new THREE.Group();
            const roadMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
            for(let x = 0; x < 30; x++) {
                const r = new THREE.Mesh(new THREE.PlaneGeometry(15, 10000), roadMat);
                r.rotation.x = -Math.PI/2;
                r.position.set(1000 + x * blockSize, 0.05, 0);
                roads.add(r);
            }
            scene.add(roads);
        }

        // --- é£æœºç»†èŠ‚æ¨¡å‹ ---

function createDetailedPlane() {
    // 1. åˆå§‹åŒ– GLTFLoader
    const loader = new THREE.GLTFLoader();
    // 2. åŠ è½½ .glb æ¨¡å‹
    loader.load(
        // èµ„æºè·¯å¾„
        'plane1.glb',
        // åŠ è½½æˆåŠŸå›è°ƒ
        function (gltf) {
            planeGroup = gltf.scene; // èµ‹å€¼ç»™å…¨å±€å˜é‡ planeGroup
            
            // æ¨¡å‹çš„é»˜è®¤ç¼©æ”¾å’Œæ—‹è½¬å¯èƒ½éœ€è¦è°ƒæ•´ï¼Œä»¥åŒ¹é…åŸå…ˆçš„å‡ ä½•ä½“å¤§å°å’Œæ–¹å‘ã€‚
            // å‡è®¾æ¨¡å‹éœ€è¦ç¼©å°å¹¶æ—‹è½¬ä½¿å…¶æœºå¤´æœå‘ -Z
            planeGroup.scale.set(0.2, 0.2, 0.2); // ç¤ºä¾‹ç¼©æ”¾ï¼šæ ¹æ®æ‚¨çš„æ¨¡å‹è°ƒæ•´
            // ç¡®ä¿æ¨¡å‹åŠå…¶å­å¯¹è±¡èƒ½å¤ŸæŠ•å°„å’Œæ¥æ”¶é˜´å½±
            planeGroup.castShadow = true;
            planeGroup.traverse(c => { 
                if (c.isMesh) { 
                    c.castShadow = true; 
                    c.receiveShadow = true; 
                }
            });

            scene.add(planeGroup);
            console.log('Plane model plane1.glb loaded successfully!');

            // 3. å½±å­ (ä¿ç•™å¹³é¢å½±å­)
            shadowPlane = new THREE.Mesh(

            );
            //shadowPlane.rotation.x = -Math.PI / 2;
            
            // ä¿®æ­£ 3ï¼šå½±å­åˆå§‹ä½ç½®è®¾ç½®ä¸ºè´´è¿‘åœ°é¢ (0.05)
            shadowPlane.position.y = 0.05; 
            scene.add(shadowPlane);
        },
        // åŠ è½½è¿‡ç¨‹ä¸­å›è°ƒ
        function (xhr) {
            console.log('Plane loading: ' + (xhr.loaded / xhr.total * 100).toFixed(2) + '% loaded');
        },
        // åŠ è½½å¤±è´¥å›è°ƒ
        function (error) {
            console.error('An error occurred while loading the plane model:', error);
        }
    );
}
        // **ä¿®æ”¹**ï¼šV é”®åˆ‡æ¢ç›¸æœºæ¨¡å¼ (æ–°å¢ Orbit æ¨¡å¼)
        function changeCamera() {
            cameraMode = (cameraMode + 1) % 3; // 0, 1, 2 å¾ªç¯
        }

        function handleKey(e, val) {
            let k = e.key.toLowerCase();
            if (k === " ") k = "space";
            if (k === "v" && val === 1) changeCamera();
            if (input.hasOwnProperty(k)) input[k] = val;
        }
        
        // **æ–°å¢**ï¼šé¼ æ ‡äº‹ä»¶å¤„ç†å‡½æ•°
        function onMouseDown(event) {
            if (cameraMode === 2) {
                isDragging = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        }

        function onMouseMove(event) {
            if (isDragging && cameraMode === 2) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                orbitAlpha -= deltaX * 0.005; // æ°´å¹³æ—‹è½¬
                orbitBeta += deltaY * 0.005;  // å‚ç›´æ—‹è½¬

                // é™åˆ¶å‚ç›´æ—‹è½¬èŒƒå›´ï¼Œé˜²æ­¢è§†è§’ç¿»è½¬
                orbitBeta = THREE.MathUtils.clamp(orbitBeta, 0.1, Math.PI - 0.1); 

                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        }

        function onMouseUp() {
            isDragging = false;
        }
        
        function onMouseWheel(event) {
            if (cameraMode === 2) {
                // æ»šè½®ç¼©æ”¾/æ”¾å¤§åˆ‡æ¢
                const zoomFactor = event.deltaY * 0.01; // è°ƒæ•´æ»šè½®æ•æ„Ÿåº¦
                // ç¡®ä¿ orbitDistance è¢«å£°æ˜ä¸º let è€Œä¸æ˜¯ const (å®ƒç›®å‰æ˜¯ const)
                // orbitDistance = THREE.MathUtils.clamp(orbitDistance + zoomFactor, 20, 1000); 
            }
        }


        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);

            updatePhysics(dt);

            if (planeGroup) {
                // ç‰©ç†åŒæ­¥
                planeGroup.position.copy(physics.pos);
                planeGroup.quaternion.copy(physics.quat);
                const correctionQuat = new THREE.Quaternion().setFromAxisAngle(
            new THREE.Vector3(0, 1, 0), 
            Math.PI
            )
            planeGroup.quaternion.copy(physics.quat).multiply(correctionQuat);

                // å½±å­è·Ÿéš
                shadowPlane.position.set(physics.pos.x, 0.05, physics.pos.z);
                
                // å½±å­åªè·Ÿéšé£æœºçš„èˆªå‘ rotation.yï¼Œå› ä¸ºå®ƒæ˜¯åœ°å¹³é¢çš„
                const euler = new THREE.Euler().setFromQuaternion(physics.quat, 'YXZ');
                shadowPlane.rotation.z = euler.y; 

                // ç›¸æœºé€»è¾‘
                const groundHeight = 2.8;
                
                if (cameraMode === 0) { // å°¾éšè§†è§’
                    // ç†æƒ³çš„ç›¸æœºç›®æ ‡ä½ç½®ï¼ˆä¸–ç•Œåæ ‡ï¼‰
                    // ç†æƒ³ä½ç½®ï¼šåæ–¹80ï¼Œä¸Šæ–¹15
                    const relativeOffset = new THREE.Vector3(0, 15, -80); 
    const idealCameraPosition = relativeOffset.clone().applyMatrix4(planeGroup.matrixWorld);
                    
                    // --- ç›¸æœºé¿éšœä¼˜åŒ–ï¼šé˜²æ­¢é™·åœ° ---
                    const safeBuffer = 1.5;   // ç›¸æœºç¦»åœ°æœ€å°å®‰å…¨è·ç¦» (ä¾‹å¦‚ï¼š1.5 ç±³)
                    const minCameraY = groundHeight + safeBuffer;
                    
                    // é’³åˆ¶ Y è½´ï¼šå¦‚æœç†æƒ³ä½ç½®ä½äºæœ€å°å®‰å…¨é«˜åº¦ï¼Œåˆ™å¼ºåˆ¶æŠ¬é«˜
                    if (idealCameraPosition.y < minCameraY) {
                        idealCameraPosition.y = minCameraY;
                    }
                    // -----------------------------

                    camera.position.lerp(idealCameraPosition, 0.1); // å¹³æ»‘è·Ÿéš
                    
                    // é¢„æµ‹æ€§ LookAt: çœ‹å‘é£æœºå‰æ–¹ä¸€ç‚¹ï¼Œå¢åŠ åŠ¨æ€æ„Ÿ
                    const forward = new THREE.Vector3(0,0,-1).applyQuaternion(physics.quat);
                    const lookAtPos = planeGroup.position.clone().add(forward.multiplyScalar(50));
                    camera.lookAt(lookAtPos);
                } else if (cameraMode === 0) { // å°¾éšè§†è§’
    // ç†æƒ³çš„ç›¸æœºç›®æ ‡ä½ç½®ï¼ˆä¸–ç•Œåæ ‡ï¼‰
    // ç†æƒ³ä½ç½®ï¼šåæ–¹80ï¼Œä¸Šæ–¹15
    
    // **ğŸš€ å…³é”®ä¿®æ”¹ï¼šå°† Z è½´åç§»æ”¹ä¸ºè´Ÿå€¼ï¼Œä»¥åŒ¹é…æ¨¡å‹ 180 åº¦æ—‹è½¬åçš„æ–°å°¾éƒ¨**
    const relativeOffset = new THREE.Vector3(0, 15, -80); 
    
    const idealCameraPosition = relativeOffset.clone().applyMatrix4(planeGroup.matrixWorld);
    
                } else if (cameraMode === 1) { // åº§èˆ±è§†è§’
                    // æš‚æ—¶ä¸åšåº§èˆ±å»ºæ¨¡ï¼Œä½¿ç”¨ä¸€ä¸ªé è¿‘æœºèº«çš„ä½ç½®
                    const relativeOffset = new THREE.Vector3(0, 2, -15);
                    const cockpitPos = relativeOffset.clone().applyMatrix4(planeGroup.matrixWorld);
                    
                    camera.position.copy(cockpitPos);
                    camera.quaternion.copy(physics.quat);
                    
                } else if (cameraMode === 2) { // **æ–°å¢**ï¼šé¼ æ ‡æ‹–åŠ¨çš„å…¨æ™¯è§†è§’
                    const target = planeGroup.position.clone();
                    
                    // 1. è®¡ç®—ç›¸æœºåœ¨çƒåæ ‡ç³»ä¸­çš„ä½ç½® (x, y, z)
                    // x = r * sin(beta) * sin(alpha)
                    // y = r * cos(beta)
                    // z = r * sin(beta) * cos(alpha)
                    const sinAlpha = Math.sin(orbitAlpha);
                    const cosAlpha = Math.cos(orbitAlpha);
                    const sinBeta = Math.sin(orbitBeta);
                    const cosBeta = Math.cos(orbitBeta);
                    
                    const camX = target.x + orbitDistance * sinBeta * sinAlpha;
                    const camY = target.y + orbitDistance * cosBeta;
                    const camZ = target.z + orbitDistance * sinBeta * cosAlpha;
                    
                    camera.position.set(camX, camY, camZ);
                    camera.lookAt(target); // å§‹ç»ˆçœ‹å‘é£æœº
                }
            }
            
            // UI æ›´æ–°
            const speedKnots = Math.floor(physics.vel.length() * 1.94);
            document.getElementById('hud-spd').innerText = speedKnots;
            document.getElementById('hud-alt').innerText = Math.floor(physics.pos.y * 3.28);
            document.getElementById('hud-rpm').innerText = Math.floor(physics.throttle * 100);
            document.getElementById('throttle-fill').style.height = (physics.throttle * 100) + '%';
            
            // èˆªå‘
            const euler = new THREE.Euler().setFromQuaternion(physics.quat, 'YXZ');
            let hdg = Math.floor(THREE.MathUtils.radToDeg(-euler.y) % 360);
            if (hdg < 0) hdg += 360; // è½¬æ¢ä¸º 0-360 åº¦
            document.getElementById('hud-hdg').innerText = hdg.toString().padStart(3, '0');
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
