<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASL Car Simulator - Ultimate Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap');

        body { 
            margin: 0; 
            overflow: hidden; 
            background: #050505; 
            font-family: 'Rajdhani', sans-serif; 
            user-select: none; 
        }
        
        /* === UI æ•´ä½“å¸ƒå±€ === */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            padding: 30px; box-sizing: border-box; z-index: 10;
        }

        /* === é¡¶éƒ¨ä»ªè¡¨ === */
        .hud-top-left { display: flex; gap: 15px; flex-wrap: wrap; }
        
        .instrument {
            background: rgba(0, 10, 20, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.1);
            border-left: 3px solid #00eeff;
            backdrop-filter: blur(10px);
            padding: 8px 20px;
            color: #fff;
            min-width: 110px;
            box-shadow: 0 0 15px rgba(0, 238, 255, 0.05);
            border-radius: 2px;
            clip-path: polygon(10px 0, 100% 0, 100% 100%, 0 100%, 0 10px);
            transition: transform 0.1s;
        }

        .instrument:hover { transform: scale(1.05); border-left-color: #fff; }
        
        .label {
            font-family: 'Orbitron', sans-serif;
            font-size: 9px; color: #00eeff; font-weight: 700; letter-spacing: 1px;
            margin-bottom: 2px; display:block; text-transform: uppercase; text-shadow: 0 0 5px rgba(0,238,255,0.5);
        }
        
        .value {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px; font-weight: 700; letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
        }
        
        .unit {
            font-size: 12px; color: #aaa; margin-left: 5px; font-weight: 500;
        }

        /* === åº•éƒ¨æ§åˆ¶æç¤º === */
        #control-hints {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: 3px solid #00ff66;
            backdrop-filter: blur(10px);
            padding: 15px 25px;
            color: #eee;
            font-size: 14px;
            border-radius: 0 15px 0 0;
            line-height: 1.8;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }

        .hint-title {
            color: #00ff66;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
            font-size: 12px;
            border-bottom: 1px solid rgba(0,255,102,0.3);
            padding-bottom: 5px;
        }

        /* === å¯åŠ¨ç”»é¢ === */
        #splash {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #1a2a3a 0%, #000000 100%);
            z-index: 999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white;
        }
        
        #splash-three-container {
            width: 100%; height: 300px;
            margin-bottom: 0px;
            position: relative;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 56px;
            margin: 0;
            font-weight: 900;
            letter-spacing: 10px;
            text-transform: uppercase;
            background: linear-gradient(to right, #00c6ff, #0072ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 10px 30px rgba(0, 114, 255, 0.4);
        }

        button#start-button {
            margin-top: 40px;
            padding: 15px 50px;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            background: transparent;
            border: 2px solid #00c6ff;
            cursor: pointer;
            transition: 0.3s;
            letter-spacing: 2px;
            box-shadow: 0 0 15px rgba(0, 198, 255, 0.2);
        }

        button#start-button:hover {
            background: #00c6ff;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 198, 255, 0.8);
        }

        /* === ç‰ˆæƒæ ‡è¯† === */
        .copyright-tag {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-family: 'Rajdhani', sans-serif;
            color: rgba(255, 255, 255, 0.4);
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 1px;
            z-index: 1001;
            text-transform: uppercase;
            pointer-events: none;
        }
        
        .copyright-splash {
            margin-top: 20px;
            font-family: 'Rajdhani', sans-serif;
            color: rgba(255,255,255,0.3);
            font-size: 14px;
            letter-spacing: 2px;
        }

        /* === åŠ è½½æ¡ === */
        #loading-progress-bar {
            width: 400px; height: 4px; background: #222; margin-top: 20px;
            border-radius: 2px; overflow: hidden;
        }
        #loading-progress-fill {
            height: 100%; width: 0%; background: #00eeff;
            box-shadow: 0 0 10px #00eeff;
            transition: width 0.2s;
        }
    </style>
</head>
<body>

    <div id="splash">
        <div id="splash-three-container"></div>
        <h1>ASL SIMULATOR</h1>
        <p style="opacity:0.7; font-size: 18px; letter-spacing: 4px; margin-top: -10px;">ULTIMATE EDITION</p>
        <button id="start-button" onclick="startGame()">INITIALIZE ENGINE</button>
        <div class="copyright-splash">DESIGNED BY ZHANYI ZHOU</div>
    </div>

    <div id="hud-layer" style="display:none;">
        <div class="hud-top-left">
            <div class="instrument">
                <span class="label">Speed</span>
                <span class="value" id="hud-spd">0</span> <span class="unit">KM/H</span>
            </div>
            <div class="instrument" style="border-left-color: #ff0055;">
                <span class="label" style="color:#ff0055">RPM</span>
                <span class="value" id="hud-rpm">0</span> <span class="unit">x100</span>
            </div>
            <div class="instrument" style="border-left-color: #ffcc00;">
                <span class="label" style="color:#ffcc00">Gear</span>
                <span class="value" id="hud-gear">P</span> <span class="unit">AUTO</span>
            </div>
            <div class="instrument" style="border-left-color: #00ff66;">
                <span class="label" style="color:#00ff66">Throttle</span>
                <span class="value" id="hud-throttle">0%</span>
            </div>
        </div>

        <div class="hud-bottom">
            <div id="control-hints">
                <div class="hint-title">ğŸ’¡ SYSTEM CONTROLS</div>
                <div>[SHIFT] NITRO BOOST</div>
                <div>[SPACE] HANDBRAKE</div>
                <div>[V] TOGGLE CAMERA</div>
                <div>[WASD] DRIVE</div>
            </div>
        </div>
    </div>

    <div class="copyright-tag">ZHANYI ZHOU DESIGN Â© 2025</div>

    <div id="loading-screen" style="display:none; flex-direction:column; align-items:center; justify-content:center; position:absolute;top:0;left:0;width:100%;height:100%;background:#000; color:#fff; z-index:1000;">
        <h2 style="font-family:'Orbitron'; color:#00eeff;">LOADING ASSETS</h2>
        <div id="loading-progress-bar">
            <div id="loading-progress-fill"></div>
        </div>
        <p id="loading-status" style="margin-top:15px; font-family:'Consolas'; color:#888;">Initializing...</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

    <script>
    // =============================================================================
    // ** æ ¸å¿ƒå˜é‡ **
    // =============================================================================
    let scene, renderer;
    let cameraChase, cameraCockpit, activeCamera;
    let world, vehicle, chassisBody;
    let wheelMeshes = [];
    let lastTime = undefined;

    let hemiLight, dirLight;
    const daySkyColor = new THREE.Color(0x87CEEB);
    const nightSkyColor = new THREE.Color(0x050510);
    
    let staticBodies = [];
    let carMesh = null;
    let tireMeshPrototype = null;
    let flameMesh = null;
    let gltfLoader = null;
    let dracoLoader = null;

    const inputState = { keyW: false, keyS: false, keyA: false, keyD: false, keySpace: false, keyShift: false };

    // == ç‰©ç†è°ƒæ•´å‚æ•° (Zhanyi Zhou ä¼˜åŒ–ç‰ˆ) ==
    const maxEngineForce = 3000; // é™ä½æ‰­çŸ©ä»¥é˜²æ­¢èµ·æ­¥æŠ¬å¤´
    const maxBrakeForce = 150;
    const maxSteerVal = 0.6;
    let engineForce = 0;
    let steeringValue = 0;

    // ä»ªè¡¨ç›˜å…ƒç´ 
    const speedEl = document.getElementById('hud-spd');
    const rpmEl = document.getElementById('hud-rpm');
    const gearEl = document.getElementById('hud-gear');
    const throttleEl = document.getElementById('hud-throttle');

    // =============================================================================
    // ** åˆå§‹åŒ–åŠ è½½å™¨ **
    // =============================================================================
    function initLoaders() {
        dracoLoader = new THREE.DRACOLoader();
        dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/');

        const loadingManager = new THREE.LoadingManager();
        const progressFill = document.getElementById('loading-progress-fill');
        const loadingStatus = document.getElementById('loading-status');
        
        loadingManager.onProgress = function(itemUrl, itemsLoaded, itemsTotal) {
            const percent = Math.floor((itemsLoaded / itemsTotal) * 100);
            progressFill.style.width = percent + '%';
            loadingStatus.innerText = `LOADING OBJECTS (${percent}%)`;
        };
        
        loadingManager.onLoad = function() {
            cancelAnimationFrame(splashAnimationId);
            document.getElementById('loading-screen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('hud-layer').style.display = 'flex';
            }, 800);
            initVehicle();
            requestAnimationFrame(animate);
        };

        gltfLoader = new THREE.GLTFLoader(loadingManager);
        gltfLoader.setDRACOLoader(dracoLoader);
    }

    // =============================================================================
    // ** å¯åŠ¨ç”»é¢æ—‹è½¬è½¦æ¨¡å‹ **
    // =============================================================================
    let splashScene, splashCamera, splashRenderer, splashAnimationId, splashCarModel;
    function initSplashThree() {
        const container = document.getElementById('splash-three-container');
        const width = container.clientWidth;
        const height = container.clientHeight;

        splashScene = new THREE.Scene();
        splashCamera = new THREE.PerspectiveCamera(50, width/height, 0.1, 100);
        splashRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        splashRenderer.setSize(width, height);
        container.appendChild(splashRenderer.domElement);

        const light = new THREE.DirectionalLight(0x00eeff, 2);
        light.position.set(5, 5, 5);
        splashScene.add(light);
        splashScene.add(new THREE.AmbientLight(0xffffff, 0.5));

        splashCamera.position.set(0, 1.5, 4.5);
        splashCamera.lookAt(0, 0, 0);

        function animateSplash() {
            splashAnimationId = requestAnimationFrame(animateSplash);
            if (splashCarModel) {
                splashCarModel.rotation.y += 0.005;
            }
            splashRenderer.render(splashScene, splashCamera);
        }
        animateSplash();
    }

    function loadSplashCarModel() {
        if (!gltfLoader) gltfLoader = new THREE.GLTFLoader(); 
        gltfLoader.load('car1.glb', (gltf) => {
            splashCarModel = gltf.scene;
            splashCarModel.scale.set(1.5, 1.5, 1.5);
            splashScene.add(splashCarModel);
        });
    }

    // =============================================================================
    // ** æ¸¸æˆèµ„æºåŠ è½½ **
    // =============================================================================
    function loadCarModel() {
        gltfLoader.load('car1.glb', (gltf) => {
            carMesh = gltf.scene;
            carMesh.scale.set(1.7, 1.7, 1.7);
            carMesh.rotation.y = Math.PI;
            // ä¿®æ­£ï¼šè§†è§‰æ¨¡å‹ä½ç½®ç¨å¾®ä¸‹ç§»ï¼Œé…åˆç‰©ç†åˆšä½“
            carMesh.position.y = -0.8; 
            carMesh.traverse((node) => {
                if (node.isMesh) node.castShadow = true;
            });
            scene.add(carMesh);

            // ç«ç„°ç‰¹æ•ˆ
            const flameGeo = new THREE.ConeGeometry(0.2, 0.8, 8);
            const flameMat = new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.8 });
            flameMesh = new THREE.Mesh(flameGeo, flameMat);
            flameMesh.rotation.x = -Math.PI / 2;
            flameMesh.position.set(0, 0.5, 2.8);
            flameMesh.visible = false;
            carMesh.add(flameMesh);
        });
    }

    function loadTireModel() {
        gltfLoader.load('tire1.glb', (gltf) => {
            tireMeshPrototype = gltf.scene;
            tireMeshPrototype.scale.set(0.75, 0.75, 0.75);
            tireMeshPrototype.traverse((node) => { if(node.isMesh) node.castShadow = true; });
        });
    }

    function loadCity() {
        gltfLoader.load('city.glb', (gltf) => {
            const city = gltf.scene;
            city.scale.set(4,4,4);
            city.traverse(n => { if(n.isMesh){ n.castShadow = true; n.receiveShadow = true; } });
            scene.add(city);
            
            // ç®€å•çš„ç¢°æ’ä½“ç”Ÿæˆ
            city.updateMatrixWorld(true);
            city.traverse((node) => {
                if (node.isMesh) {
                    const geometry = node.geometry.clone();
                    geometry.applyMatrix4(node.matrixWorld);
                    geometry.computeBoundingSphere();
                    const radius = geometry.boundingSphere.radius;
                    // åªæœ‰å¤§çš„ç‰©ä½“æ‰åŠ ç¢°æ’ï¼Œä¼˜åŒ–æ€§èƒ½
                    if(radius > 1) {
                         const shape = new CANNON.Sphere(radius * 0.8); // ç¨å¾®ç¼©å°ä¸€ç‚¹ç¢°æ’çƒ
                         const body = new CANNON.Body({ mass: 0 });
                         body.addShape(shape);
                         body.position.copy(geometry.boundingSphere.center);
                         staticBodies.push({ body: body, center: body.position.clone(), radius: radius, added: false });
                    }
                }
            });
        });
    }

    // =============================================================================
    // ** THREE / CANNON åˆå§‹åŒ– **
    // =============================================================================
    function initThree() {
        scene = new THREE.Scene();
        scene.background = daySkyColor.clone();
        scene.fog = new THREE.Fog(daySkyColor, 10, 150);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
    }

    function initCannon() {
        world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.allowSleep = true;

        // ** å…³é”®ä¿®å¤ï¼šå¢åŠ å…¨å±€æ‘©æ“¦åŠ› **
        const defaultMaterial = new CANNON.Material('default');
        const contactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
            friction: 0.8, // é«˜æ‘©æ“¦
            restitution: 0.0 // æ— åå¼¹
        });
        world.defaultContactMaterial = contactMaterial;
        world.addContactMaterial(contactMaterial);
    }

    function initGround() {
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0 });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        const groundGeo = new THREE.PlaneGeometry(1000, 1000);
        const groundMat = new THREE.MeshStandardMaterial({ 
            color: 0x222222, roughness: 0.8, metalness: 0.2 
        });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);
    }

    function initCameraAndLights() {
        cameraChase = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        cameraCockpit = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        activeCamera = cameraChase;

        hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemiLight);

        dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        scene.add(dirLight);
    }

    // =============================================================================
    // ** è½¦è¾†ç‰©ç†æ ¸å¿ƒ (Zhanyi Zhou ä¿®å¤ç‰ˆ) **
    // =============================================================================
    function initVehicle() {
        // 1. å¢åŠ è½¦èº«è´¨é‡ï¼Œå¢åŠ ç¨³å®šæ€§
        const mass = 2000; 
        
        // 2. å½¢çŠ¶ä¿®æ­£
        const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.4, 2.2));
        chassisBody = new CANNON.Body({ mass: mass });
        
        // ** æ ¸å¿ƒä¿®å¤ï¼šé‡å¿ƒä¸‹ç§» **
        // å°†ç¢°æ’å½¢çŠ¶ç›¸å¯¹äºåˆšä½“ä¸­å¿ƒå‘ä¸Šç§»åŠ¨ï¼Œæ„å‘³ç€åˆšä½“ä¸­å¿ƒï¼ˆé‡å¿ƒï¼‰ç›¸å¯¹äºå½¢çŠ¶å‘ä¸‹ç§»åŠ¨
        // è¿™è®©è½¦å­å³ä½¿çœ‹èµ·æ¥å¾ˆé«˜ï¼Œç‰©ç†é‡å¿ƒå´å¾ˆä½ï¼Œåƒä¸å€’ç¿
        chassisBody.addShape(chassisShape, new CANNON.Vec3(0, 0.2, 0)); 

        chassisBody.position.set(0, 1.5, 0);
        
        // 3. ** æ ¸å¿ƒä¿®å¤ï¼šé«˜é˜»å°¼ **
        // angularDamping è®¾é«˜ï¼Œé˜²æ­¢è½¦èº«çªç„¶çš„å‰åä»°
        chassisBody.angularDamping = 0.9; 
        chassisBody.linearDamping = 0.05;
        
        world.addBody(chassisBody);

        vehicle = new CANNON.RaycastVehicle({
            chassisBody: chassisBody,
        });

        const wheelOptions = {
            radius: 0.45,
            directionLocal: new CANNON.Vec3(0, -1, 0),
            suspensionStiffness: 45,
            suspensionRestLength: 0.4,
            frictionSlip: 4.0, // ** æ ¸å¿ƒä¿®å¤ï¼šæé«˜æŠ“åœ°åŠ› **
            dampingRelaxation: 2.3,
            dampingCompression: 4.5,
            maxSuspensionForce: 100000,
            rollInfluence: 0.1, // ** æ ¸å¿ƒä¿®å¤ï¼š0.1 æ„å‘³ç€å‡ ä¹ä¸ä¼šä¾§ç¿» **
            axleLocal: new CANNON.Vec3(1, 0, 0),
            chassisConnectionPointLocal: new CANNON.Vec3(1, 1, 0),
            maxSuspensionTravel: 0.2,
            customSlidingRotationalSpeed: -30,
            useCustomSlidingRotationalSpeed: true
        };

        const axleWidth = 0.9;
        const frontLen = 1.4;
        const rearLen = 1.4;
        const heightOffset = -0.1; // è½®å­è¿æ¥ç‚¹é«˜åº¦

        // FL
        wheelOptions.chassisConnectionPointLocal.set(-axleWidth, heightOffset, frontLen);
        vehicle.addWheel(wheelOptions);
        // FR
        wheelOptions.chassisConnectionPointLocal.set(axleWidth, heightOffset, frontLen);
        vehicle.addWheel(wheelOptions);
        // RL
        wheelOptions.chassisConnectionPointLocal.set(-axleWidth, heightOffset, -rearLen);
        vehicle.addWheel(wheelOptions);
        // RR
        wheelOptions.chassisConnectionPointLocal.set(axleWidth, heightOffset, -rearLen);
        vehicle.addWheel(wheelOptions);

        vehicle.addToWorld(world);

        // åˆ›å»ºè½®å­Mesh
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 });
        for (let i = 0; i < vehicle.wheelInfos.length; i++) {
            let mesh;
            if(tireMeshPrototype) {
                mesh = tireMeshPrototype.clone();
                // ä¿®æ­£æ¨¡å‹æ—‹è½¬
                if(i===0 || i===2) mesh.rotation.y = Math.PI; // å·¦ä¾§è½®å­åè½¬
            } else {
                mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.45, 0.3, 24), wheelMat);
                mesh.rotation.z = Math.PI/2;
            }
            scene.add(mesh);
            wheelMeshes.push(mesh);
        }
    }

    // =============================================================================
    // ** æ§åˆ¶ä¸é€»è¾‘ **
    // =============================================================================
    window.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();
        if(k==='w') inputState.keyW = true;
        if(k==='s') inputState.keyS = true;
        if(k==='a') inputState.keyA = true;
        if(k==='d') inputState.keyD = true;
        if(k===' ') inputState.keySpace = true;
        if(k==='shift') inputState.keyShift = true;
        if(k==='v') activeCamera = (activeCamera === cameraChase) ? cameraCockpit : cameraChase;
    });
    window.addEventListener('keyup', (e) => {
        const k = e.key.toLowerCase();
        if(k==='w') inputState.keyW = false;
        if(k==='s') inputState.keyS = false;
        if(k==='a') inputState.keyA = false;
        if(k==='d') inputState.keyD = false;
        if(k===' ') inputState.keySpace = false;
        if(k==='shift') inputState.keyShift = false;
    });

    function updateControls() {
        if (!chassisBody) return;

        engineForce = 0;
        let brakeForce = 0;
        steeringValue = 0;

        // è½¬å‘
        if (inputState.keyA) steeringValue = maxSteerVal;
        if (inputState.keyD) steeringValue = -maxSteerVal;

        // åŠ¨åŠ›
        if (inputState.keyW) {
            engineForce = -maxEngineForce;
            // Shift åŠ é€Ÿé€»è¾‘
            if(inputState.keyShift) engineForce *= 2.5; 
        } else if (inputState.keyS) {
            engineForce = maxEngineForce * 0.8; // å€’è½¦ç¨å¾®æ…¢ç‚¹
        }

        // æ‰‹åˆ¹/åˆ¹è½¦
        if (inputState.keySpace) {
            brakeForce = maxBrakeForce * 2;
            engineForce = 0;
        }

        // åº”ç”¨
        vehicle.setSteeringValue(steeringValue, 0);
        vehicle.setSteeringValue(steeringValue, 1);

        // å››é©±è®¾å®š (AWD)
        vehicle.applyEngineForce(engineForce, 0);
        vehicle.applyEngineForce(engineForce, 1);
        vehicle.applyEngineForce(engineForce, 2);
        vehicle.applyEngineForce(engineForce, 3);

        vehicle.setBrake(brakeForce, 0);
        vehicle.setBrake(brakeForce, 1);
        vehicle.setBrake(brakeForce, 2);
        vehicle.setBrake(brakeForce, 3);

        // UI æ›´æ–°
        if(engineForce < 0) gearEl.innerText = "D";
        else if(engineForce > 0) gearEl.innerText = "R";
        else gearEl.innerText = "N";

        if(flameMesh) flameMesh.visible = (inputState.keyShift && inputState.keyW);
    }

    function updateCamera() {
        if(!chassisBody) return;
        const pos = chassisBody.position;
        const quat = chassisBody.quaternion;

        if (activeCamera === cameraChase) {
            // å¹³æ»‘è·Ÿéš
            const idealOffset = new THREE.Vector3(0, 2.5, -6.5);
            idealOffset.applyQuaternion(quat);
            idealOffset.add(pos);
            
            // é™åˆ¶æ‘„åƒæœºä¸æ‰å…¥åœ°ä¸‹
            if(idealOffset.y < pos.y + 0.5) idealOffset.y = pos.y + 0.5;

            cameraChase.position.lerp(idealOffset, 0.1);
            cameraChase.lookAt(pos.x, pos.y + 0.8, pos.z);
        } else {
            const offset = new THREE.Vector3(0, 0.5, 0.8);
            offset.applyQuaternion(quat);
            offset.add(pos);
            cameraCockpit.position.copy(offset);
            cameraCockpit.quaternion.copy(quat);
            cameraCockpit.rotateY(Math.PI);
        }
    }

    function updateHUD() {
        if(!chassisBody) return;
        const speed = Math.floor(chassisBody.velocity.length() * 3.6);
        speedEl.innerText = speed;
        rpmEl.innerText = Math.min(80, Math.floor(speed * 2.5));
        
        let t = 0;
        if(engineForce !== 0) t = Math.abs(engineForce / maxEngineForce * 100);
        if(t > 100) t = 100;
        throttleEl.innerText = Math.floor(t) + "%";
    }

    function updateDayNight(time) {
        const cycle = (time / 10000) % 1; // ç®€å•çš„å¾ªç¯
        // æ­¤å¤„ç®€åŒ–å¤„ç†ï¼Œä¿æŒè¾ƒå¥½çš„å¯è§åº¦
    }

    function updatePhysicsObjs() {
        const pos = chassisBody.position;
        staticBodies.forEach(obj => {
            const dist = pos.distanceTo(obj.center);
            if(!obj.added && dist < 50) {
                world.addBody(obj.body);
                obj.added = true;
            } else if(obj.added && dist > 55) {
                world.removeBody(obj.body);
                obj.added = false;
            }
        });
    }

    function animate(time) {
        requestAnimationFrame(animate);
        
        const dt = 1/60;
        world.step(dt);

        updateControls();
        
        // åŒæ­¥è½®å­æ¨¡å‹
        for (let i = 0; i < vehicle.wheelInfos.length; i++) {
            vehicle.updateWheelTransform(i);
            const t = vehicle.wheelInfos[i].worldTransform;
            if (wheelMeshes[i]) {
                wheelMeshes[i].position.copy(t.position);
                wheelMeshes[i].quaternion.copy(t.quaternion);
            }
        }

        // åŒæ­¥è½¦èº«æ¨¡å‹
        if (carMesh && chassisBody) {
            carMesh.position.copy(chassisBody.position);
            carMesh.quaternion.copy(chassisBody.quaternion);
        }

        updateCamera();
        updateHUD();
        updatePhysicsObjs();

        renderer.render(scene, activeCamera);
    }

    function startGame() {
        document.getElementById('splash').style.display = 'none';
        document.getElementById('loading-screen').style.display = 'flex';
        initThree();
        initCannon();
        initGround();
        initCameraAndLights();
        initLoaders();
        loadCarModel();
        loadTireModel();
        loadCity();
    }
    
    // Resize Handler
    window.addEventListener('resize', () => {
        if(renderer) {
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(cameraChase) {
                cameraChase.aspect = window.innerWidth/window.innerHeight;
                cameraChase.updateProjectionMatrix();
                cameraCockpit.aspect = window.innerWidth/window.innerHeight;
                cameraCockpit.updateProjectionMatrix();
            }
        }
        if(splashRenderer) {
            const c = document.getElementById('splash-three-container');
            splashRenderer.setSize(c.clientWidth, c.clientHeight);
            splashCamera.aspect = c.clientWidth/c.clientHeight;
            splashCamera.updateProjectionMatrix();
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        initLoaders();
        initSplashThree();
        loadSplashCarModel();
    });

    </script>
</body>
</html>
