<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F1 City Simulator - Zhanyi Zhou</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; user-select: none; }
        
        /* 仪表盘布局 */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            padding: 25px; box-sizing: border-box; z-index: 10;
        }

        .hud-top-left { display: flex; gap: 20px; flex-wrap: wrap; }
        
        .instrument {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: 4px solid #00aaff;
            backdrop-filter: blur(5px);
            padding: 10px 18px;
            color: #eee;
            min-width: 100px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            border-radius: 4px;
            transform: skewX(-10deg); /* 赛车风格倾斜 */
        }
        
        .instrument span { display: inline-block; transform: skewX(10deg); } /* 文字回正 */
        
        .label {
            font-size: 10px; color: #88ccff; font-weight: 700; letter-spacing: 1px;
            margin-bottom: 4px; display:block; text-transform: uppercase;
        }
        
        .value {
            font-size: 26px; font-weight: 700; font-family: 'Consolas', monospace; letter-spacing: -1px;
        }
        
        .unit {
            font-size: 12px; color: #aaa; margin-left: 4px; font-weight: 400;
        }

        /* 底部版权信息 */
        #credits {
            position: absolute;
            bottom: 20px;
            right: 25px;
            text-align: right;
            color: rgba(255, 255, 255, 0.4);
            font-size: 14px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: none;
        }

        #credits strong { color: rgba(255, 255, 255, 0.8); }

        /* 启动画面 */
        #splash {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #1a2a3a 0%, #000000 100%);
            z-index: 999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white;
        }
        
        #splash-three-container {
            width: 100%;
            height: 300px;
            margin-bottom: -50px;
            position: relative;
        }

        h1 {
            font-size: 48px;
            margin: 0;
            font-weight: 800;
            letter-spacing: 8px;
            text-transform: uppercase;
            color: #fff;
            background: linear-gradient(90deg, #00C9FF 0%, #92FE9D 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0, 200, 255, 0.3);
            font-style: italic;
        }

        button#start-button {
            margin-top: 30px;
            padding: 15px 50px;
            background: transparent;
            color: #00C9FF;
            border: 2px solid #00C9FF;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            letter-spacing: 2px;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        button#start-button:hover {
            background: #00C9FF;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 201, 255, 0.6);
        }

        /* 加载条 */
        #loading-screen {
            display:none; 
            flex-direction:column; 
            align-items:center; 
            justify-content:center; 
            position:absolute; top:0; left:0; 
            width:100%; height:100%; 
            background:#000; 
            color:#fff; 
            z-index:1000;
        }
    </style>
</head>
<body>
    <div id="splash">
        <div id="splash-three-container"></div>
        <h1>F1 CITY DRIFT</h1>
        <p style="opacity:0.6; margin-top:10px; letter-spacing: 2px;">ULTIMATE EDITION</p>
        <button id="start-button" onclick="startGame()">ENTER SIMULATION</button>
    </div>

    <div id="hud-layer" style="display:none;">
        <div class="hud-top-left">
            <div class="instrument">
                <span class="label">Speed</span>
                <span class="value" id="hud-spd">0</span> <span class="unit">KM/H</span>
            </div>
            <div class="instrument" style="border-left-color: #ff3333;">
                <span class="label" style="color:#ff5555">RPM</span>
                <span class="value" id="hud-rpm">0</span> <span class="unit">x100</span>
            </div>
            <div class="instrument" style="border-left-color: #ff9900;">
                <span class="label" style="color:#ff9900">Gear</span>
                <span class="value" id="hud-gear">P</span>
            </div>
            <div class="instrument" style="border-left-color: #00ff00;">
                <span class="label" style="color:#00ff00">Throttle</span>
                <span class="value" id="hud-throttle">0%</span>
            </div>
        </div>

        <div id="credits">
            Created by <strong>Zhanyi Zhou</strong><br>
            Powered by <strong>ChatGPT</strong>
        </div>
    </div>

    <div id="loading-screen">
        <h2 style="margin-bottom:20px; font-weight:300;">INITIALIZING WORLD</h2>
        <div id="loading-progress-bar" style="width:400px; height:4px; background:#222; border-radius:2px; overflow:hidden;">
            <div id="loading-progress-fill" style="height:100%; width:0%; background:#00C9FF; box-shadow: 0 0 10px #00C9FF;"></div>
        </div>
        <p id="loading-status" style="margin-top:15px; font-size:12px; color:#666;">LOADING ASSETS...</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

    <script>
    // =============================================================================
    // ** 全局变量 **
    // =============================================================================
    let scene, renderer, cameraChase, cameraCockpit, activeCamera;
    let world, vehicle, chassisBody;
    let wheelMeshes = [];
    let lastTime = undefined;

    // 光照
    let dirLight;

    // 资源与状态
    let staticBodies = [];
    let carMesh = null;
    let tireMeshPrototype = null;
    let flameMesh = null;
    let gltfLoader = null;
    let dracoLoader = null;

    // 输入状态
    const inputState = {
      keyW: false, keyS: false, keyA: false, keyD: false,
      keySpace: false, keyShift: false
    };

    // F1 物理参数 (已优化)
    const maxEngineForce = 15000; 
    const maxBrakeForce = 250;
    const maxSteerVal = 0.55;     
    const steerSpeed = 0.08;      
    
    // 实时状态
    let currentSteerAngle = 0;    
    let engineForce = 0;

    // HUD 元素
    const speedEl = document.getElementById('hud-spd');
    const rpmEl = document.getElementById('hud-rpm');
    const gearEl = document.getElementById('hud-gear');
    const throttleEl = document.getElementById('hud-throttle');

    // =============================================================================
    // ** 资源加载系统 **
    // =============================================================================
    function initLoaders() {
        dracoLoader = new THREE.DRACOLoader();
        dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/');

        const loadingManager = new THREE.LoadingManager();
        const progressFill = document.getElementById('loading-progress-fill');
        const loadingStatus = document.getElementById('loading-status');

        loadingManager.onProgress = function(itemUrl, itemsLoaded, itemsTotal) {
            const percent = Math.floor((itemsLoaded / itemsTotal) * 100);
            progressFill.style.width = percent + '%';
        };
        
        loadingManager.onLoad = function() {
            // 加载完成
            const loadScreen = document.getElementById('loading-screen');
            loadScreen.style.opacity = '0';
            loadScreen.style.transition = 'opacity 0.5s';
            setTimeout(() => {
                loadScreen.style.display = 'none';
                document.getElementById('hud-layer').style.display = 'flex';
                // 停止 Splash 动画以节省性能
                if(splashRenderer) {
                    splashRenderer.dispose();
                    document.getElementById('splash').remove();
                }
            }, 500);
            
            initVehicle();
            requestAnimationFrame(animate);
        };

        gltfLoader = new THREE.GLTFLoader(loadingManager);
        gltfLoader.setDRACOLoader(dracoLoader);
    }

    // =============================================================================
    // ** 启动画面 3D 预览 **
    // =============================================================================
    let splashScene, splashCamera, splashRenderer, splashCarModel;
    function initSplashThree() {
        const container = document.getElementById('splash-three-container');
        const width = container.clientWidth;
        const height = container.clientHeight;

        splashScene = new THREE.Scene();
        splashCamera = new THREE.PerspectiveCamera(50, width/height, 0.1, 100);
        splashRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        splashRenderer.setSize(width, height);
        splashRenderer.setClearColor(0x000000, 0);
        container.appendChild(splashRenderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 1.0);
        splashScene.add(ambient);
        const dir = new THREE.DirectionalLight(0x00C9FF, 2.0);
        dir.position.set(5, 5, 5);
        splashScene.add(dir);

        splashCamera.position.set(0, 1.5, 5);
        splashCamera.lookAt(0, 0.5, 0);

        function animateSplash() {
            if(document.getElementById('splash').style.display !== 'none') {
                requestAnimationFrame(animateSplash);
                if (splashCarModel) {
                    splashCarModel.rotation.y += 0.005;
                }
                splashRenderer.render(splashScene, splashCamera);
            }
        }
        animateSplash();
    }

    // =============================================================================
    // ** 游戏资源加载逻辑 **
    // =============================================================================
    function loadCarModel() {
        gltfLoader.load('car1.glb', (gltf) => {
            carMesh = gltf.scene;
            const carScale = 2.5;
            carMesh.scale.set(carScale, carScale, carScale);
            carMesh.rotation.y = Math.PI;
            carMesh.position.y = -0.6; 

            carMesh.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                    if(node.material) {
                        node.material.envMapIntensity = 1.0;
                        node.material.metalness = 0.7;
                        node.material.roughness = 0.2;
                    }
                }
            });
            scene.add(carMesh);

            const flameGeometry = new THREE.ConeGeometry(0.4 * carScale, 2.0 * carScale, 16);
            flameGeometry.rotateX(Math.PI / 2); 
            
            const flameMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true,
                opacity: 0.8
            });
            flameMesh = new THREE.Mesh(flameGeometry, flameMaterial);
            flameMesh.position.set(0, 0.5, 2.0 * carScale); 
            flameMesh.visible = false;
            carMesh.add(flameMesh);
        });

        gltfLoader.load('car1.glb', (gltf) => {
            splashCarModel = gltf.scene;
            splashCarModel.scale.set(2,2,2);
            splashCarModel.position.set(0, -0.5, 0);
            splashScene.add(splashCarModel);
        });
    }

    function loadTireModel() {
        gltfLoader.load('tire1.glb', (gltf) => {
            tireMeshPrototype = gltf.scene;
            tireMeshPrototype.scale.set(1.1, 1.1, 1.1);
            tireMeshPrototype.traverse((node) => {
                if (node.isMesh) node.castShadow = true;
            });
        });
    }

    function loadCity() {
        gltfLoader.load('city.glb', (gltf) => {
            const city = gltf.scene;
            city.scale.set(4, 4, 4);
            scene.add(city);

            city.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                    
                    const geometry = node.geometry.clone();
                    geometry.applyMatrix4(node.matrixWorld);
                    geometry.computeBoundingSphere();
                    
                    if (geometry.boundingSphere.radius > 1) {
                        const vertices = Array.from(geometry.attributes.position.array);
                        let indices = [];
                        if (geometry.index) {
                            indices = Array.from(geometry.index.array);
                        } else {
                            for (let i = 0; i < vertices.length/3; i++) indices.push(i);
                        }
                        
                        const shape = new CANNON.Trimesh(vertices, indices);
                        const body = new CANNON.Body({ mass: 0 });
                        body.addShape(shape);
                        
                        staticBodies.push({
                            body: body,
                            center: new THREE.Vector3().copy(geometry.boundingSphere.center),
                            radius: geometry.boundingSphere.radius,
                            added: false
                        });
                    }
                }
            });
        });
    }

    // =============================================================================
    // ** THREE.js 场景初始化 **
    // =============================================================================
    function initThree() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88ccff); 
        scene.fog = new THREE.Fog(0x88ccff, 50, 600);

        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);
    }

    function initCannon() {
        world = new CANNON.World();
        world.gravity.set(0, -12, 0); 
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.allowSleep = true;

        const defaultMaterial = new CANNON.Material('default');
        const contactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
            friction: 0.05, 
            restitution: 0.1
        });
        world.defaultContactMaterial = contactMaterial;
    }

    function initGround() {
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0 });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        const groundGeo = new THREE.PlaneGeometry(2000, 2000);
        const groundMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.position.y = -0.1;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);
    }

    function initCameraAndLights() {
        cameraChase = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
        cameraCockpit = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
        activeCamera = cameraChase;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(100, 150, 50);
        dirLight.castShadow = true;
        
        const d = 80;
        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;
        dirLight.shadow.camera.near = 1;
        dirLight.shadow.camera.far = 500;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.bias = -0.0005;
        scene.add(dirLight);
    }

    // =============================================================================
    // ** 车辆初始化 **
    // =============================================================================
    function initVehicle() {
        const chassisShape = new CANNON.Box(new CANNON.Vec3(1.1, 0.25, 2.2)); 
        chassisBody = new CANNON.Body({
            mass: 1200, 
            position: new CANNON.Vec3(0, 2, 0)
        });
        chassisBody.addShape(chassisShape);
        chassisBody.angularDamping = 0.5; 
        chassisBody.linearDamping = 0.02;
        world.addBody(chassisBody);

        vehicle = new CANNON.RaycastVehicle({
            chassisBody: chassisBody,
            indexRightAxis: 0,
            indexUpAxis: 1,
            indexForwardAxis: 2
        });

        const axleWidth = 1.3; 
        const wheelBaseFront = 1.6;
        const wheelBaseRear = 1.8;
        
        const wheelOptions = {
            radius: 0.55,
            directionLocal: new CANNON.Vec3(0, -1, 0),
            suspensionStiffness: 65,    
            suspensionRestLength: 0.4,  
            frictionSlip: 2.5,          
            dampingRelaxation: 2.3,
            dampingCompression: 4.4,
            maxSuspensionForce: 100000,
            rollInfluence: 0.05,        
            axleLocal: new CANNON.Vec3(1, 0, 0),
            chassisConnectionPointLocal: new CANNON.Vec3(1, 1, 0),
            useCustomSlidingRotationalSpeed: true,
            customSlidingRotationalSpeed: -30,
        };

        // 左前
        wheelOptions.chassisConnectionPointLocal.set(-axleWidth, 0, wheelBaseFront);
        vehicle.addWheel(wheelOptions);
        // 右前
        wheelOptions.chassisConnectionPointLocal.set(axleWidth, 0, wheelBaseFront);
        vehicle.addWheel(wheelOptions);
        // 左后
        wheelOptions.chassisConnectionPointLocal.set(-axleWidth, 0, -wheelBaseRear);
        vehicle.addWheel(wheelOptions);
        // 右后
        wheelOptions.chassisConnectionPointLocal.set(axleWidth, 0, -wheelBaseRear);
        vehicle.addWheel(wheelOptions);

        vehicle.addToWorld(world);

        if (tireMeshPrototype) {
            for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                const w = tireMeshPrototype.clone();
                wheelMeshes.push(w);
                scene.add(w);
            }
        } else {
            const wMat = new THREE.MeshPhongMaterial({color:0x111111});
            const wGeo = new THREE.CylinderGeometry(0.55, 0.55, 0.4, 24);
            wGeo.rotateZ(Math.PI/2);
            for(let i=0; i<4; i++) {
                const m = new THREE.Mesh(wGeo, wMat);
                wheelMeshes.push(m);
                scene.add(m);
            }
        }
    }

    // =============================================================================
    // ** 控制与物理循环 **
    // =============================================================================
    window.addEventListener('keydown', (e) => {
        switch(e.key.toLowerCase()) {
            case 'w': inputState.keyW = true; break;
            case 's': inputState.keyS = true; break;
            case 'a': inputState.keyA = true; break;
            case 'd': inputState.keyD = true; break;
            case ' ': inputState.keySpace = true; break;
            case 'shift': inputState.keyShift = true; break;
            case 'v': toggleCamera(); break;
        }
    });
    window.addEventListener('keyup', (e) => {
        switch(e.key.toLowerCase()) {
            case 'w': inputState.keyW = false; break;
            case 's': inputState.keyS = false; break;
            case 'a': inputState.keyA = false; break;
            case 'd': inputState.keyD = false; break;
            case ' ': inputState.keySpace = false; break;
            case 'shift': inputState.keyShift = false; break;
        }
    });

    function toggleCamera() {
        activeCamera = (activeCamera === cameraChase) ? cameraCockpit : cameraChase;
    }

    function updatePhysics() {
        if (!chassisBody) return;

        let targetSteer = 0;
        if (inputState.keyA) targetSteer = maxSteerVal;
        if (inputState.keyD) targetSteer = -maxSteerVal;

        currentSteerAngle += (targetSteer - currentSteerAngle) * steerSpeed;
        
        vehicle.setSteeringValue(currentSteerAngle, 0); 
        vehicle.setSteeringValue(currentSteerAngle, 1); 

        engineForce = 0;
        let brakeForce = 0;
        
        const vel = chassisBody.velocity;
        
        if (inputState.keyW) {
             engineForce = -maxEngineForce; 
        } else if (inputState.keyS) {
             engineForce = maxEngineForce * 0.6; 
        }

        if (inputState.keyShift && inputState.keyW) {
            engineForce *= 5; 
            if(flameMesh) flameMesh.visible = true;
        } else {
            if(flameMesh) flameMesh.visible = false;
        }

        vehicle.applyEngineForce(engineForce, 0);
        vehicle.applyEngineForce(engineForce, 1);
        vehicle.applyEngineForce(engineForce, 2);
        vehicle.applyEngineForce(engineForce, 3);

        if (inputState.keySpace) {
            brakeForce = 150; 
            vehicle.setBrake(brakeForce, 2);
            vehicle.setBrake(brakeForce, 3);
            vehicle.setBrake(brakeForce * 0.2, 0);
            vehicle.setBrake(brakeForce * 0.2, 1);
        } else {
            vehicle.setBrake(0, 0);
            vehicle.setBrake(0, 1);
            vehicle.setBrake(0, 2);
            vehicle.setBrake(0, 3);
        }
    }

    function updateVisuals() {
        if(!chassisBody) return;

        for (let i = 0; i < vehicle.wheelInfos.length; i++) {
            vehicle.updateWheelTransform(i);
            const t = vehicle.wheelInfos[i].worldTransform;
            if (wheelMeshes[i]) {
                wheelMeshes[i].position.copy(t.position);
                wheelMeshes[i].quaternion.copy(t.quaternion);
            }
        }

        if (carMesh) {
            carMesh.position.copy(chassisBody.position);
            carMesh.quaternion.copy(chassisBody.quaternion);
        }

        const chassisPos = chassisBody.position;
        const speed = chassisBody.velocity.length();

        if (activeCamera === cameraChase) {
            const dist = 8 + (speed * 0.1); 
            const offset = new THREE.Vector3(0, 4.0, 7.5 + (speed * 0.05)); 
            offset.applyQuaternion(chassisBody.quaternion);
            offset.add(chassisPos); 

            cameraChase.position.lerp(offset, 0.1); 
            const lookTarget = new THREE.Vector3(0, 1, -5); 
            lookTarget.applyQuaternion(chassisBody.quaternion);
            lookTarget.add(chassisPos);
            cameraChase.lookAt(lookTarget);
        } else {
            const offset = new THREE.Vector3(0, 1.2, 0.5); 
            offset.applyQuaternion(chassisBody.quaternion);
            offset.add(chassisPos);
            cameraCockpit.position.copy(offset);
            cameraCockpit.quaternion.copy(chassisBody.quaternion);
            cameraCockpit.rotateY(Math.PI); 
        }

        if(dirLight) {
            dirLight.position.set(chassisPos.x + 50, chassisPos.y + 100, chassisPos.z + 50);
            dirLight.target.position.copy(chassisPos);
            dirLight.target.updateMatrixWorld();
        }
    }

    function updateHUD() {
        if (!chassisBody) return;
        const v = chassisBody.velocity;
        const kmh = v.length() * 3.6;
        
        speedEl.textContent = Math.floor(kmh);
        
        let rpm = 0;
        if (engineForce !== 0) {
            rpm = 10 + (Math.abs(kmh) / 300) * 70;
            if(inputState.keyShift) rpm += 10;
        } else {
            rpm = Math.max(0, kmh / 10);
        }
        rpmEl.textContent = Math.min(99, Math.floor(rpm));

        if (inputState.keySpace) gearEl.textContent = 'DRIFT';
        else if (kmh < 1 && Math.abs(engineForce) < 10) gearEl.textContent = 'N';
        else if (inputState.keyW) gearEl.textContent = inputState.keyShift ? 'S' : 'D';
        else if (inputState.keyS) gearEl.textContent = 'R';

        const throttle = engineForce !== 0 ? (inputState.keyShift ? 100 : 70) : 0;
        throttleEl.textContent = throttle + '%';
    }

    // ✅ FIXED FUNCTION: 将Cannon向量转换为Three向量再进行计算
    function updateColliders() {
        if (!chassisBody) return;
        
        // 关键修复：将Cannon.js的Vec3转换为Three.js的Vector3
        const pos = new THREE.Vector3(chassisBody.position.x, chassisBody.position.y, chassisBody.position.z);
        
        staticBodies.forEach(obj => {
            // 现在 pos 是 Three.js 对象，可以使用 distanceToSquared
            const distSq = pos.distanceToSquared(obj.center);
            const range = obj.radius + 15; 
            if (!obj.added && distSq < range * range) {
                world.addBody(obj.body);
                obj.added = true;
            } else if (obj.added && distSq > range * range) {
                world.removeBody(obj.body);
                obj.added = false;
            }
        });
    }

    function animate(time) {
        requestAnimationFrame(animate);

        const dt = 1 / 60;
        if(world) world.step(dt);

        updatePhysics();
        updateVisuals();
        updateHUD();
        updateColliders();

        renderer.render(scene, activeCamera);
    }

    // =============================================================================
    // ** 启动流程 **
    // =============================================================================
    window.startGame = function() {
        document.getElementById('splash').style.display = 'none';
        document.getElementById('loading-screen').style.display = 'flex';
        
        initThree();
        initCannon();
        initGround();
        initCameraAndLights();
        
        initLoaders();
        loadCarModel();
        loadTireModel();
        loadCity();
    };

    window.addEventListener('resize', () => {
        if (renderer) {
            renderer.setSize(window.innerWidth, window.innerHeight);
            cameraChase.aspect = window.innerWidth / window.innerHeight;
            cameraChase.updateProjectionMatrix();
            cameraCockpit.aspect = cameraChase.aspect;
            cameraCockpit.updateProjectionMatrix();
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        initSplashThree();
        const gltfSimple = new THREE.GLTFLoader();
        const dracoSimple = new THREE.DRACOLoader();
        dracoSimple.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/');
        gltfSimple.setDRACOLoader(dracoSimple);
        gltfSimple.load('car1.glb', (gltf) => {
             splashCarModel = gltf.scene;
             splashCarModel.scale.set(1.8,1.8,1.8);
             splashCarModel.position.set(0, -0.6, 0);
             if(splashScene) splashScene.add(splashCarModel);
        });
    });

    </script>
</body>
</html>
