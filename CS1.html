<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ASL Car Simulator - Hyper Drive Edition (with Gold Coins)</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* =========================================================================
         * UI 基础与字体
         * ========================================================================= */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000000; 
            font-family: 'Rajdhani', sans-serif; 
            color: #E0FFFF;
            user-select: none; 
        }
        
        /* =========================================================================
         * HUD 整体布局
         * ========================================================================= */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            padding: 30px; box-sizing: border-box; z-index: 10;
        }

        .hud-top-left { 
            display: flex; 
            gap: 20px; 
            flex-wrap: wrap; 
        }

        .hud-top-right {
            position: absolute;
            top: 30px;
            right: 30px;
        }
        
        /* 仪表盘核心样式 - 赛博朋克霓虹风 */
        .instrument {
            background: rgba(0, 15, 30, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-left: 5px solid #00FFFF; /* 默认霓虹蓝 */
            backdrop-filter: blur(10px);
            padding: 12px 22px;
            min-width: 120px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
            border-radius: 4px;
            transition: all 0.2s ease;
            clip-path: polygon(0 0, 100% 0, 100% 80%, 90% 100%, 0 100%); /* 切角设计 */
        }
        
        .instrument:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.4);
        }

        /* 标签 */
        .label {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px; 
            color: #00FFFF; 
            font-weight: 700; 
            letter-spacing: 2px;
            margin-bottom: 3px; 
            display:block; 
            text-transform: uppercase; 
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.8);
        }
        
        /* 值 */
        .value {
            font-family: 'Orbitron', sans-serif;
            font-size: 36px; 
            font-weight: 900; 
            letter-spacing: -2px;
            line-height: 1;
            color: #FFFFFF;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }
        
        .unit {
            font-size: 14px; 
            color: #888888; 
            margin-left: 6px; 
            font-weight: 400;
        }

        /* 特殊颜色 */
        .spd-color { border-left-color: #00FFFF !important; }
        .rpm-color { border-left-color: #FF00FF !important; }
        .gear-color { border-left-color: #FFD700 !important; }
        .throttle-color { border-left-color: #00FF00 !important; }

        /* HUD coin 仪表 - 与原风格一致 */
        #hud-coin {
            background: rgba(35, 18, 0, 0.7);
            border: 1px solid rgba(255, 215, 0, 0.15);
            border-left: 5px solid #FFD700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.06);
            min-width: 140px;
            margin-bottom: 20px;
        }
        #hud-coin .label { color: #FFD700; text-shadow: 0 0 5px rgba(255, 215, 0, 0.6); }
        #coin-count { font-size: 40px; letter-spacing: 2px; color: #FFD700; }

        /* =========================================================================
         * 底部控制提示与版权
         * ========================================================================= */
        #control-hints {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: 5px solid #00FF00;
            backdrop-filter: blur(10px);
            padding: 18px 25px;
            color: #eee;
            font-size: 13px;
            border-radius: 4px;
            max-width: 250px;
            line-height: 1.8;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.1);
        }
        
        /* 新增的重生提示的特殊样式 */
        .respawn-hint {
            color: #FFD700;
            font-weight: bold;
        }

        .hint-title {
            color: #00FF00;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
            font-size: 11px;
            border-bottom: 1px solid rgba(0, 255, 0, 0.3);
            padding-bottom: 5px;
            letter-spacing: 2px;
        }
        
        /* 版权标识 */
        .copyright-tag {
            position: fixed;
            bottom: 15px;
            right: 15px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.3);
            letter-spacing: 1px;
            z-index: 10;
        }

        /* =========================================================================
         * 启动画面样式
         * ========================================================================= */
        #splash {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #000000 0%, #0a0a1a 100%);
            z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white;
            opacity: 1;
            transition: opacity 0.5s;
        }
        
        #splash-three-container {
            width: 300px; height: 150px; margin-bottom: 20px; position: relative;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 48px;
            margin: 0;
            font-weight: 900;
            letter-spacing: 10px;
            text-transform: uppercase;
            background: linear-gradient(to right, #00FFFF, #FF00FF);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }

        #start-button {
            margin-top: 40px;
            padding: 15px 60px;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: bold;
            color: #000000;
            background: #00FFFF;
            border: none;
            cursor: pointer;
            transition: 0.3s;
            letter-spacing: 3px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
            clip-path: polygon(0 0, 100% 0, 90% 100%, 10% 100%);
        }

        #start-button:hover {
            background: #FF00FF;
            box-shadow: 0 0 40px rgba(255, 0, 255, 1);
            color: #fff;
        }
        
        .splash-subtitle {
            font-family: 'Rajdhani', sans-serif;
            font-size: 18px;
            color: rgba(0, 255, 255, 0.7);
            letter-spacing: 4px;
        }

        /* 加载界面 */
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #00FFFF; z-index: 1000;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            opacity: 0; transition: opacity 0.5s;
        }
        #loading-screen p { font-family: 'Orbitron', sans-serif; }
        #loading-progress-bar { width: 400px; height: 5px; background: #222; margin-top: 10px; border-radius: 2px; overflow: hidden; }
        #loading-progress-fill { height: 100%; width: 0%; background: #00FFFF; box-shadow: 0 0 10px #00FFFF; }

    </style>
</head>
<body>
    <div id="splash">
        <div id="splash-three-container"></div>
        <h1>HYPER DRIVE</h1>
        <p class="splash-subtitle">MADE BY ZHANYI ZHOU</p>
        <div style="margin-top:16px; color:#FFD700; font-weight:700;">Gold Coin collected: <span id="splash-coin-count">0</span></div>
        <button id="start-button" onclick="startGame()">PLAY NOW</button>
    </div>

    <div class="copyright-tag">ZHANYI ZHOU DESIGN © 2025</div>

    <div id="hud-layer" style="display:none;">
        <div class="hud-top-left">
            <div class="instrument spd-color">
                <span class="label">Speed</span>
                <span class="value" id="hud-spd">0</span> <span class="unit">KM/H</span>
            </div>
            <div class="instrument rpm-color">
                <span class="label">RPM</span>
                <span class="value" id="hud-rpm">0</span> <span class="unit">x100</span>
            </div>
            <div class="instrument gear-color">
                <span class="label">Gear</span>
                <span class="value" id="hud-gear">P</span> <span class="unit">MODE</span>
            </div>
            <div class="instrument throttle-color">
                <span class="label">Throttle</span>
                <span class="value" id="hud-throttle">0%</span>
            </div>
            <div class="instrument">
                <span class="label">Altitude</span>
                <span class="value" id="hud-alt">0</span> <span class="unit">M</span>
            </div>
            <div class="instrument">
                <span class="label">Heading</span>
                <span class="value" id="hud-hdg">000</span> <span class="unit">DEG</span>
            </div>
            <div class="instrument">
                <span class="label">Time</span>
                <span class="value" id="hud-time">DAY</span>
            </div>
        </div>

        <div class="hud-top-right">
            <div class="instrument" id="hud-coin">
                <span class="label">GOLD COIN</span>
                <span class="value" id="coin-count">0</span>
            </div>
        </div>

        <div class="hud-bottom">
            <div id="control-hints">
                <div class="hint-title">SYSTEM CONTROLS</div>
                <div>[SHIFT] NITRO BOOST (MAX TORQUE)</div>
                <div>[SPACE] HANDBRAKE DRIFT</div>
                <div>[V] TOGGLE CAMERA</div>
                <div class="respawn-hint">[R] RESPAWN CAR (RESETS VELOCITY)</div>
                <div>[WASD] DRIVE</div>
            </div>
        </div>
    </div>

    <div id="loading-screen">
        <p>LOADING CITY AND ASSETS...</p>
        <div id="loading-progress-bar">
            <div id="loading-progress-fill"></div>
        </div>
        <p id="loading-status" style="margin-top:10px; font-size:14px;">(0%)</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

    <script>
    // =============================================================================
    // ** 核心变量 **
    // =============================================================================
    let scene, renderer;
    let cameraChase, cameraCockpit, activeCamera;
    let world, vehicle, chassisBody;
    let wheelMeshes = [];
    let lastTime = undefined;

    // ** 环境光/日夜切换变量 **
    let hemiLight, dirLight;
    const daySkyColor = new THREE.Color(0x87CEEB);
    const nightSkyColor = new THREE.Color(0x050510);
    const dayHemiSky = new THREE.Color(0xffffff);
    const nightHemiSky = new THREE.Color(0x111133);
    const dayHemiGround = new THREE.Color(0x3b4c5a);
    const nightHemiGround = new THREE.Color(0x04040a);

    // ** 物理调整参数 **
    const maxEngineForce = 9000; 
    const brakeForce = 40;
    const maxSteerVal = 0.7;

    // ** 日夜循环时间 **
    const cycleDurationSec = 300; // 5 分钟

    // ** 车辆初始位置 **
    const initialCarPosition = new CANNON.Vec3(90, 0.6, 0);

    // 状态和加载器
    let staticBodies = [];
    let carMesh = null;
    let tireMeshPrototype = null;
    let flameMesh = null;
    let gltfLoader = null;
    let dracoLoader = null;

    const inputState = { keyW: false, keyS: false, keyA: false, keyD: false, keySpace: false, keyShift: false, keyR: false };

    // 仪表盘元素
    const speedEl = document.getElementById('hud-spd');
    const altitudeEl = document.getElementById('hud-alt');
    const headingEl = document.getElementById('hud-hdg');
    const rpmEl = document.getElementById('hud-rpm');
    const gearEl = document.getElementById('hud-gear');
    const throttleEl = document.getElementById('hud-throttle');
    const timeEl = document.getElementById('hud-time');
    const coinCountEl = document.getElementById('coin-count');
    const splashCoinCountEl = document.getElementById('splash-coin-count');

    let headlightLeft = null, headlightRight = null;

    let engineForce = 0;
    let steeringValue = 0;

    // =============================================================================
    // ** Gold coin 相关状态 **
    // =============================================================================
    let coinProto = null;             // 预加载的金币原型（GLTF.scene）
    let coinMeshes = [];              // Three.js mesh 实例列表
    let coinBodies = [];              // Cannon.js body 实例列表
    let coinCount = 0;                // 当前金币数量（持久化到 localStorage）
    const COIN_MIN = 50;
    const COIN_MAX = 80;
    const COIN_SPAWN_RADIUS = 800;    // 随机位置半径（相对城市中心）
    const COIN_HEIGHT = 0.7;          // Y 高度

    // =============================================================================
    // ** 加载器初始化 **
    // =============================================================================
    function initLoaders() {
        dracoLoader = new THREE.DRACOLoader();
        dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/');

        const loadingManager = new THREE.LoadingManager();
        const progressFill = document.getElementById('loading-progress-fill');
        const loadingStatus = document.getElementById('loading-status');
        
        loadingManager.onProgress = function(itemUrl, itemsLoaded, itemsTotal) {
            const percent = Math.floor((itemsLoaded / itemsTotal) * 100);
            progressFill.style.width = percent + '%';
            loadingStatus.innerText = `(${percent}%) Loading ${itemsLoaded}/${itemsTotal}`;
        };
        
        loadingManager.onLoad = function() {
            // 加载完成：显示 HUD，初始化车辆物理，产生金币，然后启动动画循环
            cancelAnimationFrame(splashAnimationId);
            document.getElementById('loading-screen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('hud-layer').style.display = 'flex';
            }, 500);

            initVehicle();
            // 在车辆初始化后生成金币（需要 chassisBody 存在以便碰撞检测）
            spawnCoinsWhenReady();
            requestAnimationFrame(animate);
        };

        gltfLoader = new THREE.GLTFLoader(loadingManager);
        gltfLoader.setDRACOLoader(dracoLoader);
    }

    // =============================================================================
    // ** 启动画面 3D 逻辑 **
    // =============================================================================
    let splashScene, splashCamera, splashRenderer, splashAnimationId, splashCarModel;
    function initSplashThree() {
        const container = document.getElementById('splash-three-container');
        const width = container.clientWidth;
        const height = container.clientHeight;

        splashScene = new THREE.Scene();
        splashCamera = new THREE.PerspectiveCamera(60, width/height, 0.1, 1000);
        splashRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        splashRenderer.setSize(width, height);
        splashRenderer.setClearColor(0x000000, 0);
        container.appendChild(splashRenderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        splashScene.add(ambient);
        const dir = new THREE.DirectionalLight(0x00FFFF, 1.5);
        dir.position.set(5,10,7.5);
        splashScene.add(dir);

        splashCamera.position.set(0, 1, 3);
        splashCamera.lookAt(0, 0.5, 0);

        function animateSplash() {
            splashAnimationId = requestAnimationFrame(animateSplash);
            if (splashCarModel) {
                splashCarModel.rotation.y += 0.01;
            }
            splashRenderer.render(splashScene, splashCamera);
        }
        animateSplash();
    }

    function loadSplashCarModel() {
        if (!gltfLoader) return;
        const simpleLoader = new THREE.GLTFLoader();
        simpleLoader.setDRACOLoader(dracoLoader);
        simpleLoader.load('car1.glb', (gltf) => {
            splashCarModel = gltf.scene;
            splashCarModel.scale.set(104.7,104.7,104.7);
            splashCarModel.position.set(0,-1.0,0);
            splashScene.add(splashCarModel);
        });
    }
    
    // =============================================================================
    // ** 游戏资源加载 **
    // =============================================================================
    function loadCarModel() {
        gltfLoader.load('car1.glb', (gltf) => {
            carMesh = gltf.scene;
            carMesh.scale.set(104.7, 104.7, 104.7);
            carMesh.rotation.y = Math.PI;
            // 把车整体往下移
            // *** GLB 视觉修改点 *** 从 -1.9 调整为 -2.1，视觉上进一步降低 0.2
            carMesh.position.y = -9.9;
            carMesh.traverse((node) => { if (node.isMesh) node.castShadow = true; });
            scene.add(carMesh);

            // ========== 前灯（白色，白天关闭，夜间打开） ==========
            // 确保 SpotLight 强度不为 0，否则阴影不会工作
            headlightLeft = new THREE.SpotLight(0xffffff, 1.0, 60, Math.PI / 7, 0.2, 2);
            headlightLeft.castShadow = true;
            headlightLeft.shadow.mapSize.width = 1024;
            headlightLeft.shadow.mapSize.height = 1024;
            headlightLeft.position.set(-0.6, 0.4, 2.2);
            const leftTarget = new THREE.Object3D();
            leftTarget.position.set(-0.6, 0.4, 10);
            carMesh.add(leftTarget);
            headlightLeft.target = leftTarget;
            carMesh.add(headlightLeft);

            headlightRight = new THREE.SpotLight(0xffffff, 1.0, 60, Math.PI / 7, 0.2, 2);
            headlightRight.castShadow = true;
            headlightRight.shadow.mapSize.width = 1024;
            headlightRight.shadow.mapSize.height = 1024;
            headlightRight.position.set(0.6, 0.4, 2.2);
            const rightTarget = new THREE.Object3D();
            rightTarget.position.set(0.6, 0.4, 10);
            carMesh.add(rightTarget);
            headlightRight.target = rightTarget;
            carMesh.add(headlightRight);
            // ========= 结束前灯 ==========

            // 原来的“火焰/尾焰” — 已改为白色（去掉蓝色）
            const flameGeometry = new THREE.ConeGeometry(0.3, 1, 16);
            const flameMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.75 });
            flameMesh = new THREE.Mesh(flameGeometry, flameMaterial);
            flameMesh.rotation.x = -Math.PI / 2;
            flameMesh.position.set(0, 0, 2.5);
            flameMesh.visible = false;
            carMesh.add(flameMesh);
        });
    }

    function loadTireModel() {
        gltfLoader.load('tire1.glb', (gltf) => {
            tireMeshPrototype = gltf.scene;
            tireMeshPrototype.scale.set(0.75, 0.75, 0.75);
            tireMeshPrototype.rotation.x = Math.PI / 2;
            tireMeshPrototype.traverse((node) => { if (node.isMesh) node.castShadow = true; });
        });
    }

    function loadCity() {
        gltfLoader.load('city.glb', (gltf) => {
            const city = gltf.scene;
            city.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;

                    // Remove city emissive: clone material and zero emissive (no self-illumination)
                    if (node.material) {
                        const mat = node.material.clone ? node.material.clone() : node.material;
                        if (mat.emissive !== undefined) {
                            mat.emissive = new THREE.Color(0x000000);
                            mat.emissiveIntensity = 0;
                        }
                        node.material = mat;
                        node.userData.isStandardMaterial = true;
                    }
                }
            });
            city.scale.set(4,4,4);
            scene.add(city);

            city.updateMatrixWorld(true);
            city.traverse((node) => {
                if (node.isMesh) {
                    const geometry = node.geometry.clone();
                    geometry.applyMatrix4(node.matrixWorld);
                    geometry.computeBoundingSphere();
                    const vertices = Array.from(geometry.attributes.position.array);
                    let indices = [];
                    if (geometry.index) {
                        indices = Array.from(geometry.index.array);
                    } else {
                        for (let i = 0; i < vertices.length/3; i++) indices.push(i);
                    }
                    const shape = new CANNON.Trimesh(vertices, indices);
                    const body = new CANNON.Body({ mass: 0 });
                    body.addShape(shape);
                    staticBodies.push({
                        body: body,
                        center: new THREE.Vector3().copy(geometry.boundingSphere.center),
                        radius: geometry.boundingSphere.radius,
                        added: false
                    });
                }
            });
        });
    }

    // =============================================================================
    // ** THREE.js/Cannon.js 基础设置 **
    // =============================================================================
    function initThree() {
        scene = new THREE.Scene();
        scene.background = daySkyColor.clone();
        scene.fog = new THREE.Fog(daySkyColor, 500, 800);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
    }

    function initCannon() {
        world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.allowSleep = true;

        const defaultMaterial = new CANNON.Material('default');
        const contactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
            friction: 1.0, 
            restitution: 0.0
        });
        world.defaultContactMaterial = contactMaterial;
        world.addContactMaterial(contactMaterial);
    }

    function initGround() {
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0 });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        const groundGeo = new THREE.PlaneGeometry(500, 500, 10, 10);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8, metalness: 0.2 });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.position.y = -0.05;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);
    }

    function initCameraAndLights() {
        cameraChase = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        cameraCockpit = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
        activeCamera = cameraChase;

        hemiLight = new THREE.HemisphereLight(dayHemiSky.clone(), dayHemiGround.clone(), 0.8);
        scene.add(hemiLight);

        dirLight = new THREE.DirectionalLight(0xfff0dd, 1.0);
        dirLight.position.set(50,100,50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 4096;
        dirLight.shadow.mapSize.height = 4096;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 500;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        scene.add(dirLight);
    }

    // =============================================================================
    // ** 车辆物理核心 (重新应用物理调整) **
    // =============================================================================
    function initVehicle() {
        const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.5, 2));
        chassisBody = new CANNON.Body({
            mass: 2500, 
            shape: chassisShape,
            position: initialCarPosition.clone()
        });
        chassisBody.angularDamping = 0.9; 
        chassisBody.linearDamping = 0.05;
        world.addBody(chassisBody);

        vehicle = new CANNON.RaycastVehicle({
            chassisBody: chassisBody,
            indexRightAxis: 0,
            indexUpAxis: 1,
            indexForwardAxis: 2
        });

        const axleWidth = 1.0;
        const wheelBase = 1.5;
        function makeWheelOptions(x,y,z) {
            return {
                radius: 0.5,
                directionLocal: new CANNON.Vec3(0, -1, 0),
                suspensionStiffness: 150,
                suspensionRestLength: 0.3,
                frictionSlip: 4.0, 
                dampingRelaxation: 8.0,
                dampingCompression: 10.0,
                maxSuspensionForce: 100000,
                rollInfluence: 0.05, 
                maxSuspensionTravel: 0.3,
                customSlidingRotationalSpeed: -30,
                useCustomSlidingRotationalSpeed: true,
                axleLocal: new CANNON.Vec3(1, 0, 0),
                chassisConnectionPointLocal: new CANNON.Vec3(x, y, z) 
            };
        }

        vehicle.addWheel(makeWheelOptions(-axleWidth, 0, wheelBase)); // 0: FL
        vehicle.addWheel(makeWheelOptions( axleWidth, 0, wheelBase)); // 1: FR
        vehicle.addWheel(makeWheelOptions(-axleWidth, 0, -wheelBase)); // 2: RL
        vehicle.addWheel(makeWheelOptions( axleWidth, 0, -wheelBase)); // 3: RR

        vehicle.addToWorld(world);

        wheelMeshes = [];
        if (tireMeshPrototype) {
            for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                const wheelMesh = tireMeshPrototype.clone();
                if(i===0 || i===2) wheelMesh.rotation.y = Math.PI; 
                wheelMeshes.push(wheelMesh);
                scene.add(wheelMesh);
            }
        } else {
            const wheelMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
            for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                const wheel = vehicle.wheelInfos[i];
                const cylinderGeometry = new THREE.CylinderGeometry(wheel.radius, wheel.radius, 0.2, 32);
                cylinderGeometry.rotateZ(Math.PI / 2);
                const wheelMesh = new THREE.Mesh(cylinderGeometry, wheelMat);
                wheelMeshes.push(wheelMesh);
                scene.add(wheelMesh);
            }
        }
    }

    function respawnCar() {
        if (!chassisBody) return;
        chassisBody.position.copy(initialCarPosition);
        chassisBody.quaternion.set(0, 0, 0, 1);
        chassisBody.velocity.set(0, 0, 0);
        chassisBody.angularVelocity.set(0, 0, 0);

        vehicle.applyEngineForce(0, 0); 
        vehicle.applyEngineForce(0, 1); 
        vehicle.applyEngineForce(0, 2); 
        vehicle.applyEngineForce(0, 3); 
        vehicle.setSteeringValue(0, 0);
        vehicle.setSteeringValue(0, 1);
        vehicle.setBrake(0, 0);
        vehicle.setBrake(0, 1);
        vehicle.setBrake(0, 2);
        vehicle.setBrake(0, 3);

        gearEl.textContent = 'P';
        console.log("Car Respawned to initial position.");
    }

    // =============================================================================
    // ** 控制与更新（保留原逻辑） **
    // =============================================================================
    window.addEventListener('keydown', (event) => {
        const k = event.key.toLowerCase();
        if(k==='w') inputState.keyW = true;
        if(k==='s') inputState.keyS = true;
        if(k==='a') inputState.keyA = true;
        if(k==='d') inputState.keyD = true;
        if(k===' ') { inputState.keySpace = true; event.preventDefault(); }
        if(k==='shift') inputState.keyShift = true;
        if(k==='v') toggleCamera();
        if(k==='r') { inputState.keyR = true; respawnCar(); }
    });
    window.addEventListener('keyup', (event) => {
        const k = event.key.toLowerCase();
        if(k==='w') inputState.keyW = false;
        if(k==='s') inputState.keyS = false;
        if(k==='a') inputState.keyA = false;
        if(k==='d') inputState.keyD = false;
        if(k===' ') inputState.keySpace = false;
        if(k==='shift') inputState.keyShift = false;
        if(k==='r') inputState.keyR = false;
    });

    function toggleCamera() {
        activeCamera = (activeCamera === cameraChase) ? cameraCockpit : cameraChase;
    }

    function updateControls() {
        if (!chassisBody) return;
        engineForce = 0;
        steeringValue = 0;
        let brake = 0;

        const v = chassisBody.velocity;
        const currentSpeed = v.length() * 3.6;
        const chassisQuaternion = new THREE.Quaternion(chassisBody.quaternion.x, chassisBody.quaternion.y, chassisBody.quaternion.z, chassisBody.quaternion.w);
        const forwardVector = new THREE.Vector3(0, 0, 1).applyQuaternion(chassisQuaternion);
        const velocityVector = new THREE.Vector3(v.x, v.y, v.z);
        const isMovingForward = velocityVector.dot(forwardVector) > 0.5;
        const isMovingBackward = velocityVector.dot(forwardVector) < -0.5;

        if (inputState.keyA) steeringValue = maxSteerVal;
        else if (inputState.keyD) steeringValue = -maxSteerVal;

        if (inputState.keyW) {
            if (isMovingBackward) brake = maxEngineForce * 0.5;
            else { engineForce = -maxEngineForce; gearEl.textContent = 'D'; }
        } else if (inputState.keyS) {
            if (isMovingForward) brake = maxEngineForce * 0.5;
            else { engineForce = maxEngineForce * 0.5; gearEl.textContent = 'R'; }
        } else if (!inputState.keySpace) {
            gearEl.textContent = (currentSpeed < 1) ? 'P' : 'N';
        }

        if (inputState.keyShift && engineForce !== 0) {
            engineForce *= 2.5;
            if (flameMesh) flameMesh.visible = true;
        } else {
            if (flameMesh) flameMesh.visible = false;
        }

        vehicle.setSteeringValue(steeringValue, 0);
        vehicle.setSteeringValue(steeringValue, 1);
        vehicle.applyEngineForce(engineForce, 0); 
        vehicle.applyEngineForce(engineForce, 1); 
        vehicle.applyEngineForce(engineForce, 2); 
        vehicle.applyEngineForce(engineForce, 3); 

        let finalBrakeRL = brake, finalBrakeRR = brake;
        if (inputState.keySpace) {
            finalBrakeRL = maxEngineForce * 0.8; 
            finalBrakeRR = maxEngineForce * 0.8;
            gearEl.textContent = 'E';
        } else if (brake === 0) {
            vehicle.setBrake(0, 0);
            vehicle.setBrake(0, 1);
            vehicle.setBrake(0, 2);
            vehicle.setBrake(0, 3);
        }

        vehicle.setBrake(brake, 0);
        vehicle.setBrake(brake, 1);
        vehicle.setBrake(finalBrakeRL, 2);
        vehicle.setBrake(finalBrakeRR, 3);
    }

    function updateCamera() {
        if (!chassisBody) return;
        const chassisPos = new THREE.Vector3().copy(chassisBody.position);
        const q = chassisBody.quaternion;

        if (activeCamera === cameraChase) {
            const idealOffset = new THREE.Vector3(0, 3, -7);
            idealOffset.applyQuaternion(q);
            idealOffset.add(chassisPos);
            if(idealOffset.y < chassisPos.y + 0.5) idealOffset.y = chassisPos.y + 0.5;
            cameraChase.position.lerp(idealOffset, 0.1);
            cameraChase.lookAt(chassisPos.x, chassisPos.y + 1, chassisPos.z);
        } else {
            const offset = new THREE.Vector3(0, 0.8, 1.5);
            offset.applyQuaternion(q);
            offset.add(chassisPos);
            cameraCockpit.position.copy(offset);
            cameraCockpit.quaternion.copy(q);
            const rotation180 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI);
            cameraCockpit.quaternion.multiply(rotation180);
        }
    }

    function updateHUD(time) {
        if (!chassisBody) return;
        const v = chassisBody.velocity;
        const speed = v.length() * 3.6; // KM/H
        speedEl.textContent = speed.toFixed(0);
        altitudeEl.textContent = chassisBody.position.y.toFixed(0);
        
        const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(chassisBody.quaternion);
        const heading = Math.atan2(forward.x, forward.z) * 180 / Math.PI;
        let h = (heading + 360) % 360;
        headingEl.textContent = h.toFixed(0).padStart(3, '0');
        
        const rpm = Math.min(99, Math.floor(speed * 1.5));
        rpmEl.textContent = rpm;
        
        let throttlePercent = 0;
        if (engineForce !== 0) {
            throttlePercent = Math.abs((engineForce / (maxEngineForce * 2.5)) * 100);
            if (throttlePercent > 100) throttlePercent = 100;
        }
        throttleEl.textContent = throttlePercent.toFixed(0) + '%';

        // 不再有 reward 逻辑（已移除）
        updateDayNight(time); setHeadlights();
        // 同步金币 HUD
        coinCountEl.textContent = coinCount;
    }

    function updateDayNight(time) {
        const tSec = time / 1000;
        const cycle = tSec % cycleDurationSec; 
        const halfCycleSec = cycleDurationSec / 2; // 150 seconds

        let t = 0;
        let timeLabel = "DAY";
        let isNight = false;

        if (cycle < halfCycleSec) {
            t = cycle / halfCycleSec;
            isNight = t > 0.5;
            scene.background.lerpColors(daySkyColor, nightSkyColor, t);
            scene.fog.color.copy(scene.background);
            hemiLight.color.lerpColors(dayHemiSky, nightHemiSky, t);
            hemiLight.groundColor.lerpColors(dayHemiGround, nightHemiGround, t);
            dirLight.color.lerpColors(new THREE.Color(0xfff0dd), new THREE.Color(0x222233), t);
            dirLight.intensity = 1.0 * (1 - t) + 0.2 * t;
            hemiLight.intensity = 0.8 * (1 - t) + 0.2 * t;
            timeLabel = (t < 0.2) ? "DAY" : (t < 0.8) ? "TWILIGHT" : "NIGHT";
        } else {
            t = (cycle - halfCycleSec) / halfCycleSec;
            isNight = t < 0.5;
            scene.background.lerpColors(nightSkyColor, daySkyColor, t);
            scene.fog.color.copy(scene.background);
            hemiLight.color.lerpColors(nightHemiSky, dayHemiSky, t);
            hemiLight.groundColor.lerpColors(nightHemiGround, dayHemiGround, t);
            dirLight.color.lerpColors(new THREE.Color(0x222233), new THREE.Color(0xfff0dd), t);
            dirLight.intensity = 0.2 * (1 - t) + 1.0 * t;
            hemiLight.intensity = 0.2 * (1 - t) + 0.8 * t;
            timeLabel = (t < 0.2) ? "NIGHT" : (t < 0.8) ? "DAWN" : "DAY";
        }
        timeEl.textContent = timeLabel;
        
        scene.traverse((node) => {
            if (node.isMesh && node.userData.isStandardMaterial) {
                const intensity = isNight ? (1 - Math.abs(t - 0.5) * 2) * 2 : 0;
                node.material.emissiveIntensity = THREE.MathUtils.lerp(0.1, 1.0, intensity);
            }
            if (node.isMesh && node.userData.isEmissive) {
                node.visible = isNight;
            }
        });
    }

    function updateColliders() {
        if (!chassisBody) return;
        const chassisPos = new THREE.Vector3(chassisBody.position.x, chassisBody.position.y, chassisBody.position.z);
        staticBodies.forEach(obj => {
            const d = chassisPos.distanceTo(obj.center);
            if (!obj.added && d <= obj.radius + 120) {
                world.addBody(obj.body);
                obj.added = true;
            } else if (obj.added && d > obj.radius + 120) {
                world.removeBody(obj.body);
                obj.added = false;
            }
        });
    }

    // =============================================================================
    // ** Gold coin 生成与碰撞处理 **
    // =============================================================================
    function loadCoinPrototype(callback) {
        // 先读取持久化金币数（首页、HUD）
        const stored = localStorage.getItem('goldCoinCount');
        coinCount = stored ? parseInt(stored, 10) : 0;
        splashCoinCountEl.textContent = coinCount;
        coinCountEl.textContent = coinCount;

        // 加载 gold_coin.glb（与 car1.glb 同目录）
        const coinLoader = new THREE.GLTFLoader();
        coinLoader.load('gold_coin.glb', (gltf) => {
            coinProto = gltf.scene;
            // 保证原型不受场景矩阵影响
            coinProto.traverse(node => { if (node.isMesh) node.castShadow = true; });
            if (callback) callback();
        }, undefined, (err) => {
            console.warn('gold_coin.glb 加载失败，请确认文件存在于同一目录下。', err);
            if (callback) callback(); // 即使失败也继续（不阻塞游戏）
        });
    }

    function spawnCoinsWhenReady() {
        // 等待 chassisBody 已初始化再生成金币
        if (!chassisBody) {
            setTimeout(spawnCoinsWhenReady, 200);
            return;
        }
        // 先加载金币原型（如果未加载）
        if (!coinProto) {
            loadCoinPrototype(() => spawnCoins(Math.floor(Math.random()*(COIN_MAX-COIN_MIN+1))+COIN_MIN));
        } else {
            spawnCoins(Math.floor(Math.random()*(COIN_MAX-COIN_MIN+1))+COIN_MIN);
        }
    }

    function spawnCoins(num) {
        if (!coinProto) return; // 未加载原型则跳过
        for (let i = 0; i < num; i++) {
            // 随机位置：在城市范围附近随机分布
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * COIN_SPAWN_RADIUS;
            const x = Math.cos(angle) * radius + (Math.random()-0.5)*20; // 加入一点噪声
            const z = Math.sin(angle) * radius + (Math.random()-0.5)*20;
            const y = COIN_HEIGHT + (Math.random()*0.3 - 0.15);

            // 克隆 mesh
            const coinMesh = coinProto.clone(true);
            coinMesh.scale.set(1.0,1.0,1.0);
            coinMesh.position.set(x, y, z);
            coinMesh.rotation.y = Math.random()*Math.PI*2;
            scene.add(coinMesh);
            coinMeshes.push(coinMesh);

            // 对应的物理体（静态球体，collisionResponse=0，仅触发事件）
            const coinBody = new CANNON.Body({ mass: 0 });
            const radiusSphere = 0.4;
            coinBody.addShape(new CANNON.Sphere(radiusSphere));
            coinBody.position.set(x, y, z);
            coinBody.collisionResponse = 0; // 不产生物理作用，仅用来触发事件
            // 监听碰撞事件
            coinBody.addEventListener('collide', (e) => {
                // 检查是否与车辆发生碰撞（考虑到 wheel/车身接触可能使用 chassisBody）
                const other = e.body;
                const contact = e.contact;
                const hitByChassis = (other === chassisBody) || (contact && (contact.bi === chassisBody || contact.bj === chassisBody));
                if (hitByChassis) {
                    // 找到对应 mesh 与 body 在数组中的索引并移除
                    const bIdx = coinBodies.indexOf(coinBody);
                    if (bIdx !== -1) {
                        // 移除 mesh & body
                        const mesh = coinMeshes[bIdx];
                        if (mesh) scene.remove(mesh);
                        coinMeshes.splice(bIdx, 1);
                        coinBodies.splice(bIdx, 1);
                        try { world.removeBody(coinBody); } catch (err) {}
                        // 更新计数并持久化
                        coinCount += 1;
                        localStorage.setItem('goldCoinCount', coinCount);
                        coinCountEl.textContent = coinCount;
                    }
                }
            });
            coinBodies.push(coinBody);
            world.addBody(coinBody);
        }
    }

    // =============================================================================
    // ** 主循环 **
    // =============================================================================
    

function setHeadlights() {
    if (!headlightLeft || !headlightRight) return;
    const tSec = performance.now() / 1000;
    const cycle = tSec % cycleDurationSec;
    const isNight = cycle >= (cycleDurationSec / 2);
    // 强度调整到夜间
    headlightLeft.intensity = isNight ? 3.0 : 0.0;
    headlightRight.intensity = isNight ? 3.0 : 0.0;
}

function animate(time) {
        requestAnimationFrame(animate);
        if (!chassisBody || !world) return;
        const fixedTimeStep = 1/60;
        const maxSubSteps = 1;
        
        if (lastTime !== undefined) {
            const dt = (time - lastTime) / 1000;
            world.step(fixedTimeStep, dt, maxSubSteps);
        } else {
            world.step(fixedTimeStep);
        }
        lastTime = time;

        updateControls();
        
        // 模型同步
        for (let i = 0; i < vehicle.wheelInfos.length; i++) {
            vehicle.updateWheelTransform(i);
            const t = vehicle.wheelInfos[i].worldTransform;
            if (wheelMeshes[i]) {
                wheelMeshes[i].position.copy(t.position);
                wheelMeshes[i].quaternion.copy(t.quaternion);
            }
        }
        if (carMesh && chassisBody) {
            carMesh.position.copy(chassisBody.position);
            carMesh.quaternion.copy(chassisBody.quaternion);
        }

        // 同步金币 mesh 与 body（如果 body 有位置改变）
        for (let i = 0; i < coinMeshes.length; i++) {
            if (coinBodies[i]) {
                coinMeshes[i].position.copy(coinBodies[i].position);
                coinMeshes[i].quaternion.copy(coinBodies[i].quaternion);
                // 轻微自转视觉（保持可见性）
                coinMeshes[i].rotation.y += 0.02;
            }
        }

        updateCamera();
        updateHUD(time);
        updateColliders();

        renderer.render(scene, activeCamera);
    }

    // =============================================================================
    // ** 启动逻辑 **
    // =============================================================================
    function startGame() {
        // 首页显示的金币与 localStorage 同步
        const stored = localStorage.getItem('goldCoinCount');
        coinCount = stored ? parseInt(stored, 10) : 0;
        splashCoinCountEl.textContent = coinCount;
        coinCountEl.textContent = coinCount;

        document.getElementById('splash').style.opacity = '0';
        document.getElementById('loading-screen').style.display = 'flex';
        setTimeout(() => {
            document.getElementById('splash').style.display = 'none';
        }, 500);
        
        setupGame();
    }
    window.startGame = startGame;

    function setupGame() {
        initThree();
        initCannon();
        initGround();
        initCameraAndLights();
        initLoaders();
        loadCarModel();
        loadTireModel();
        loadCity();
        // 预加载金币原型（即使未在 city 完成也会尽快准备）
        loadCoinPrototype();
    }

    window.addEventListener('resize', () => {
        if (renderer && cameraChase && cameraCockpit) {
            renderer.setSize(window.innerWidth, window.innerHeight);
            const aspect = window.innerWidth / window.innerHeight;
            cameraChase.aspect = aspect;
            cameraChase.updateProjectionMatrix();
            cameraCockpit.aspect = aspect;
            cameraCockpit.updateProjectionMatrix();
        }
        if (splashRenderer && splashCamera) {
            const container = document.getElementById('splash-three-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            splashRenderer.setSize(width, height);
            splashCamera.aspect = width / height;
            splashCamera.updateProjectionMatrix();
        }
    });

    // 页面初始化：准备 Splash、加载器（点击 PLAY 触发 startGame）
    document.addEventListener('DOMContentLoaded', () => {
        // 页面加载时读取本地金币数并显示在首页
        const stored = localStorage.getItem('goldCoinCount');
        coinCount = stored ? parseInt(stored, 10) : 0;
        splashCoinCountEl.textContent = coinCount;
        coinCountEl.textContent = coinCount;

        initLoaders();
        initSplashThree();
        loadSplashCarModel();
    });
    </script>
</body>
</html>
