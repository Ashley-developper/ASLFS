<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ASL Car Simulator - Hyper Drive Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* =========================================================================
         * UI 基础与字体
         * ========================================================================= */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000000; 
            font-family: 'Rajdhani', sans-serif; 
            color: #E0FFFF;
            user-select: none; 
        }
        
        /* =========================================================================
         * HUD (游戏内界面)
         * ========================================================================= */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            padding: 30px; box-sizing: border-box; z-index: 10;
        }

        .hud-top-left { display: flex; gap: 20px; flex-wrap: wrap; }
        .hud-top-right { position: absolute; top: 30px; right: 30px; }
        
        .instrument {
            background: rgba(0, 15, 30, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-left: 5px solid #00FFFF;
            backdrop-filter: blur(10px);
            padding: 12px 22px;
            min-width: 120px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
            border-radius: 4px;
            clip-path: polygon(0 0, 100% 0, 100% 80%, 90% 100%, 0 100%);
        }
        
        .label {
            font-family: 'Orbitron', sans-serif; font-size: 10px; color: #00FFFF; 
            font-weight: 700; letter-spacing: 2px; margin-bottom: 3px; display:block; 
            text-transform: uppercase; text-shadow: 0 0 5px rgba(0, 255, 255, 0.8);
        }
        .value {
            font-family: 'Orbitron', sans-serif; font-size: 36px; font-weight: 900; 
            letter-spacing: -2px; line-height: 1; color: #FFFFFF;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }
        .unit { font-size: 14px; color: #888888; margin-left: 6px; font-weight: 400; }

        .spd-color { border-left-color: #00FFFF !important; }
        .rpm-color { border-left-color: #FF00FF !important; }
        .gear-color { border-left-color: #FFD700 !important; }
        .throttle-color { border-left-color: #00FF00 !important; }

        #hud-coin {
            background: rgba(35, 18, 0, 0.7);
            border: 1px solid rgba(255, 215, 0, 0.15);
            border-left: 5px solid #FFD700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.06);
            min-width: 140px; margin-bottom: 20px;
        }
        #hud-coin .label { color: #FFD700; }
        #coin-count { font-size: 40px; letter-spacing: 2px; color: #FFD700; }

        #control-hints {
            position: absolute; bottom: 30px; left: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: 5px solid #00FF00;
            backdrop-filter: blur(10px); padding: 18px 25px;
            color: #eee; font-size: 13px; border-radius: 4px;
            max-width: 250px; line-height: 1.8;
        }
        .respawn-hint { color: #FFD700; font-weight: bold; }
        .hint-title { color: #00FF00; font-family: 'Orbitron', sans-serif; font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid rgba(0, 255, 0, 0.3); padding-bottom: 5px; }
        .copyright-tag { position: fixed; bottom: 15px; right: 15px; font-size: 12px; color: rgba(255, 255, 255, 0.3); z-index: 10; }

        /* =========================================================================
         * Splash / Main Menu UI
         * ========================================================================= */
        #splash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0) 30%, rgba(0,0,0,0) 70%, rgba(0,0,0,0.8) 100%);
            z-index: 999;
            display: none; /* Initial hidden */
            cursor: grab;
        }
        #splash:active { cursor: grabbing; }

        /* 标题区 */
        .splash-header {
            position: absolute; top: 60px; left: 0; width: 100%;
            text-align: center; pointer-events: none;
        }
        h1 {
            font-family: 'Orbitron', sans-serif; font-size: 64px; margin: 0; font-weight: 900;
            letter-spacing: 12px; text-transform: uppercase;
            background: linear-gradient(to right, #00FFFF, #FFFFFF, #FF00FF);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }
        .splash-subtitle {
            font-family: 'Rajdhani', sans-serif; font-size: 20px; color: rgba(0, 255, 255, 0.8);
            letter-spacing: 6px; margin-top: 10px; font-weight: 600;
        }

        /* 右上角金币显示 */
        .splash-top-right {
            position: absolute; top: 40px; right: 40px;
            text-align: right; pointer-events: none;
        }
        .splash-top-right .label { font-size: 12px; color: #FFD700; text-shadow: 0 0 10px #FFD700; margin-bottom: 5px;}
        .splash-top-right .value { font-size: 42px; color: #FFD700; text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }

        /* 左侧菜单按钮 (SHOP, INFO) */
        .splash-left-menu {
            position: absolute; top: 50%; left: 40px;
            transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 20px;
        }
        .menu-btn {
            font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 700;
            color: rgba(255,255,255,0.7); background: rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2); border-left: 3px solid #888;
            padding: 12px 30px; letter-spacing: 3px; cursor: pointer;
            transition: 0.3s; width: 200px; text-align: left;
            clip-path: polygon(0 0, 100% 0, 95% 100%, 0 100%);
        }
        .menu-btn:hover {
            background: rgba(0, 255, 255, 0.2); color: #fff;
            border-left-color: #00FFFF; padding-left: 40px;
            box-shadow: 0 0 15px rgba(0,255,255,0.3);
        }

        /* 底部按钮区 */
        .splash-footer {
            position: absolute; bottom: 60px; right: 60px;
            display: flex; gap: 20px; align-items: flex-end;
            pointer-events: none; /* 容器穿透 */
        }
        
        /* 通用底部按钮样式 */
        .splash-footer button { pointer-events: auto; font-family: 'Orbitron', sans-serif; cursor: pointer; transition: 0.3s; }

        #start-button {
            padding: 20px 80px; font-size: 24px; font-weight: 900;
            color: #000000; background: #00FFFF; border: none;
            letter-spacing: 4px; box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
            clip-path: polygon(15% 0, 100% 0, 100% 70%, 85% 100%, 0 100%, 0 30%);
        }
        #start-button:hover {
            background: #FF00FF; box-shadow: 0 0 50px rgba(255, 0, 255, 0.8); color: #fff; transform: scale(1.05);
        }

        .secondary-btn {
            padding: 15px 40px; font-size: 16px; font-weight: 700;
            color: #00FFFF; background: rgba(0, 20, 40, 0.8);
            border: 1px solid #00FFFF; letter-spacing: 2px;
            clip-path: polygon(10% 0, 100% 0, 100% 100%, 0 100%, 0 20%);
        }
        .secondary-btn:hover {
            background: rgba(0, 255, 255, 0.2); box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        /* Loading Screen */
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #00FFFF; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.5s;
        }
        #loading-progress-bar { width: 400px; height: 5px; background: #222; margin-top: 20px; border-radius: 2px; overflow: hidden; }
        #loading-progress-fill { height: 100%; width: 0%; background: #00FFFF; box-shadow: 0 0 10px #00FFFF; }

    </style>
</head>
<body>

    <div id="loading-screen">
        <h2 style="margin:0; font-size:32px; color:white; font-family:'Orbitron';">SYSTEM INITIALIZING</h2>
        <p style="font-family:'Orbitron'; letter-spacing:2px;">LOADING ASSETS...</p>
        <div id="loading-progress-bar"><div id="loading-progress-fill"></div></div>
        <p id="loading-status" style="margin-top:10px; font-size:14px; font-family:'Rajdhani';">(0%)</p>
    </div>

    <div id="splash">
        <div class="splash-header">
            <h1>OPEN WORLD<br>HYPER DRIVE</h1>
            <p class="splash-subtitle">IMMERSIVE SIMULATION // ZHANYI ZHOU</p>
        </div>

        <div class="splash-top-right">
            <span class="label">TOTAL GOLD</span><br>
            <span class="value" id="splash-coin-count">0</span>
        </div>

        <div class="splash-left-menu">
            <button class="menu-btn">SHOP</button>
            <button class="menu-btn">INFORMATION</button>
        </div>

        <div class="splash-footer">
            <button class="secondary-btn">DELIVERY MODE</button>
            <button id="start-button" onclick="enterGame()">PLAY NOW</button>
        </div>
    </div>

    <div class="copyright-tag">ZHANYI ZHOU DESIGN © 2025</div>

    <div id="hud-layer" style="display:none;">
        <div class="hud-top-left">
            <div class="instrument spd-color">
                <span class="label">Speed</span> <span class="value" id="hud-spd">0</span> <span class="unit">KM/H</span>
            </div>
            <div class="instrument rpm-color">
                <span class="label">RPM</span> <span class="value" id="hud-rpm">0</span> <span class="unit">x100</span>
            </div>
            <div class="instrument gear-color">
                <span class="label">Gear</span> <span class="value" id="hud-gear">P</span> <span class="unit">MODE</span>
            </div>
            <div class="instrument throttle-color">
                <span class="label">Throttle</span> <span class="value" id="hud-throttle">0%</span>
            </div>
            <div class="instrument">
                <span class="label">Altitude</span> <span class="value" id="hud-alt">0</span> <span class="unit">M</span>
            </div>
            <div class="instrument">
                <span class="label">Heading</span> <span class="value" id="hud-hdg">000</span> <span class="unit">DEG</span>
            </div>
        </div>

        <div class="hud-top-right">
            <div class="instrument" id="hud-coin">
                <span class="label">GOLD COIN</span> <span class="value" id="coin-count">0</span>
            </div>
        </div>

        <div class="hud-bottom">
            <div id="control-hints">
                <div class="hint-title">SYSTEM CONTROLS</div>
                <div>[SHIFT] NITRO BOOST</div>
                <div>[SPACE] DRIFT / BRAKE</div>
                <div>[V] CHANGE CAMERA</div>
                <div class="respawn-hint">[R] RESPAWN CAR</div>
                <div>[WASD] DRIVE</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

    <script>
    // =============================================================================
    // ** 核心变量 **
    // =============================================================================
    let scene, renderer;
    let cameraChase, cameraCockpit, activeCamera;
    let world, vehicle, chassisBody;
    let wheelMeshes = [];
    let lastTime = undefined;

    let isGameRunning = false; 
    let splashCameraAngle = 0; 
    let isDragging = false;
    let previousMouseX = 0;

    const daySkyColor = new THREE.Color(0x87CEEB);
    const dayHemiSky = new THREE.Color(0xffffff);
    const dayHemiGround = new THREE.Color(0x3b4c5a);

    const maxEngineForce = 9000; 
    const brakeForce = 40;
    const maxSteerVal = 0.7;
    const VISUAL_Y_OFFSET = -0.9; 

    // ** 修复穿模核心：将初始高度提高到 2.0 (原为 0.6) **
    // 这样在Splash界面车子会悬空，点击Play后会掉下来
    const initialCarPosition = new CANNON.Vec3(90, 2.0, 0);

    let staticBodies = [];
    let carMesh = null;
    let tireMeshPrototype = null;
    let flameMesh = null;
    let gltfLoader = null;
    let dracoLoader = null;

    const inputState = { keyW: false, keyS: false, keyA: false, keyD: false, keySpace: false, keyShift: false, keyR: false };

    // UI Elements
    const speedEl = document.getElementById('hud-spd');
    const altitudeEl = document.getElementById('hud-alt');
    const headingEl = document.getElementById('hud-hdg');
    const rpmEl = document.getElementById('hud-rpm');
    const gearEl = document.getElementById('hud-gear');
    const throttleEl = document.getElementById('hud-throttle');
    const coinCountEl = document.getElementById('coin-count');
    const splashCoinCountEl = document.getElementById('splash-coin-count');

    let engineForce = 0;
    let steeringValue = 0;

    // Coin Vars
    let coinProto = null;
    let coinMeshes = [];
    let coinBodies = [];
    let coinCount = 0;
    const COIN_MIN = 50;
    const COIN_MAX = 80;
    const COIN_SPAWN_RADIUS = 800;
    const COIN_HEIGHT = 0.7;

    // =============================================================================
    // ** 交互：Splash 界面拖拽旋转 **
    // =============================================================================
    document.addEventListener('mousedown', (e) => {
        if (!isGameRunning) {
            isDragging = true;
            previousMouseX = e.clientX;
            document.body.style.cursor = 'grabbing';
            document.getElementById('splash').style.cursor = 'grabbing';
        }
    });

    document.addEventListener('mouseup', () => {
        isDragging = false;
        document.body.style.cursor = 'default';
        document.getElementById('splash').style.cursor = 'grab';
    });

    document.addEventListener('mousemove', (e) => {
        if (isDragging && !isGameRunning) {
            const deltaX = e.clientX - previousMouseX;
            splashCameraAngle -= deltaX * 0.005;
            previousMouseX = e.clientX;
        }
    });

    // =============================================================================
    // ** 加载器初始化 **
    // =============================================================================
    function initLoaders() {
        dracoLoader = new THREE.DRACOLoader();
        dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/');

        const loadingManager = new THREE.LoadingManager();
        const progressFill = document.getElementById('loading-progress-fill');
        const loadingStatus = document.getElementById('loading-status');
        
        loadingManager.onProgress = function(itemUrl, itemsLoaded, itemsTotal) {
            const percent = Math.floor((itemsLoaded / itemsTotal) * 100);
            progressFill.style.width = percent + '%';
            loadingStatus.innerText = `(${percent}%) Loading Assets...`;
        };
        
        loadingManager.onLoad = function() {
            const loadingScreen = document.getElementById('loading-screen');
            loadingScreen.style.opacity = '0';
            setTimeout(() => {
                loadingScreen.style.display = 'none';
                document.getElementById('splash').style.display = 'block'; 
            }, 500);

            initVehicle();
            spawnCoinsWhenReady();
            requestAnimationFrame(animate);
        };

        gltfLoader = new THREE.GLTFLoader(loadingManager);
        gltfLoader.setDRACOLoader(dracoLoader);
    }

    // =============================================================================
    // ** 游戏资源加载 **
    // =============================================================================
    function loadCarModel() {
        gltfLoader.load('car1.glb', (gltf) => {
            carMesh = gltf.scene;
            carMesh.scale.set(104.7, 104.7, 104.7);
            carMesh.rotation.y = Math.PI;
            carMesh.traverse((node) => { if (node.isMesh) node.castShadow = true; });
            scene.add(carMesh);

            const flameGeometry = new THREE.ConeGeometry(0.3, 1, 16);
            const flameMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.75 });
            flameMesh = new THREE.Mesh(flameGeometry, flameMaterial);
            flameMesh.rotation.x = -Math.PI / 2;
            flameMesh.position.set(0, 0, 2.5);
            flameMesh.visible = false;
            carMesh.add(flameMesh);
        });
    }

    function loadTireModel() {
        gltfLoader.load('tire1.glb', (gltf) => {
            tireMeshPrototype = gltf.scene;
            tireMeshPrototype.scale.set(0.75, 0.75, 0.75);
            tireMeshPrototype.rotation.x = Math.PI / 2;
            tireMeshPrototype.traverse((node) => { if (node.isMesh) node.castShadow = true; });
        });
    }

    function loadCity() {
        gltfLoader.load('city.glb', (gltf) => {
            const city = gltf.scene;
            city.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                    if (node.material) {
                        const mat = node.material.clone ? node.material.clone() : node.material;
                        if (mat.emissive !== undefined) {
                            mat.emissive = new THREE.Color(0x000000);
                            mat.emissiveIntensity = 0;
                        }
                        node.material = mat;
                    }
                }
            });
            city.scale.set(4,4,4);
            scene.add(city);

            city.updateMatrixWorld(true);
            city.traverse((node) => {
                if (node.isMesh) {
                    const geometry = node.geometry.clone();
                    geometry.applyMatrix4(node.matrixWorld);
                    geometry.computeBoundingSphere();
                    const vertices = Array.from(geometry.attributes.position.array);
                    let indices = [];
                    if (geometry.index) {
                        indices = Array.from(geometry.index.array);
                    } else {
                        for (let i = 0; i < vertices.length/3; i++) indices.push(i);
                    }
                    const shape = new CANNON.Trimesh(vertices, indices);
                    const body = new CANNON.Body({ mass: 0 });
                    body.addShape(shape);
                    staticBodies.push({
                        body: body,
                        center: new THREE.Vector3().copy(geometry.boundingSphere.center),
                        radius: geometry.boundingSphere.radius,
                        added: false
                    });
                }
            });
        });
    }

    // =============================================================================
    // ** THREE.js/Cannon.js 基础设置 **
    // =============================================================================
    function initThree() {
        scene = new THREE.Scene();
        scene.background = daySkyColor.clone();
        scene.fog = new THREE.Fog(daySkyColor, 500, 800);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
    }

    function initCannon() {
        world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.allowSleep = true;

        const defaultMaterial = new CANNON.Material('default');
        const contactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
            friction: 1.0, restitution: 0.0
        });
        world.defaultContactMaterial = contactMaterial;
        world.addContactMaterial(contactMaterial);
    }

    function initGround() {
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0 });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        const groundGeo = new THREE.PlaneGeometry(500, 500, 10, 10);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8, metalness: 0.2 });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.position.y = -0.05;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);
    }

    function initCameraAndLights() {
        cameraChase = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        cameraCockpit = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
        activeCamera = cameraChase;

        hemiLight = new THREE.HemisphereLight(dayHemiSky.clone(), dayHemiGround.clone(), 0.8);
        scene.add(hemiLight);

        dirLight = new THREE.DirectionalLight(0xfff0dd, 1.0);
        dirLight.position.set(50,100,50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 4096;
        dirLight.shadow.mapSize.height = 4096;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 500;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        scene.add(dirLight);
    }

    // =============================================================================
    // ** 车辆物理核心 **
    // =============================================================================
    function initVehicle() {
        const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.5, 2));
        chassisBody = new CANNON.Body({
            mass: 2500, 
            shape: chassisShape,
            position: initialCarPosition.clone()
        });
        chassisBody.angularDamping = 0.9; 
        chassisBody.linearDamping = 0.05;
        world.addBody(chassisBody);

        vehicle = new CANNON.RaycastVehicle({
            chassisBody: chassisBody,
            indexRightAxis: 0, indexUpAxis: 1, indexForwardAxis: 2
        });

        const axleWidth = 1.0;
        const wheelBase = 1.5;
        function makeWheelOptions(x,y,z) {
            return {
                radius: 0.5,
                directionLocal: new CANNON.Vec3(0, -1, 0),
                suspensionStiffness: 150, suspensionRestLength: 0.3,
                frictionSlip: 4.0, dampingRelaxation: 8.0, dampingCompression: 10.0,
                maxSuspensionForce: 100000, rollInfluence: 0.05, maxSuspensionTravel: 0.3,
                customSlidingRotationalSpeed: -30, useCustomSlidingRotationalSpeed: true,
                axleLocal: new CANNON.Vec3(1, 0, 0),
                chassisConnectionPointLocal: new CANNON.Vec3(x, -0.3, z)
            };
        }

        vehicle.addWheel(makeWheelOptions(-axleWidth, 0, wheelBase));
        vehicle.addWheel(makeWheelOptions( axleWidth, 0, wheelBase));
        vehicle.addWheel(makeWheelOptions(-axleWidth, 0, -wheelBase));
        vehicle.addWheel(makeWheelOptions( axleWidth, 0, -wheelBase));

        vehicle.addToWorld(world);

        wheelMeshes = [];
        if (tireMeshPrototype) {
            for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                const wheelMesh = tireMeshPrototype.clone();
                if(i===0 || i===2) wheelMesh.rotation.y = Math.PI; 
                wheelMeshes.push(wheelMesh);
                scene.add(wheelMesh);
            }
        } else {
            const wheelMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
            for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                const wheel = vehicle.wheelInfos[i];
                const cylinderGeometry = new THREE.CylinderGeometry(wheel.radius, wheel.radius, 0.2, 32);
                cylinderGeometry.rotateZ(Math.PI / 2);
                const wheelMesh = new THREE.Mesh(cylinderGeometry, wheelMat);
                wheelMeshes.push(wheelMesh);
                scene.add(wheelMesh);
            }
        }
    }

    function respawnCar() {
        if (!chassisBody) return;
        chassisBody.position.copy(initialCarPosition);
        chassisBody.quaternion.set(0, 0, 0, 1);
        chassisBody.velocity.set(0, 0, 0);
        chassisBody.angularVelocity.set(0, 0, 0);
        vehicle.applyEngineForce(0, 0); vehicle.applyEngineForce(0, 1); 
        vehicle.applyEngineForce(0, 2); vehicle.applyEngineForce(0, 3); 
        vehicle.setSteeringValue(0, 0); vehicle.setSteeringValue(0, 1);
        vehicle.setBrake(0, 0); vehicle.setBrake(0, 1); vehicle.setBrake(0, 2); vehicle.setBrake(0, 3);
        gearEl.textContent = 'P';
    }

    // =============================================================================
    // ** 控制与更新 **
    // =============================================================================
    window.addEventListener('keydown', (event) => {
        if (!isGameRunning) return;
        const k = event.key.toLowerCase();
        if(k==='w') inputState.keyW = true;
        if(k==='s') inputState.keyS = true;
        if(k==='a') inputState.keyA = true;
        if(k==='d') inputState.keyD = true;
        if(k===' ') { inputState.keySpace = true; event.preventDefault(); }
        if(k==='shift') inputState.keyShift = true;
        if(k==='v') toggleCamera();
        if(k==='r') { inputState.keyR = true; respawnCar(); }
    });
    window.addEventListener('keyup', (event) => {
        const k = event.key.toLowerCase();
        if(k==='w') inputState.keyW = false;
        if(k==='s') inputState.keyS = false;
        if(k==='a') inputState.keyA = false;
        if(k==='d') inputState.keyD = false;
        if(k===' ') inputState.keySpace = false;
        if(k==='shift') inputState.keyShift = false;
        if(k==='r') inputState.keyR = false;
    });

    function toggleCamera() {
        activeCamera = (activeCamera === cameraChase) ? cameraCockpit : cameraChase;
    }

    function updateControls() {
        if (!chassisBody || !isGameRunning) return;
        if (inputState.keyW || inputState.keyS || inputState.keyA || inputState.keyD) {
            if (chassisBody.sleepState === CANNON.Body.SLEEPING) chassisBody.wakeUp(); 
        }
        engineForce = 0; steeringValue = 0; let brake = 0;

        const v = chassisBody.velocity;
        const chassisQuaternion = new THREE.Quaternion(chassisBody.quaternion.x, chassisBody.quaternion.y, chassisBody.quaternion.z, chassisBody.quaternion.w);
        const forwardVector = new THREE.Vector3(0, 0, 1).applyQuaternion(chassisQuaternion);
        const velocityVector = new THREE.Vector3(v.x, v.y, v.z);
        const isMovingForward = velocityVector.dot(forwardVector) > 0.5;
        const isMovingBackward = velocityVector.dot(forwardVector) < -0.5;

        if (inputState.keyA) steeringValue = maxSteerVal;
        else if (inputState.keyD) steeringValue = -maxSteerVal;

        if (inputState.keyW) {
            if (isMovingBackward) brake = maxEngineForce * 0.5;
            else { engineForce = -maxEngineForce; gearEl.textContent = 'D'; }
        } else if (inputState.keyS) {
            if (isMovingForward) brake = maxEngineForce * 0.5;
            else { engineForce = maxEngineForce * 0.5; gearEl.textContent = 'R'; }
        } else if (!inputState.keySpace) {
            gearEl.textContent = (v.length()*3.6 < 1) ? 'P' : 'N';
        }

        if (inputState.keyShift && engineForce !== 0) {
            engineForce *= 2.5;
            if (flameMesh) flameMesh.visible = true;
        } else {
            if (flameMesh) flameMesh.visible = false;
        }

        vehicle.setSteeringValue(steeringValue, 0); vehicle.setSteeringValue(steeringValue, 1);
        vehicle.applyEngineForce(engineForce, 0); vehicle.applyEngineForce(engineForce, 1); 
        vehicle.applyEngineForce(engineForce, 2); vehicle.applyEngineForce(engineForce, 3); 

        let finalBrakeRL = brake, finalBrakeRR = brake;
        if (inputState.keySpace) {
            finalBrakeRL = maxEngineForce * 0.8; finalBrakeRR = maxEngineForce * 0.8;
            gearEl.textContent = 'E';
        } else if (brake === 0) {
            vehicle.setBrake(0, 0); vehicle.setBrake(0, 1); vehicle.setBrake(0, 2); vehicle.setBrake(0, 3);
        }
        vehicle.setBrake(brake, 0); vehicle.setBrake(brake, 1);
        vehicle.setBrake(finalBrakeRL, 2); vehicle.setBrake(finalBrakeRR, 3);
    }

    function updateCamera() {
        if (!chassisBody) return;
        const chassisPos = new THREE.Vector3().copy(chassisBody.position);
        
        if (isGameRunning) {
            const q = chassisBody.quaternion;
            if (activeCamera === cameraChase) {
                const idealOffset = new THREE.Vector3(0, 3, -7);
                idealOffset.applyQuaternion(q);
                idealOffset.add(chassisPos);
                if(idealOffset.y < chassisPos.y + 0.5) idealOffset.y = chassisPos.y + 0.5;
                cameraChase.position.lerp(idealOffset, 0.1);
                cameraChase.lookAt(chassisPos.x, chassisPos.y + 1, chassisPos.z);
            } else {
                const offset = new THREE.Vector3(0, 0.8, 1.5);
                offset.applyQuaternion(q);
                offset.add(chassisPos);
                cameraCockpit.position.copy(offset);
                cameraCockpit.quaternion.copy(q);
                const rotation180 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI);
                cameraCockpit.quaternion.multiply(rotation180);
            }
        } 
        else {
            if (!isDragging) {
                splashCameraAngle += 0.002; 
            }
            const radius = 6.0;
            const height = 2.0;
            const x = chassisPos.x + Math.sin(splashCameraAngle) * radius;
            const z = chassisPos.z + Math.cos(splashCameraAngle) * radius;
            
            cameraChase.position.set(x, chassisPos.y + height, z);
            cameraChase.lookAt(chassisPos.x, chassisPos.y, chassisPos.z);
        }
    }

    function updateHUD(time) {
        if (!chassisBody) return;
        const v = chassisBody.velocity;
        speedEl.textContent = (v.length() * 3.6).toFixed(0);
        altitudeEl.textContent = chassisBody.position.y.toFixed(0);
        
        const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(chassisBody.quaternion);
        const heading = Math.atan2(forward.x, forward.z) * 180 / Math.PI;
        headingEl.textContent = ((heading + 360) % 360).toFixed(0).padStart(3, '0');
        
        rpmEl.textContent = Math.min(99, Math.floor(v.length() * 3.6 * 1.5));
        
        let throttlePercent = 0;
        if (engineForce !== 0) throttlePercent = Math.abs((engineForce / (maxEngineForce * 2.5)) * 100);
        throttleEl.textContent = Math.min(100, throttlePercent).toFixed(0) + '%';

        coinCountEl.textContent = coinCount;
    }

    function updateColliders() {
        if (!chassisBody) return;
        const chassisPos = new THREE.Vector3(chassisBody.position.x, chassisBody.position.y, chassisBody.position.z);
        staticBodies.forEach(obj => {
            const d = chassisPos.distanceTo(obj.center);
            if (!obj.added && d <= obj.radius + 120) {
                world.addBody(obj.body);
                obj.added = true;
            } else if (obj.added && d > obj.radius + 120) {
                world.removeBody(obj.body);
                obj.added = false;
            }
        });
    }

    // =============================================================================
    // ** Gold Coin Logic **
    // =============================================================================
    function loadCoinPrototype(callback) {
        const stored = localStorage.getItem('goldCoinCount');
        coinCount = stored ? parseInt(stored, 10) : 0;
        splashCoinCountEl.textContent = coinCount;
        coinCountEl.textContent = coinCount;

        const coinLoader = new THREE.GLTFLoader();
        coinLoader.load('gold_coin.glb', (gltf) => {
            coinProto = gltf.scene;
            coinProto.traverse(node => { if (node.isMesh) node.castShadow = true; });
            if (callback) callback();
        }, undefined, (err) => {
            console.warn('gold_coin.glb load failed', err);
            if (callback) callback();
        });
    }

    function spawnCoinsWhenReady() {
        if (!chassisBody) {
            setTimeout(spawnCoinsWhenReady, 200);
            return;
        }
        if (!coinProto) {
            loadCoinPrototype(() => spawnCoins(Math.floor(Math.random()*(COIN_MAX-COIN_MIN+1))+COIN_MIN));
        } else {
            spawnCoins(Math.floor(Math.random()*(COIN_MAX-COIN_MIN+1))+COIN_MIN);
        }
    }

    function spawnCoins(num) {
        if (!coinProto) return;
        for (let i = 0; i < num; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * COIN_SPAWN_RADIUS;
            const x = Math.cos(angle) * radius + (Math.random()-0.5)*20;
            const z = Math.sin(angle) * radius + (Math.random()-0.5)*20;
            const y = COIN_HEIGHT + (Math.random()*0.3 - 0.15);

            const coinMesh = coinProto.clone(true);
            coinMesh.scale.set(1.0,1.0,1.0);
            coinMesh.position.set(x, y, z);
            coinMesh.rotation.y = Math.random()*Math.PI*2;
            scene.add(coinMesh);
            coinMeshes.push(coinMesh);

            const coinBody = new CANNON.Body({ mass: 0 });
            coinBody.addShape(new CANNON.Sphere(0.4));
            coinBody.position.set(x, y, z);
            coinBody.collisionResponse = 0;
            coinBody.addEventListener('collide', (e) => {
                const hitByChassis = (e.body === chassisBody) || (e.contact && (e.contact.bi === chassisBody || e.contact.bj === chassisBody));
                if (hitByChassis) {
                    const bIdx = coinBodies.indexOf(coinBody);
                    if (bIdx !== -1) {
                        const mesh = coinMeshes[bIdx];
                        if (mesh) scene.remove(mesh);
                        coinMeshes.splice(bIdx, 1);
                        coinBodies.splice(bIdx, 1);
                        try { world.removeBody(coinBody); } catch (err) {}
                        coinCount += 1;
                        localStorage.setItem('goldCoinCount', coinCount);
                        coinCountEl.textContent = coinCount;
                    }
                }
            });
            coinBodies.push(coinBody);
            world.addBody(coinBody);
        }
    }

    // =============================================================================
    // ** 主循环 **
    // =============================================================================
    function animate(time) {
        requestAnimationFrame(animate);
        if (!chassisBody || !world) return;
        
        if (isGameRunning) {
            const fixedTimeStep = 1/60;
            const maxSubSteps = 1;
            if (lastTime !== undefined) {
                const dt = (time - lastTime) / 1000;
                world.step(fixedTimeStep, dt, maxSubSteps);
            } else {
                world.step(fixedTimeStep);
            }
            lastTime = time;
            updateControls();
            updateColliders();
        }

        // 模型位置同步
        for (let i = 0; i < vehicle.wheelInfos.length; i++) {
            vehicle.updateWheelTransform(i);
            const t = vehicle.wheelInfos[i].worldTransform;
            if (wheelMeshes[i]) {
                wheelMeshes[i].position.copy(t.position);
                wheelMeshes[i].quaternion.copy(t.quaternion);
            }
        }
        if (carMesh && chassisBody) {
            carMesh.position.copy(chassisBody.position);
            carMesh.quaternion.copy(chassisBody.quaternion);
            carMesh.position.y += VISUAL_Y_OFFSET; 
        }

        for (let i = 0; i < coinMeshes.length; i++) {
            if (coinBodies[i]) {
                coinMeshes[i].position.copy(coinBodies[i].position);
                coinMeshes[i].quaternion.copy(coinBodies[i].quaternion);
                coinMeshes[i].rotation.y += 0.02;
            }
        }

        updateCamera();
        if (isGameRunning) updateHUD(time);

        renderer.render(scene, activeCamera);
    }

    // =============================================================================
    // ** 启动逻辑 **
    // =============================================================================
    
    function initSystem() {
        const stored = localStorage.getItem('goldCoinCount');
        coinCount = stored ? parseInt(stored, 10) : 0;
        splashCoinCountEl.textContent = coinCount;

        initThree();
        initCannon();
        initGround();
        initCameraAndLights();
        initLoaders();
        loadCarModel();
        loadTireModel();
        loadCity();
        loadCoinPrototype();
    }

    function enterGame() {
        document.getElementById('splash').style.opacity = '0';
        setTimeout(() => {
            document.getElementById('splash').style.display = 'none';
            document.getElementById('hud-layer').style.display = 'flex';
        }, 500);
        
        isGameRunning = true; 
    }
    window.enterGame = enterGame;

    window.addEventListener('resize', () => {
        if (renderer && cameraChase && cameraCockpit) {
            renderer.setSize(window.innerWidth, window.innerHeight);
            const aspect = window.innerWidth / window.innerHeight;
            cameraChase.aspect = aspect;
            cameraChase.updateProjectionMatrix();
            cameraCockpit.aspect = aspect;
            cameraCockpit.updateProjectionMatrix();
        }
    });

    document.addEventListener('DOMContentLoaded', initSystem);

    </script>
</body>
</html>
