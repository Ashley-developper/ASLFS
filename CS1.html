<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASL Car Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; user-select: none; }
        
        /* ‰ª™Ë°®ÁõòÂ∏ÉÂ±Ä */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            padding: 25px; box-sizing: border-box; z-index: 10;
        }

        .hud-top-left { display: flex; gap: 20px; flex-wrap: wrap; }
        
        .instrument {
            background: rgba(10, 20, 30, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-left: 4px solid #00aaff;
            backdrop-filter: blur(8px);
            padding: 10px 18px;
            color: #eee;
            min-width: 100px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            border-radius: 4px;
        }
        
        .label {
            font-size: 10px; color: #88ccff; font-weight: 600; letter-spacing: 1px;
            margin-bottom: 4px; display:block; text-transform: uppercase;
        }
        
        .value {
            font-size: 26px; font-weight: 700; font-family: 'Consolas', monospace; letter-spacing: -1px;
        }
        
        .unit {
            font-size: 12px; color: #888; margin-left: 4px; font-weight: 400;
        }

        /* ÊéßÂà∂ÊèêÁ§∫ */
        #control-hints {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 20, 30, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-left: 4px solid #00ff00;
            backdrop-filter: blur(8px);
            padding: 15px 20px;
            color: #eee;
            font-size: 12px;
            border-radius: 4px;
            max-width: 200px;
            line-height: 1.6;
        }

        .hint-title {
            color: #00ff00;
            font-weight: bold;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        /* ÂêØÂä®ÁîªÈù¢ (Splash Screen) */
        #splash {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0093E9 0%, #80D0C7 100%);
            z-index: 999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        
        #splash-three-container {
            width: 300px;
            height: 150px;
            margin-bottom: 20px;
            position: relative;
        }

        h1 {
            font-size: 32px;
            margin: 0;
            font-weight: 400;
            letter-spacing: 5px;
            text-transform: uppercase;
            color: #fff;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

        #plane-chooser-title {
            font-size: 20px;
            margin-bottom: 20px;
            font-weight: 600;
            color: #f0f0f0;
            letter-spacing: 3px;
        }

        #plane-info-display {
            text-align: center;
            margin-top: 15px;
            padding: 15px 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            min-width: 450px;
        }

        .plane-title {
            font-size: 18px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 10px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px 20px;
            font-size: 13px;
            color: #c0e0f0;
        }

        .stat-value {
            font-family: 'Consolas', monospace;
            font-weight: bold;
            color: #80D0C7;
            margin-left: 5px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: auto auto;
            gap: 10px 20px;
            margin-top: 20px;
            text-align: left;
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            font-size: 14px;
        }

        .key-box {
            font-family: 'Consolas', monospace;
            color: #80D0C7;
            font-weight: bold;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div id="splash">
        <div id="splash-three-container"></div>
        <h1>ASL CAR SIMULATOR</h1>
        <p style="opacity:0.8; margin-top:15px;">Press Start to Play</p>
        <button id="start-button" onclick="startGame()">START DRIVING</button>
    </div>

    <div id="hud-layer" style="display:none;">
        <div class="hud-top-left">
            <div class="instrument">
                <span class="label">Speed</span>
                <span class="value" id="hud-spd">0</span> <span class="unit">KM/H</span>
            </div>
            <div class="instrument">
                <span class="label">Altitude</span>
                <span class="value" id="hud-alt">0</span> <span class="unit">M</span>
            </div>
            <div class="instrument">
                <span class="label">Heading</span>
                <span class="value" id="hud-hdg">000</span> <span class="unit">DEG</span>
            </div>
            <div class="instrument" style="border-left-color: #ffcc00;">
                <span class="label" style="color:#ffcc00">RPM</span>
                <span class="value" id="hud-rpm">0</span> <span class="unit">x100</span>
            </div>
            <div class="instrument" style="border-left-color: #ff9900;">
                <span class="label" style="color:#ff9900">Gear</span>
                <span class="value" id="hud-gear">P</span> <span class="unit">MODE</span>
            </div>
            <div class="instrument" style="border-left-color: #ff6699;">
                <span class="label" style="color:#ff6699">Steer</span>
                <span class="value" id="hud-steer">0¬∞</span> <span class="unit">ANGLE</span>
            </div>
        </div>

        <div class="hud-bottom">
            <div id="control-hints">
                <div class="hint-title">üí° Tips</div>
                <div>Press Shift for Boost</div>
                <div>SPACE for handbrake drift</div>
                <div>V to switch camera</div>
            </div>
            <div class="hud-bottom-right">
                <div class="instrument" style="border-left-color: #00ff00;">
                    <span class="label" style="color:#00ff00">Throttle</span>
                    <span class="value" id="hud-throttle">0%</span>
                </div>
            </div>
        </div>
    </div>

    <div id="loading-screen" style="display:none; flex-direction:column; align-items:center; justify-content:center; position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8); color:#fff; z-index:1000;">
        <p>Loading City and Assets...</p>
        <div id="loading-progress-bar" style="width:300px; height:10px; background:#333; margin-top:10px;">
            <div id="loading-progress-fill" style="height:100%; width:0%; background:#00aaff;"></div>
        </div>
        <p id="loading-status" style="margin-top:10px; font-size:14px;">(0%)</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

    <script>
    // =============================================================================
    // ** ‰∏ªÊ∏∏Êàè 3D Âú∫ÊôØÂèòÈáè **
    // =============================================================================
    let scene, renderer;
    let cameraChase, cameraCockpit, activeCamera;
    let world, vehicle, chassisBody;
    let wheelMeshes = [];
    let lastTime = undefined;

    // ** ÁéØÂ¢ÉÂÖâ/Êó•Â§úÂàáÊç¢ÂèòÈáè **
    let hemiLight, dirLight;
    const daySkyColor = new THREE.Color(0x87CEEB);
    const nightSkyColor = new THREE.Color(0x000022);
    const dayHemiSky = new THREE.Color(0xffffff);
    const nightHemiSky = new THREE.Color(0x111133);
    const dayHemiGround = new THREE.Color(0x3b4c5a);
    const nightHemiGround = new THREE.Color(0x04040a);

    // ** ÂÖ≥ÈîÆÁöÑÁä∂ÊÄÅÂèòÈáè **
    let staticBodies = [];
    let carMesh = null;
    let tireMeshPrototype = null;
    let flameMesh = null;
    let gltfLoader = null;
    let dracoLoader = null;

    const inputState = {
      keyW: false,
      keyS: false,
      keyA: false,
      keyD: false,
      keySpace: false,
      keyShift: false
    };

    // ÂºïÊìéÂíåËΩ¨ÂêëÂèÇÊï∞
    const maxEngineForce = 12000;
    const brakeForce = 40;
    const maxSteerVal = 0.7;

    // ‰ª™Ë°®ÁõòÂÖÉÁ¥†
    const speedEl = document.getElementById('hud-spd');
    const altitudeEl = document.getElementById('hud-alt');
    const headingEl = document.getElementById('hud-hdg');
    const rpmEl = document.getElementById('hud-rpm');
    const gearEl = document.getElementById('hud-gear');
    const steerEl = document.getElementById('hud-steer');
    const throttleEl = document.getElementById('hud-throttle');

    let engineForce = 0;
    let steeringValue = 0;

    // =============================================================================
    // ** THREE.js/GLTF Loader ÂàùÂßãÂåñ **
    // =============================================================================
    function initLoaders() {
        dracoLoader = new THREE.DRACOLoader();
        dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/');

        // ‰ΩøÁî® LoadingManager ËøõË°åÁªü‰∏ÄÂä†ËΩΩÁÆ°ÁêÜ
        const loadingManager = new THREE.LoadingManager();
        const progressFill = document.getElementById('loading-progress-fill');
        const loadingStatus = document.getElementById('loading-status');
        loadingManager.onProgress = function(itemUrl, itemsLoaded, itemsTotal) {
            const percent = Math.floor((itemsLoaded / itemsTotal) * 100);
            progressFill.style.width = percent + '%';
            loadingStatus.innerText = `(${percent}%) Loading Assets...`;
        };
        loadingManager.onLoad = function() {
            // ÊâÄÊúâËµÑÊ∫êÂä†ËΩΩÂÆåÊàêÔºåÂêØÂä®Ê∏∏Êàè
            cancelAnimationFrame(splashAnimationId);
            document.getElementById('loading-screen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('hud-layer').style.display = 'flex';
            }, 500);
            initVehicle();
            requestAnimationFrame(animate);
        };

        gltfLoader = new THREE.GLTFLoader(loadingManager);
        gltfLoader.setDRACOLoader(dracoLoader);
    }

    // =============================================================================
    // ** ÂêØÂä®ÁîªÈù¢ 3D Âú∫ÊôØÈÄªËæë **
    // =============================================================================
    let splashScene, splashCamera, splashRenderer, splashAnimationId, splashCarModel;
    function initSplashThree() {
        const container = document.getElementById('splash-three-container');
        const width = container.clientWidth;
        const height = container.clientHeight;

        splashScene = new THREE.Scene();
        splashCamera = new THREE.PerspectiveCamera(60, width/height, 0.1, 1000);
        splashRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        splashRenderer.setSize(width, height);
        splashRenderer.setClearColor(0x000000, 0);
        container.appendChild(splashRenderer.domElement);

        // Ê∑ªÂä†ÊóãËΩ¨ÁöÑÊ±ΩËΩ¶Ê®°Âûã
        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        splashScene.add(ambient);
        const dir = new THREE.DirectionalLight(0xffffff, 0.6);
        dir.position.set(5,10,7.5);
        splashScene.add(dir);

        splashCamera.position.set(0, 1, 3);
        splashCamera.lookAt(0, 0.5, 0);

        // ÊóãËΩ¨Âä®Áîª
        function animateSplash() {
            splashAnimationId = requestAnimationFrame(animateSplash);
            if (splashCarModel) {
                splashCarModel.rotation.y += 0.01;
            }
            splashRenderer.render(splashScene, splashCamera);
        }
        animateSplash();
    }

    function loadSplashCarModel() {
        if (!gltfLoader) return;
        gltfLoader.load('car1.glb', (gltf) => {
            splashCarModel = gltf.scene;
            splashCarModel.scale.set(1.7,1.7,1.7);
            splashCarModel.position.set(0,-0.5,0);
            splashScene.add(splashCarModel);
        });
    }

    // =============================================================================
    // ** Ê∏∏ÊàèËµÑÊ∫êÂä†ËΩΩ **
    // =============================================================================
    function loadCarModel() {
        gltfLoader.load('car1.glb', (gltf) => {
            carMesh = gltf.scene;
            carMesh.scale.set(1.7, 1.7, 1.7);
            carMesh.rotation.y = Math.PI;
            carMesh.position.y = -0.5;
            carMesh.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                }
            });
            scene.add(carMesh);

            // Ê∑ªÂä†Â∞æÈÉ®ÁÅ´ÁÑ∞ÁâπÊïà
            const flameGeometry = new THREE.ConeGeometry(0.3, 1, 16);
            const flameMaterial = new THREE.MeshBasicMaterial({ color: 0xff4500 });
            flameMesh = new THREE.Mesh(flameGeometry, flameMaterial);
            flameMesh.rotation.x = -Math.PI / 2; // ÁÅ´ÁÑ∞ÊúùÂêé
            flameMesh.position.set(0, 0, 2.5); // Âú®ËΩ¶Â∞æÂêéÊñπ
            flameMesh.visible = false;
            carMesh.add(flameMesh);
        });
    }

    function loadTireModel() {
        gltfLoader.load('tire1.glb', (gltf) => {
            tireMeshPrototype = gltf.scene;
            tireMeshPrototype.scale.set(0.75, 0.75, 0.75);
            tireMeshPrototype.rotation.x = Math.PI / 2;
            tireMeshPrototype.traverse((node) => {
                if (node.isMesh) node.castShadow = true;
            });
        });
    }

    function loadCity() {
        gltfLoader.load('city.glb', (gltf) => {
            const city = gltf.scene;
            city.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });
            city.scale.set(4,4,4);
            scene.add(city);

            // Â∞ÜcityÊ®°ÂûãËΩ¨Êç¢‰∏∫Cannon TrimeshÁî®‰∫éÁ≤æÁ°ÆÁ¢∞Êíû
            city.updateMatrixWorld(true);
            city.traverse((node) => {
                if (node.isMesh) {
                    const geometry = node.geometry.clone();
                    geometry.applyMatrix4(node.matrixWorld);
                    geometry.computeBoundingSphere();
                    const vertices = Array.from(geometry.attributes.position.array);
                    let indices = [];
                    if (geometry.index) {
                        indices = Array.from(geometry.index.array);
                    } else {
                        for (let i = 0; i < vertices.length/3; i++) indices.push(i);
                    }
                    const shape = new CANNON.Trimesh(vertices, indices);
                    const body = new CANNON.Body({ mass: 0 });
                    body.addShape(shape);
                    staticBodies.push({
                        body: body,
                        center: new THREE.Vector3().copy(geometry.boundingSphere.center),
                        radius: geometry.boundingSphere.radius,
                        added: false
                    });
                }
            });
        });
    }

    // =============================================================================
    // ** THREE.js/Cannon.js Âü∫Á°ÄËÆæÁΩÆ **
    // =============================================================================
    function initThree() {
        scene = new THREE.Scene();
        scene.background = daySkyColor.clone();

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap;
        document.body.appendChild(renderer.domElement);
    }

    function initCannon() {
        world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.allowSleep = true;

        const defaultMaterial = new CANNON.Material('default');
        const contactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
            friction: 0.6,
            restitution: 0.0
        });
        world.defaultContactMaterial = contactMaterial;
        world.addContactMaterial(contactMaterial);
    }

    function initGround() {
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({
            mass: 0,
            material: world.defaultContactMaterial.material
        });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        const groundGeo = new THREE.PlaneGeometry(500, 500, 10, 10);
        const groundMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.position.y = -0.05;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);
    }

    function initCameraAndLights() {
        cameraChase = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        cameraCockpit = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
        activeCamera = cameraChase;

        hemiLight = new THREE.HemisphereLight(dayHemiSky.clone(), dayHemiGround.clone(), 0.8);
        scene.add(hemiLight);

        dirLight = new THREE.DirectionalLight(0xfff0dd, 1.0);
        dirLight.position.set(50,100,50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 4096;
        dirLight.shadow.mapSize.height = 4096;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 500;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        scene.add(dirLight);
    }

    // ‚úÖ ‰øÆÂ§çËΩ¨ÂêëÈóÆÈ¢òÁöÑÂÖ≥ÈîÆÔºöË∞ÉÊï¥ËΩÆÂ≠êÁâ©ÁêÜÂèÇÊï∞
    function initVehicle() {
        const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.5, 2));
        chassisBody = new CANNON.Body({
            mass: 1500,
            shape: chassisShape,
            // ‚¨áÔ∏è ‰øÆÊîπ: Â∞ÜÂ∫ïÁõò‰ΩçÁΩÆ‰ªé 1.0 Èôç‰ΩéÂà∞ 0.6ÔºåÂÆûÁé∞Â∫ïÁõòÈôç‰Ωé
            position: new CANNON.Vec3(90, 0.6, 0)
        });
        chassisBody.angularDamping = 0.3;
        chassisBody.linearDamping = 0.05;
        world.addBody(chassisBody);

        vehicle = new CANNON.RaycastVehicle({
            chassisBody: chassisBody,
            indexRightAxis: 0,
            indexUpAxis: 1,
            indexForwardAxis: 2
        });

        const axleWidth = 1.0;
        const wheelBase = 1.5;
        function makeWheelOptions(x,y,z) {
            return {
                radius: 0.5,
                directionLocal: new CANNON.Vec3(0, -1, 0),
                suspensionStiffness: 50,
                suspensionRestLength: 0.3,
                frictionSlip: 1.5,
                dampingRelaxation: 1.5,
                dampingCompression: 2.5,
                maxSuspensionForce: 100000,
                rollInfluence: 0.3,
                maxSuspensionTravel: 0.3,
                customSlidingRotationalSpeed: -30,
                useCustomSlidingRotationalSpeed: true,
                axleLocal: new CANNON.Vec3(1, 0, 0),
                chassisConnectionPointLocal: new CANNON.Vec3(x, y, z)
            };
        }

        vehicle.addWheel(makeWheelOptions(-axleWidth, 0, wheelBase)); // 0: FL
        vehicle.addWheel(makeWheelOptions( axleWidth, 0, wheelBase)); // 1: FR
        vehicle.addWheel(makeWheelOptions(-axleWidth, 0, -wheelBase)); // 2: RL
        vehicle.addWheel(makeWheelOptions( axleWidth, 0, -wheelBase)); // 3: RR

        vehicle.addToWorld(world);

        wheelMeshes = [];
        if (tireMeshPrototype) {
            for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                const wheelMesh = tireMeshPrototype.clone();
                wheelMeshes.push(wheelMesh);
                scene.add(wheelMesh);
            }
        } else {
            console.warn("Tire model not loaded, using fallback cylinder.");
            const wheelMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
            for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                const wheel = vehicle.wheelInfos[i];
                const cylinderGeometry = new THREE.CylinderGeometry(wheel.radius, wheel.radius, 0.2, 32);
                cylinderGeometry.rotateZ(Math.PI / 2);
                const wheelMesh = new THREE.Mesh(cylinderGeometry, wheelMat);
                wheelMeshes.push(wheelMesh);
                scene.add(wheelMesh);
            }
        }
    }

    // =============================================================================
    // ** Ê∏∏ÊàèÊéßÂà∂ ‰∏é HUD Êõ¥Êñ∞ **
    // =============================================================================
    window.addEventListener('keydown', (event) => {
        switch(event.key.toLowerCase()) {
            case 'w': inputState.keyW = true; break;
            case 's': inputState.keyS = true; break;
            case 'a': inputState.keyA = true; break;
            case 'd': inputState.keyD = true; break;
            case ' ': inputState.keySpace = true; event.preventDefault(); break;
            case 'shift': inputState.keyShift = true; break;
            case 'v': toggleCamera(); break;
        }
    });
    window.addEventListener('keyup', (event) => {
        switch(event.key.toLowerCase()) {
            case 'w': inputState.keyW = false; break;
            case 's': inputState.keyS = false; break;
            case 'a': inputState.keyA = false; break;
            case 'd': inputState.keyD = false; break;
            case ' ': inputState.keySpace = false; break;
            case 'shift': inputState.keyShift = false; break;
        }
    });
    function toggleCamera() {
        if (activeCamera === cameraChase) {
            activeCamera = cameraCockpit;
        } else {
            activeCamera = cameraChase;
        }
    }

    function updateControls() {
        if (!chassisBody) return;
        engineForce = 0;
        steeringValue = 0;
        let brake = 0;

        const v = chassisBody.velocity;
        const currentSpeed = v.length() * 3.6;
        const chassisQuaternion = new THREE.Quaternion(chassisBody.quaternion.x, chassisBody.quaternion.y, chassisBody.quaternion.z, chassisBody.quaternion.w);
        const forwardVector = new THREE.Vector3(0, 0, 1).applyQuaternion(chassisQuaternion);
        const velocityVector = new THREE.Vector3(v.x, v.y, v.z);
        const isMovingForward = velocityVector.dot(forwardVector) > 0.5;
        const isMovingBackward = velocityVector.dot(forwardVector) < -0.5;

        // ËΩ¨Âêë
        if (inputState.keyA) {
            steeringValue = maxSteerVal;
        } else if (inputState.keyD) {
            steeringValue = -maxSteerVal;
        } else {
            steeringValue = 0;
        }

        // Âä†ÈÄü / ÂÄíËΩ¶
        if (inputState.keyW) {
            if (isMovingBackward) {
                brake = maxEngineForce * 0.5;
            } else {
                engineForce = -maxEngineForce;
                gearEl.textContent = 'D';
            }
        } else if (inputState.keyS) {
            if (isMovingForward) {
                brake = maxEngineForce * 0.5;
            } else {
                engineForce = maxEngineForce * 0.5;
                gearEl.textContent = 'R';
            }
        } else if (!inputState.keySpace) {
            if (currentSpeed < 1) {
                gearEl.textContent = 'P';
            } else {
                gearEl.textContent = 'N';
            }
        }

        // ËΩ¨ÂêëÂÄºÂ∫îÁî®
        vehicle.setSteeringValue(steeringValue, 0);
        vehicle.setSteeringValue(steeringValue, 1);

        // È©±Âä®
        // ‚¨áÔ∏è ‰øÆÊîπ: Â∞ÜÊé®ÂäõÂ∫îÁî®Âà∞ÊâÄÊúâÂõõ‰∏™ËΩÆÂ≠ê (0, 1, 2, 3) ÂÆûÁé∞ÂõõÈ©±
        vehicle.applyEngineForce(engineForce, 0); // FL
        vehicle.applyEngineForce(engineForce, 1); // FR
        vehicle.applyEngineForce(engineForce, 2); // RL
        vehicle.applyEngineForce(engineForce, 3); // RR

        // ÂàπËΩ¶
        let finalBrakeFL = brake, finalBrakeFR = brake, finalBrakeRL = brake, finalBrakeRR = brake;
        if (inputState.keySpace) {
            const handbrakeStrength = maxEngineForce * 0.8;
            finalBrakeRL = handbrakeStrength;
            finalBrakeRR = handbrakeStrength;
            gearEl.textContent = 'E';
        }
        vehicle.setBrake(finalBrakeFL, 0);
        vehicle.setBrake(finalBrakeFR, 1);
        vehicle.setBrake(finalBrakeRL, 2);
        vehicle.setBrake(finalBrakeRR, 3);

        if (finalBrakeFL === 0 && finalBrakeRL === 0 && !inputState.keySpace) {
            vehicle.setBrake(0, 0);
            vehicle.setBrake(0, 1);
            vehicle.setBrake(0, 2);
            vehicle.setBrake(0, 3);
        }

        // Â¢ûÂº∫ÂäüËÉΩÔºöShift ÈîÆÂä†ÈÄü
        if (inputState.keyShift && engineForce !== 0) {
            engineForce *= 3;
            if (flameMesh) flameMesh.visible = true;
        } else {
            if (flameMesh) flameMesh.visible = false;
        }
    }

    function updateCamera() {
        if (!chassisBody) return;
        const chassisPos = new THREE.Vector3().copy(chassisBody.position);
        const q = chassisBody.quaternion;
        if (activeCamera === cameraChase) {
            const offset = new THREE.Vector3(0, 3, -7);
            offset.applyQuaternion(q);
            offset.add(chassisPos);
            cameraChase.position.lerp(offset, 0.1);
            cameraChase.lookAt(chassisPos.x, chassisPos.y + 1, chassisPos.z);
        } else {
            const offset = new THREE.Vector3(0, 0.8, 1.5);
            offset.applyQuaternion(q);
            offset.add(chassisPos);
            cameraCockpit.position.copy(offset);
            cameraCockpit.quaternion.copy(q);
            const rotation180 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI);
            cameraCockpit.quaternion.multiply(rotation180);
        }
    }

    function updateWheelMeshes() {
        for (let i = 0; i < vehicle.wheelInfos.length; i++) {
            vehicle.updateWheelTransform(i);
            const t = vehicle.wheelInfos[i].worldTransform;
            if (wheelMeshes[i]) {
                wheelMeshes[i].position.copy(t.position);
                wheelMeshes[i].quaternion.copy(t.quaternion);
            }
        }
    }

    function updateCarMesh() {
        if (chassisBody && carMesh) {
            carMesh.position.copy(chassisBody.position);
            carMesh.quaternion.copy(chassisBody.quaternion);
        }
    }

    function updateHUD() {
        if (!chassisBody) return;
        const v = chassisBody.velocity;
        const speed = v.length() * 3.6;
        speedEl.textContent = speed.toFixed(0);
        altitudeEl.textContent = chassisBody.position.y.toFixed(0);
        const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(chassisBody.quaternion);
        const heading = Math.atan2(forward.x, forward.z) * 180 / Math.PI;
        let h = (heading + 360) % 360;
        headingEl.textContent = h.toFixed(0).padStart(3, '0');
        const rpm = Math.min(75, Math.floor(speed * 2.0));
        rpmEl.textContent = rpm;
        const steerDegrees = (steeringValue / maxSteerVal * 30).toFixed(0);
        steerEl.textContent = steerDegrees + '¬∞';
        let throttlePercent = 0;
        if (engineForce !== 0) {
            throttlePercent = Math.abs((engineForce / maxEngineForce) * 100).toFixed(0);
        }
        throttleEl.textContent = throttlePercent + '%';
    }

    function updateDayNight(time) {
        const tSec = time / 1000;
        const cycle = tSec % 240;
        let t = 0;
        if (cycle < 120) {
            t = cycle / 120;
            scene.background.lerpColors(daySkyColor, nightSkyColor, t);
            hemiLight.color.lerpColors(dayHemiSky, nightHemiSky, t);
            hemiLight.groundColor.lerpColors(dayHemiGround, nightHemiGround, t);
            dirLight.color.lerpColors(new THREE.Color(0xfff0dd), new THREE.Color(0x222233), t);
            dirLight.intensity = 1.0 * (1 - t) + 0.2 * t;
            hemiLight.intensity = 0.8 * (1 - t) + 0.2 * t;
        } else {
            t = (cycle - 120) / 120;
            scene.background.lerpColors(nightSkyColor, daySkyColor, t);
            hemiLight.color.lerpColors(nightHemiSky, dayHemiSky, t);
            hemiLight.groundColor.lerpColors(nightHemiGround, dayHemiGround, t);
            dirLight.color.lerpColors(new THREE.Color(0x222233), new THREE.Color(0xfff0dd), t);
            dirLight.intensity = 0.2 * (1 - t) + 1.0 * t;
            hemiLight.intensity = 0.4 * (1 - t) + 0.8 * t;
        }
    }

    function updateColliders() {
        if (!chassisBody) return;
        const chassisPos = new THREE.Vector3(chassisBody.position.x, chassisBody.position.y, chassisBody.position.z);
        staticBodies.forEach(obj => {
            const d = chassisPos.distanceTo(obj.center);
            if (!obj.added && d <= obj.radius + 3) {
                world.addBody(obj.body);
                obj.added = true;
            } else if (obj.added && d > obj.radius + 3) {
                world.removeBody(obj.body);
                obj.added = false;
            }
        });
    }

    function animate(time) {
        requestAnimationFrame(animate);
        if (!chassisBody || !world) return;
        const fixedTimeStep = 1/60;
        const maxSubSteps = 1;
        if (lastTime !== undefined) {
            const dt = (time - lastTime) / 1000;
            world.step(fixedTimeStep, dt, maxSubSteps);
        } else {
            world.step(fixedTimeStep);
        }
        lastTime = time;

        updateControls();
        updateWheelMeshes();
        updateCarMesh();
        updateCamera();
        updateHUD();
        updateDayNight(time);
        updateColliders();

        renderer.render(scene, activeCamera);
    }

    // =============================================================================
    // ** ÂêØÂä®ÈÄªËæë **
    // =============================================================================
    function startGame() {
        document.getElementById('splash').style.display = 'none';
        document.getElementById('loading-screen').style.display = 'flex';
        setupGame();
    }
    window.startGame = startGame;

    function setupGame() {
        initThree();
        initCannon();
        initGround();
        initCameraAndLights();
        initLoaders();
        loadCarModel();
        loadTireModel();
        loadCity();
    }

    window.addEventListener('resize', () => {
        if (renderer && cameraChase && cameraCockpit) {
            renderer.setSize(window.innerWidth, window.innerHeight);
            const aspect = window.innerWidth / window.innerHeight;
            cameraChase.aspect = aspect;
            cameraChase.updateProjectionMatrix();
            cameraCockpit.aspect = aspect;
            cameraCockpit.updateProjectionMatrix();
        }
        if (splashRenderer && splashCamera) {
            const container = document.getElementById('splash-three-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            splashRenderer.setSize(width, height);
            splashCamera.aspect = width / height;
            splashCamera.updateProjectionMatrix();
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        initLoaders();
        initSplashThree();
        loadSplashCarModel();
    });
    </script>
</body>
</html>
