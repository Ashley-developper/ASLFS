<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASL Car Simulator - Hyper Drive Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* =========================================================================
         * UI 基础与字体
         * ========================================================================= */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000000; 
            font-family: 'Rajdhani', sans-serif; 
            color: #E0FFFF;
            user-select: none; 
        }
        
        /* =========================================================================
         * HUD 整体布局
         * ========================================================================= */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            padding: 30px; box-sizing: border-box; z-index: 10;
        }

        .hud-top-left { 
            display: flex; 
            gap: 20px; 
            flex-wrap: wrap; 
        }

        .hud-top-right {
            position: absolute;
            top: 30px;
            right: 30px;
        }
        
        /* 仪表盘核心样式 - 赛博朋克霓虹风 */
        .instrument {
            background: rgba(0, 15, 30, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-left: 5px solid #00FFFF; /* 默认霓虹蓝 */
            backdrop-filter: blur(10px);
            padding: 12px 22px;
            min-width: 120px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
            border-radius: 4px;
            transition: all 0.2s ease;
            clip-path: polygon(0 0, 100% 0, 100% 80%, 90% 100%, 0 100%); /* 切角设计 */
        }
        
        .instrument:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.4);
        }

        /* 标签 */
        .label {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px; 
            color: #00FFFF; 
            font-weight: 700; 
            letter-spacing: 2px;
            margin-bottom: 3px; 
            display:block; 
            text-transform: uppercase; 
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.8);
        }
        
        /* 值 */
        .value {
            font-family: 'Orbitron', sans-serif;
            font-size: 36px; 
            font-weight: 900; 
            letter-spacing: -2px;
            line-height: 1;
            color: #FFFFFF;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }
        
        .unit {
            font-size: 14px; 
            color: #888888; 
            margin-left: 6px; 
            font-weight: 400;
        }

        /* 特殊颜色 */
        .spd-color { border-left-color: #00FFFF !important; }
        .rpm-color { border-left-color: #FF00FF !important; }
        .gear-color { border-left-color: #FFD700 !important; }
        .throttle-color { border-left-color: #00FF00 !important; }
        
        /* 奖励仪表盘样式 */
        #hud-reward {
            background: rgba(30, 0, 30, 0.7);
            border: 1px solid rgba(255, 0, 255, 0.2);
            border-left: 5px solid #FF00FF;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.1);
            min-width: 150px;
            margin-bottom: 20px;
        }
        
        #hud-reward .label {
            color: #FF00FF;
            text-shadow: 0 0 5px rgba(255, 0, 255, 0.8);
        }
        
        #reward-level {
            font-size: 40px; 
            letter-spacing: 2px;
            color: #FFD700;
        }

        /* =========================================================================
         * 底部控制提示与版权
         * ========================================================================= */
        #control-hints {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: 5px solid #00FF00;
            backdrop-filter: blur(10px);
            padding: 18px 25px;
            color: #eee;
            font-size: 13px;
            border-radius: 4px;
            max-width: 250px;
            line-height: 1.8;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.1);
        }
        
        /* 新增的重生提示的特殊样式 */
        .respawn-hint {
            color: #FFD700;
            font-weight: bold;
        }

        .hint-title {
            color: #00FF00;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
            font-size: 11px;
            border-bottom: 1px solid rgba(0, 255, 0, 0.3);
            padding-bottom: 5px;
            letter-spacing: 2px;
        }
        
        /* 版权标识 */
        .copyright-tag {
            position: fixed;
            bottom: 15px;
            right: 15px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.3);
            letter-spacing: 1px;
            z-index: 10;
        }

        /* =========================================================================
         * 启动画面样式
         * ========================================================================= */
        #splash {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #000000 0%, #0a0a1a 100%);
            z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white;
            opacity: 1;
            transition: opacity 0.5s;
        }
        
        #splash-three-container {
            width: 300px; height: 150px; margin-bottom: 20px; position: relative;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 48px;
            margin: 0;
            font-weight: 900;
            letter-spacing: 10px;
            text-transform: uppercase;
            background: linear-gradient(to right, #00FFFF, #FF00FF);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }

        #start-button {
            margin-top: 40px;
            padding: 15px 60px;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: bold;
            color: #000000;
            background: #00FFFF;
            border: none;
            cursor: pointer;
            transition: 0.3s;
            letter-spacing: 3px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
            clip-path: polygon(0 0, 100% 0, 90% 100%, 10% 100%);
        }

        #start-button:hover {
            background: #FF00FF;
            box-shadow: 0 0 40px rgba(255, 0, 255, 1);
            color: #fff;
        }
        
        .splash-subtitle {
            font-family: 'Rajdhani', sans-serif;
            font-size: 18px;
            color: rgba(0, 255, 255, 0.7);
            letter-spacing: 4px;
        }

        /* 加载界面 */
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #00FFFF; z-index: 1000;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            opacity: 0; transition: opacity 0.5s;
        }
        #loading-screen p { font-family: 'Orbitron', sans-serif; }
        #loading-progress-bar { width: 400px; height: 5px; background: #222; margin-top: 10px; border-radius: 2px; overflow: hidden; }
        #loading-progress-fill { height: 100%; width: 0%; background: #00FFFF; box-shadow: 0 0 10px #00FFFF; }

    </style>
</head>
<body>
    <div id="splash">
        <div id="splash-three-container"></div>
        <h1>HYPER DRIVE</h1>
        <p class="splash-subtitle">MADE BY ZHANYI ZHOU</p>
        <button id="start-button" onclick="startGame()">PLAY NOW</button>
    </div>

    <div class="copyright-tag">ZHANYI ZHOU DESIGN © 2025</div>

    <div id="hud-layer" style="display:none;">
        <div class="hud-top-left">
            <div class="instrument spd-color">
                <span class="label">Speed</span>
                <span class="value" id="hud-spd">0</span> <span class="unit">KM/H</span>
            </div>
            <div class="instrument rpm-color">
                <span class="label">RPM</span>
                <span class="value" id="hud-rpm">0</span> <span class="unit">x100</span>
            </div>
            <div class="instrument gear-color">
                <span class="label">Gear</span>
                <span class="value" id="hud-gear">P</span> <span class="unit">MODE</span>
            </div>
            <div class="instrument throttle-color">
                <span class="label">Throttle</span>
                <span class="value" id="hud-throttle">0%</span>
            </div>
            <div class="instrument">
                <span class="label">Altitude</span>
                <span class="value" id="hud-alt">0</span> <span class="unit">M</span>
            </div>
            <div class="instrument">
                <span class="label">Heading</span>
                <span class="value" id="hud-hdg">000</span> <span class="unit">DEG</span>
            </div>
            <div class="instrument">
                <span class="label">Time</span>
                <span class="value" id="hud-time">DAY</span>
            </div>
        </div>

        <div class="hud-top-right">
            <div class="instrument" id="hud-reward">
                <span class="label">DRIVE REWARD</span>
                <span class="value" id="reward-level">LEVEL 1</span>
                <div style="font-size: 12px; color: #aaa; margin-top: 5px;">
                    <span id="distance-value">0.0</span> <span class="unit" style="margin: 0;">KM</span>
                </div>
            </div>
        </div>

        <div class="hud-bottom">
            <div id="control-hints">
                <div class="hint-title">SYSTEM CONTROLS</div>
                <div>[SHIFT] NITRO BOOST (MAX TORQUE)</div>
                <div>[SPACE] HANDBRAKE DRIFT</div>
                <div>[V] TOGGLE CAMERA</div>
                <div class="respawn-hint">[R] RESPAWN CAR (RESETS VELOCITY)</div>
                <div>[WASD] DRIVE</div>
            </div>
        </div>
    </div>

    <div id="loading-screen">
        <p>LOADING CITY AND ASSETS...</p>
        <div id="loading-progress-bar">
            <div id="loading-progress-fill"></div>
        </div>
        <p id="loading-status" style="margin-top:10px; font-size:14px;">(0%)</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

    <script>
    // =============================================================================
    // ** 核心变量 **
    // =============================================================================
    let scene, renderer;
    let cameraChase, cameraCockpit, activeCamera;
    let world, vehicle, chassisBody;
    let wheelMeshes = [];
    let lastTime = undefined;

    // ** 环境光/日夜切换变量 **
    let hemiLight, dirLight;
    // NOTE: 城市自发光将在材质加载时设置，这里只修改光源和背景
    const daySkyColor = new THREE.Color(0x87CEEB);
    const nightSkyColor = new THREE.Color(0x050510);
    const dayHemiSky = new THREE.Color(0xffffff);
    const nightHemiSky = new THREE.Color(0x111133);
    const dayHemiGround = new THREE.Color(0x3b4c5a);
    const nightHemiGround = new THREE.Color(0x04040a);

    // ** 物理调整参数 (根据用户要求修改) **
    const maxEngineForce = 9000; 
    const brakeForce = 40; // 未使用，但保留
    const maxSteerVal = 0.7;

    // ** 日夜循环时间 (根据用户要求修改) **
    const cycleDurationSec = 300; // FIX: 5 分钟 = 300 秒

    // ** 车辆初始位置 **
    const initialCarPosition = new CANNON.Vec3(90, 0.6, 0);

    // ** 奖励机制变量 **
    let totalDistanceKM = 0;
    let lastCarPosition = null;
    const rewardLevels = [
        { level: "LEVEL 1", distance: 0 },
        { level: "LEVEL 2", distance: 1.0 }, // 1.0 km
        { level: "LEVEL 3", distance: 5.0 }  // 5.0 km
    ];
    let currentRewardLevel = rewardLevels[0];

    // 状态和加载器
    let staticBodies = [];
    let carMesh = null;
    let tireMeshPrototype = null;
    let flameMesh = null;
    let gltfLoader = null;
    let dracoLoader = null;

    const inputState = { keyW: false, keyS: false, keyA: false, keyD: false, keySpace: false, keyShift: false, keyR: false };

    // 仪表盘元素
    const speedEl = document.getElementById('hud-spd');
    const altitudeEl = document.getElementById('hud-alt');
    const headingEl = document.getElementById('hud-hdg');
    const rpmEl = document.getElementById('hud-rpm');
    const gearEl = document.getElementById('hud-gear');
    const throttleEl = document.getElementById('hud-throttle');
    const timeEl = document.getElementById('hud-time');
    const rewardLevelEl = document.getElementById('reward-level');
    const distanceValueEl = document.getElementById('distance-value');

    let engineForce = 0;
    let steeringValue = 0;

    // =============================================================================
    // ** 加载器初始化 **
    // =============================================================================
    function initLoaders() {
        dracoLoader = new THREE.DRACOLoader();
        dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/');

        const loadingManager = new THREE.LoadingManager();
        const progressFill = document.getElementById('loading-progress-fill');
        const loadingStatus = document.getElementById('loading-status');
        
        loadingManager.onProgress = function(itemUrl, itemsLoaded, itemsTotal) {
            const percent = Math.floor((itemsLoaded / itemsTotal) * 100);
            progressFill.style.width = percent + '%';
            loadingStatus.innerText = `(${percent}%) Loading ${itemsLoaded}/${itemsTotal}`;
        };
        
        loadingManager.onLoad = function() {
            cancelAnimationFrame(splashAnimationId);
            document.getElementById('loading-screen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('hud-layer').style.display = 'flex';
            }, 500);
            initVehicle();
            lastCarPosition = new THREE.Vector3().copy(chassisBody.position); // 初始化距离计算
            requestAnimationFrame(animate);
        };

        gltfLoader = new THREE.GLTFLoader(loadingManager);
        gltfLoader.setDRACOLoader(dracoLoader);
    }

    // =============================================================================
    // ** 启动画面 3D 逻辑 **
    // =============================================================================
    let splashScene, splashCamera, splashRenderer, splashAnimationId, splashCarModel;
    function initSplashThree() {
        const container = document.getElementById('splash-three-container');
        const width = container.clientWidth;
        const height = container.clientHeight;

        splashScene = new THREE.Scene();
        splashCamera = new THREE.PerspectiveCamera(60, width/height, 0.1, 1000);
        splashRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        splashRenderer.setSize(width, height);
        splashRenderer.setClearColor(0x000000, 0);
        container.appendChild(splashRenderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        splashScene.add(ambient);
        const dir = new THREE.DirectionalLight(0x00FFFF, 1.5);
        dir.position.set(5,10,7.5);
        splashScene.add(dir);

        splashCamera.position.set(0, 1, 3);
        splashCamera.lookAt(0, 0.5, 0);

        function animateSplash() {
            splashAnimationId = requestAnimationFrame(animateSplash);
            if (splashCarModel) {
                splashCarModel.rotation.y += 0.01;
            }
            splashRenderer.render(splashScene, splashCamera);
        }
        animateSplash();
    }

    function loadSplashCarModel() {
        if (!gltfLoader) return;
        // 使用一个简单的加载器来避免与主游戏加载管理器冲突
        const simpleLoader = new THREE.GLTFLoader();
        simpleLoader.setDRACOLoader(dracoLoader);
        simpleLoader.load('car1.glb', (gltf) => {
            splashCarModel = gltf.scene;
            splashCarModel.scale.set(1.7,1.7,1.7);
            splashCarModel.position.set(0,-0.5,0);
            splashScene.add(splashCarModel);
        });
    }
    
    // =============================================================================
    // ** 游戏资源加载 **
    // =============================================================================
    function loadCarModel() {
        gltfLoader.load('car1.glb', (gltf) => {
            carMesh = gltf.scene;
            carMesh.scale.set(1.7, 1.7, 1.7);
            carMesh.rotation.y = Math.PI;
            carMesh.position.y = -0.5;
            carMesh.traverse((node) => { if (node.isMesh) node.castShadow = true; });
            scene.add(carMesh);

            const flameGeometry = new THREE.ConeGeometry(0.3, 1, 16);
            const flameMaterial = new THREE.MeshBasicMaterial({ color: 0x00FFFF, transparent: true, opacity: 0.8 });
            flameMesh = new THREE.Mesh(flameGeometry, flameMaterial);
            flameMesh.rotation.x = -Math.PI / 2;
            flameMesh.position.set(0, 0, 2.5);
            flameMesh.visible = false;
            carMesh.add(flameMesh);
        });
    }

    function loadTireModel() {
        gltfLoader.load('tire1.glb', (gltf) => {
            tireMeshPrototype = gltf.scene;
            tireMeshPrototype.scale.set(0.75, 0.75, 0.75);
            tireMeshPrototype.rotation.x = Math.PI / 2;
            tireMeshPrototype.traverse((node) => { if (node.isMesh) node.castShadow = true; });
        });
    }

    function loadCity() {
        gltfLoader.load('city.glb', (gltf) => {
            const city = gltf.scene;
            city.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;

                    // ** 城市自发光逻辑 **
                    if (node.name.includes('Emissive')) { // 假设所有需要发光的材质或网格名称中包含 'Emissive'
                        node.material = new THREE.MeshBasicMaterial({ color: 0x00FFFF, fog: false }); // 使用 MeshBasicMaterial 实现纯色自发光
                        node.userData.isEmissive = true;
                    }
                    else if(node.material) {
                        // 克隆材质以避免共享，并启用夜晚自发光效果
                        const originalMaterial = node.material;
                        const emsMaterial = originalMaterial.clone();
                        emsMaterial.emissive = new THREE.Color(0x0a0a1a); // 默认低发光
                        emsMaterial.emissiveIntensity = 0.5;
                        node.material = emsMaterial;
                        node.userData.isStandardMaterial = true;
                    }
                }
            });
            city.scale.set(4,4,4);
            scene.add(city);

            city.updateMatrixWorld(true);
            city.traverse((node) => {
                if (node.isMesh) {
                    const geometry = node.geometry.clone();
                    geometry.applyMatrix4(node.matrixWorld);
                    geometry.computeBoundingSphere();
                    const vertices = Array.from(geometry.attributes.position.array);
                    let indices = [];
                    if (geometry.index) {
                        indices = Array.from(geometry.index.array);
                    } else {
                        for (let i = 0; i < vertices.length/3; i++) indices.push(i);
                    }
                    const shape = new CANNON.Trimesh(vertices, indices);
                    const body = new CANNON.Body({ mass: 0 });
                    body.addShape(shape);
                    staticBodies.push({
                        body: body,
                        center: new THREE.Vector3().copy(geometry.boundingSphere.center),
                        radius: geometry.boundingSphere.radius,
                        added: false
                    });
                }
            });
        });
    }

    // =============================================================================
    // ** THREE.js/Cannon.js 基础设置 **
    // =============================================================================
    function initThree() {
        scene = new THREE.Scene();
        scene.background = daySkyColor.clone();
        scene.fog = new THREE.Fog(daySkyColor, 500, 800);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
    }

    function initCannon() {
        world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.allowSleep = true;

        const defaultMaterial = new CANNON.Material('default');
        const contactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
            friction: 1.0, 
            restitution: 0.0
        });
        world.defaultContactMaterial = contactMaterial;
        world.addContactMaterial(contactMaterial);
    }

    function initGround() {
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0 });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        const groundGeo = new THREE.PlaneGeometry(500, 500, 10, 10);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8, metalness: 0.2 });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.position.y = -0.05;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);
    }

    function initCameraAndLights() {
        cameraChase = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        cameraCockpit = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
        activeCamera = cameraChase;

        hemiLight = new THREE.HemisphereLight(dayHemiSky.clone(), dayHemiGround.clone(), 0.8);
        scene.add(hemiLight);

        dirLight = new THREE.DirectionalLight(0xfff0dd, 1.0);
        dirLight.position.set(50,100,50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 4096;
        dirLight.shadow.mapSize.height = 4096;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 500;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        scene.add(dirLight);
    }

    // =============================================================================
    // ** 车辆物理核心 (已修复和调优) **
    // =============================================================================
    function initVehicle() {
        const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.5, 2));
        chassisBody = new CANNON.Body({
            mass: 2500, 
            shape: chassisShape,
            position: initialCarPosition.clone() // 使用初始位置
        });
        chassisBody.angularDamping = 0.9; 
        chassisBody.linearDamping = 0.05;
        world.addBody(chassisBody);

        vehicle = new CANNON.RaycastVehicle({
            chassisBody: chassisBody,
            indexRightAxis: 0,
            indexUpAxis: 1,
            indexForwardAxis: 2
        });

        const axleWidth = 1.0;
        const wheelBase = 1.5;
        function makeWheelOptions(x,y,z) {
            return {
                radius: 0.5,
                directionLocal: new CANNON.Vec3(0, -1, 0),
                suspensionStiffness: 150,
                suspensionRestLength: 0.3,
                frictionSlip: 4.0, 
                dampingRelaxation: 8.0,
                dampingCompression: 10.0,
                maxSuspensionForce: 100000,
                rollInfluence: 0.05, 
                maxSuspensionTravel: 0.3,
                customSlidingRotationalSpeed: -30,
                useCustomSlidingRotationalSpeed: true,
                axleLocal: new CANNON.Vec3(1, 0, 0),
                chassisConnectionPointLocal: new CANNON.Vec3(x, y, z)
            };
        }

        vehicle.addWheel(makeWheelOptions(-axleWidth, 0, wheelBase)); // 0: FL
        vehicle.addWheel(makeWheelOptions( axleWidth, 0, wheelBase)); // 1: FR
        vehicle.addWheel(makeWheelOptions(-axleWidth, 0, -wheelBase)); // 2: RL
        vehicle.addWheel(makeWheelOptions( axleWidth, 0, -wheelBase)); // 3: RR

        vehicle.addToWorld(world);

        wheelMeshes = [];
        if (tireMeshPrototype) {
            for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                const wheelMesh = tireMeshPrototype.clone();
                if(i===0 || i===2) wheelMesh.rotation.y = Math.PI; 
                wheelMeshes.push(wheelMesh);
                scene.add(wheelMesh);
            }
        } else {
            const wheelMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
            for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                const wheel = vehicle.wheelInfos[i];
                const cylinderGeometry = new THREE.CylinderGeometry(wheel.radius, wheel.radius, 0.2, 32);
                cylinderGeometry.rotateZ(Math.PI / 2);
                const wheelMesh = new THREE.Mesh(cylinderGeometry, wheelMat);
                wheelMeshes.push(wheelMesh);
                scene.add(wheelMesh);
            }
        }
    }

    /**
     * 将车辆重置到初始位置和状态
     */
    function respawnCar() {
        if (!chassisBody) return;
        
        // 1. 重置物理位置和速度
        chassisBody.position.copy(initialCarPosition);
        chassisBody.quaternion.set(0, 0, 0, 1);
        chassisBody.velocity.set(0, 0, 0);
        chassisBody.angularVelocity.set(0, 0, 0);

        // 2. 重置车辆状态
        vehicle.applyEngineForce(0, 0); 
        vehicle.applyEngineForce(0, 1); 
        vehicle.applyEngineForce(0, 2); 
        vehicle.applyEngineForce(0, 3); 
        vehicle.setSteeringValue(0, 0);
        vehicle.setSteeringValue(0, 1);
        vehicle.setBrake(0, 0);
        vehicle.setBrake(0, 1);
        vehicle.setBrake(0, 2);
        vehicle.setBrake(0, 3);

        // 3. 更新距离计算起点
        lastCarPosition = new THREE.Vector3().copy(chassisBody.position);
        
        // 4. 强制更新一次 HUD (显示'P'档)
        gearEl.textContent = 'P';
        
        console.log("Car Respawned to initial position.");
    }

    // =============================================================================
    // ** 游戏控制 与 逻辑更新 **
    // =============================================================================
    window.addEventListener('keydown', (event) => {
        const k = event.key.toLowerCase();
        if(k==='w') inputState.keyW = true;
        if(k==='s') inputState.keyS = true;
        if(k==='a') inputState.keyA = true;
        if(k==='d') inputState.keyD = true;
        if(k===' ') { inputState.keySpace = true; event.preventDefault(); }
        if(k==='shift') inputState.keyShift = true;
        if(k==='v') toggleCamera();
        if(k==='r') { inputState.keyR = true; respawnCar(); } // R 键重生
    });
    window.addEventListener('keyup', (event) => {
        const k = event.key.toLowerCase();
        if(k==='w') inputState.keyW = false;
        if(k==='s') inputState.keyS = false;
        if(k==='a') inputState.keyA = false;
        if(k==='d') inputState.keyD = false;
        if(k===' ') inputState.keySpace = false;
        if(k==='shift') inputState.keyShift = false;
        if(k==='r') inputState.keyR = false;
    });

    function toggleCamera() {
        activeCamera = (activeCamera === cameraChase) ? cameraCockpit : cameraChase;
    }

    function updateControls() {
        if (!chassisBody) return;
        engineForce = 0;
        steeringValue = 0;
        let brake = 0;

        const v = chassisBody.velocity;
        const currentSpeed = v.length() * 3.6;
        const chassisQuaternion = new THREE.Quaternion(chassisBody.quaternion.x, chassisBody.quaternion.y, chassisBody.quaternion.z, chassisBody.quaternion.w);
        const forwardVector = new THREE.Vector3(0, 0, 1).applyQuaternion(chassisQuaternion);
        const velocityVector = new THREE.Vector3(v.x, v.y, v.z);
        const isMovingForward = velocityVector.dot(forwardVector) > 0.5;
        const isMovingBackward = velocityVector.dot(forwardVector) < -0.5;

        if (inputState.keyA) steeringValue = maxSteerVal;
        else if (inputState.keyD) steeringValue = -maxSteerVal;

        if (inputState.keyW) {
            if (isMovingBackward) brake = maxEngineForce * 0.5;
            else { engineForce = -maxEngineForce; gearEl.textContent = 'D'; }
        } else if (inputState.keyS) {
            if (isMovingForward) brake = maxEngineForce * 0.5;
            else { engineForce = maxEngineForce * 0.5; gearEl.textContent = 'R'; }
        } else if (!inputState.keySpace) {
            gearEl.textContent = (currentSpeed < 1) ? 'P' : 'N';
        }

        // Shift 键加速 (超增压)
        if (inputState.keyShift && engineForce !== 0) {
            engineForce *= 2.5; // 超增压
            if (flameMesh) flameMesh.visible = true;
        } else {
            if (flameMesh) flameMesh.visible = false;
        }

        // 应用转向和动力
        vehicle.setSteeringValue(steeringValue, 0);
        vehicle.setSteeringValue(steeringValue, 1);
        vehicle.applyEngineForce(engineForce, 0); 
        vehicle.applyEngineForce(engineForce, 1); 
        vehicle.applyEngineForce(engineForce, 2); 
        vehicle.applyEngineForce(engineForce, 3); 

        // 刹车和手刹
        let finalBrakeRL = brake, finalBrakeRR = brake;
        if (inputState.keySpace) {
            finalBrakeRL = maxEngineForce * 0.8; 
            finalBrakeRR = maxEngineForce * 0.8;
            gearEl.textContent = 'E';
        } else if (brake === 0) {
            vehicle.setBrake(0, 0);
            vehicle.setBrake(0, 1);
            vehicle.setBrake(0, 2);
            vehicle.setBrake(0, 3);
        }

        vehicle.setBrake(brake, 0);
        vehicle.setBrake(brake, 1);
        vehicle.setBrake(finalBrakeRL, 2);
        vehicle.setBrake(finalBrakeRR, 3);
    }

    function updateCamera() {
        if (!chassisBody) return;
        const chassisPos = new THREE.Vector3().copy(chassisBody.position);
        const q = chassisBody.quaternion;

        if (activeCamera === cameraChase) {
            const idealOffset = new THREE.Vector3(0, 3, -7);
            idealOffset.applyQuaternion(q);
            idealOffset.add(chassisPos);
            if(idealOffset.y < chassisPos.y + 0.5) idealOffset.y = chassisPos.y + 0.5;
            cameraChase.position.lerp(idealOffset, 0.1);
            cameraChase.lookAt(chassisPos.x, chassisPos.y + 1, chassisPos.z);
        } else {
            const offset = new THREE.Vector3(0, 0.8, 1.5);
            offset.applyQuaternion(q);
            offset.add(chassisPos);
            cameraCockpit.position.copy(offset);
            cameraCockpit.quaternion.copy(q);
            const rotation180 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI);
            cameraCockpit.quaternion.multiply(rotation180);
        }
    }

    function updateHUD(time) {
        if (!chassisBody) return;
        const v = chassisBody.velocity;
        const speed = v.length() * 3.6; // KM/H
        speedEl.textContent = speed.toFixed(0);
        altitudeEl.textContent = chassisBody.position.y.toFixed(0);
        
        const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(chassisBody.quaternion);
        const heading = Math.atan2(forward.x, forward.z) * 180 / Math.PI;
        let h = (heading + 360) % 360;
        headingEl.textContent = h.toFixed(0).padStart(3, '0');
        
        const rpm = Math.min(99, Math.floor(speed * 1.5));
        rpmEl.textContent = rpm;
        
        let throttlePercent = 0;
        if (engineForce !== 0) {
            throttlePercent = Math.abs((engineForce / (maxEngineForce * 2.5)) * 100);
            if (throttlePercent > 100) throttlePercent = 100;
        }
        throttleEl.textContent = throttlePercent.toFixed(0) + '%';

        updateDistanceAndReward();
        updateDayNight(time);
    }

    function updateDistanceAndReward() {
        if (!chassisBody || !lastCarPosition) return;

        const currentPos = new THREE.Vector3().copy(chassisBody.position);
        
        // 只计算水平距离 (忽略Y轴)
        const distM = new THREE.Vector3(currentPos.x, lastCarPosition.y, currentPos.z).distanceTo(new THREE.Vector3(lastCarPosition.x, lastCarPosition.y, lastCarPosition.z));

        totalDistanceKM += distM / 1000; // 累加到总距离 (KM)
        lastCarPosition.copy(currentPos); // 更新上一个位置

        distanceValueEl.textContent = totalDistanceKM.toFixed(2);

        // 检查奖励等级
        let newLevel = currentRewardLevel;
        for (let i = rewardLevels.length - 1; i >= 0; i--) {
            if (totalDistanceKM >= rewardLevels[i].distance) {
                newLevel = rewardLevels[i];
                break;
            }
        }
        
        if (newLevel.level !== currentRewardLevel.level) {
            currentRewardLevel = newLevel;
            rewardLevelEl.textContent = newLevel.level;
            // 可以在此添加等级提升的视觉或声音效果
            console.log("Reward Level Up! " + newLevel.level);
        }
    }

    function updateDayNight(time) {
        const tSec = time / 1000;
        const cycle = tSec % cycleDurationSec; 
        const halfCycleSec = cycleDurationSec / 2; // 150 seconds

        let t = 0;
        let timeLabel = "DAY";
        let isNight = false;

        if (cycle < halfCycleSec) {
            // Day to Night transition (0s to 150s)
            t = cycle / halfCycleSec;
            isNight = t > 0.5;
            scene.background.lerpColors(daySkyColor, nightSkyColor, t);
            scene.fog.color.copy(scene.background);
            hemiLight.color.lerpColors(dayHemiSky, nightHemiSky, t);
            hemiLight.groundColor.lerpColors(dayHemiGround, nightHemiGround, t);
            dirLight.color.lerpColors(new THREE.Color(0xfff0dd), new THREE.Color(0x222233), t);
            dirLight.intensity = 1.0 * (1 - t) + 0.2 * t;
            hemiLight.intensity = 0.8 * (1 - t) + 0.2 * t;
            timeLabel = (t < 0.2) ? "DAY" : (t < 0.8) ? "TWILIGHT" : "NIGHT";
        } else {
            // Night to Day transition (150s to 300s)
            t = (cycle - halfCycleSec) / halfCycleSec;
            isNight = t < 0.5; // 夜晚部分
            scene.background.lerpColors(nightSkyColor, daySkyColor, t);
            scene.fog.color.copy(scene.background);
            hemiLight.color.lerpColors(nightHemiSky, dayHemiSky, t);
            hemiLight.groundColor.lerpColors(nightHemiGround, dayHemiGround, t);
            dirLight.color.lerpColors(new THREE.Color(0x222233), new THREE.Color(0xfff0dd), t);
            dirLight.intensity = 0.2 * (1 - t) + 1.0 * t;
            hemiLight.intensity = 0.2 * (1 - t) + 0.8 * t;
            timeLabel = (t < 0.2) ? "NIGHT" : (t < 0.8) ? "DAWN" : "DAY";
        }
        timeEl.textContent = timeLabel;
        
        // ** 更新城市自发光 **
        scene.traverse((node) => {
            if (node.isMesh && node.userData.isStandardMaterial) {
                // 标准材质发光强度随时间平滑变化
                const intensity = isNight ? (1 - Math.abs(t - 0.5) * 2) * 2 : 0; // 夜晚达到最高，白天降为0
                node.material.emissiveIntensity = THREE.MathUtils.lerp(0.1, 1.0, intensity);
            }
            if (node.isMesh && node.userData.isEmissive) {
                // 纯色发光材质只在夜晚显示
                node.visible = isNight;
            }
        });
    }

    function updateColliders() {
        if (!chassisBody) return;
        const chassisPos = new THREE.Vector3(chassisBody.position.x, chassisBody.position.y, chassisBody.position.z);
        staticBodies.forEach(obj => {
            const d = chassisPos.distanceTo(obj.center);
            // 简单逻辑：靠近时添加碰撞体，远离时移除
            if (!obj.added && d <= obj.radius + 120) {
                world.addBody(obj.body);
                obj.added = true;
            } else if (obj.added && d > obj.radius + 120) {
                world.removeBody(obj.body);
                obj.added = false;
            }
        });
    }

    function animate(time) {
        requestAnimationFrame(animate);
        if (!chassisBody || !world) return;
        const fixedTimeStep = 1/60;
        const maxSubSteps = 1;
        
        // 物理更新
        if (lastTime !== undefined) {
            const dt = (time - lastTime) / 1000;
            world.step(fixedTimeStep, dt, maxSubSteps);
        } else {
            world.step(fixedTimeStep);
        }
        lastTime = time;

        updateControls();
        
        // 模型同步
        for (let i = 0; i < vehicle.wheelInfos.length; i++) {
            vehicle.updateWheelTransform(i);
            const t = vehicle.wheelInfos[i].worldTransform;
            if (wheelMeshes[i]) {
                wheelMeshes[i].position.copy(t.position);
                wheelMeshes[i].quaternion.copy(t.quaternion);
            }
        }
        if (carMesh && chassisBody) {
            carMesh.position.copy(chassisBody.position);
            carMesh.quaternion.copy(chassisBody.quaternion);
        }

        updateCamera();
        updateHUD(time);
        updateColliders();

        renderer.render(scene, activeCamera);
    }

    // =============================================================================
    // ** 启动逻辑 **
    // =============================================================================
    function startGame() {
        document.getElementById('splash').style.opacity = '0';
        document.getElementById('loading-screen').style.display = 'flex';
        setTimeout(() => {
            document.getElementById('splash').style.display = 'none';
        }, 500);
        
        setupGame();
    }
    window.startGame = startGame;

    function setupGame() {
        initThree();
        initCannon();
        initGround();
        initCameraAndLights();
        initLoaders();
        loadCarModel();
        loadTireModel();
        loadCity();
    }

    window.addEventListener('resize', () => {
        if (renderer && cameraChase && cameraCockpit) {
            renderer.setSize(window.innerWidth, window.innerHeight);
            const aspect = window.innerWidth / window.innerHeight;
            cameraChase.aspect = aspect;
            cameraChase.updateProjectionMatrix();
            cameraCockpit.aspect = aspect;
            cameraCockpit.updateProjectionMatrix();
        }
        if (splashRenderer && splashCamera) {
            const container = document.getElementById('splash-three-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            splashRenderer.setSize(width, height);
            splashCamera.aspect = width / height;
            splashCamera.updateProjectionMatrix();
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        initLoaders();
        initSplashThree();
        loadSplashCarModel();
    });
    </script>
</body>
</html>
