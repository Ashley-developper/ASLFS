<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Babylon GTA Pro - Havok Edition</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; font-family: sans-serif; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">WASD 移动 | F 上下车 | 空格 刹车</div>
    <canvas id="renderCanvas"></canvas>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const FILTERS = { Player: 1, Car: 2, Environment: 4 };

        // --- 车辆类 ---
        class Vehicle {
            constructor(name, position, scene, hkWasm) {
                this.scene = scene;
                this.isOccupied = false;
                this.speed = 0;
                this.steeringAngle = 0;
                
                // 1. 创建车身
                this.mesh = BABYLON.MeshBuilder.CreateBox(name + "_frame", { height: 1.2, width: 6, depth: 12 }, scene);
                this.mesh.position = position;
                this.mesh.visibility = 0.7;

                // 使用 Box 替代 Mesh 碰撞，性能提升 10 倍且不穿模
                const chassisShape = new BABYLON.PhysicsShapeBox(new BABYLON.Vector3(0,0,0), new BABYLON.Quaternion(0,0,0,1), new BABYLON.Vector3(6, 1.2, 12), scene);
                this.body = new BABYLON.PhysicsBody(this.mesh, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
                chassisShape.material = { friction: 0.2, restitution: 0.1 };
                this.body.shape = chassisShape;
                this.body.setMassProperties({ mass: 1000 });
                chassisShape.filterMembershipMask = FILTERS.Car;
                chassisShape.filterCollideMask = FILTERS.Environment | FILTERS.Player;

                // 2. 轮子逻辑 (简化演示：2个驱动轮，2个转向轮)
                this.steerJoints = [];
                this.driveMotors = [];
                this._createWheels();
            }

            _createWheels() {
                const wheelPos = [
                    { p: new BABYLON.Vector3(3, -0.5, 4), steer: true },   // 前左
                    { p: new BABYLON.Vector3(-3, -0.5, 4), steer: true },  // 前右
                    { p: new BABYLON.Vector3(3, -0.5, -4), steer: false }, // 后左
                    { p: new BABYLON.Vector3(-3, -0.5, -4), steer: false } // 后右
                ];

                wheelPos.forEach((config, i) => {
                    const wheel = BABYLON.MeshBuilder.CreateCylinder("w"+i, {height: 0.8, diameter: 2.5}, this.scene);
                    wheel.rotation.z = Math.PI/2;
                    wheel.bakeCurrentTransformIntoVertices();
                    wheel.position = this.mesh.position.add(config.p);
                    
                    const wheelBody = new BABYLON.PhysicsBody(wheel, BABYLON.PhysicsMotionType.DYNAMIC, false, this.scene);
                    const wheelShape = new BABYLON.PhysicsShapeCylinder(new BABYLON.Vector3(-0.4,0,0), new BABYLON.Vector3(0.4,0,0), 1.25, this.scene);
                    wheelShape.material = { friction: 0.8, restitution: 0.1 };
                    wheelBody.shape = wheelShape;
                    wheelBody.setMassProperties({ mass: 50 });
                    wheelShape.filterMembershipMask = FILTERS.Car;

                    // 6DoF 约束
                    const joint = new BABYLON.Physics6DoFConstraint({
                        pivotA: config.p,
                        pivotB: BABYLON.Vector3.Zero(),
                        axisA: BABYLON.Vector3.Forward(),
                        axisB: BABYLON.Vector3.Forward()
                    }, [
                        { axis: BABYLON.PhysicsConstraintAxis.LINEAR_DISTANCE, minLimit: 0, maxLimit: 0 },
                        { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Y, minLimit: config.steer ? -0.5 : 0, maxLimit: config.steer ? 0.5 : 0 }
                    ], this.scene);

                    this.body.addConstraint(wheelBody, joint);

                    if(config.steer) {
                        joint.setAxisMotorType(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, BABYLON.PhysicsConstraintMotorType.POSITION);
                        this.steerJoints.push(joint);
                    }
                    
                    joint.setAxisMotorType(BABYLON.PhysicsConstraintAxis.ANGULAR_X, BABYLON.PhysicsConstraintMotorType.VELOCITY);
                    joint.setAxisMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_X, 100000);
                    this.driveMotors.push(joint);
                });
            }

            update(input) {
                if(!this.isOccupied) {
                    this.driveMotors.forEach(m => m.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_X, 0));
                    return;
                }

                // 转向逻辑
                if (input.left) this.steeringAngle = BABYLON.Scalar.Lerp(this.steeringAngle, 0.5, 0.1);
                else if (input.right) this.steeringAngle = BABYLON.Scalar.Lerp(this.steeringAngle, -0.5, 0.1);
                else this.steeringAngle *= 0.9;
                this.steerJoints.forEach(s => s.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, this.steeringAngle));

                // 动力逻辑
                if (input.forward) this.speed = 150;
                else if (input.back) this.speed = -50;
                else this.speed *= 0.95;
                this.driveMotors.forEach(m => m.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_X, this.speed));
            }
        }

        // --- 角色类 ---
        class Player {
            constructor(scene) {
                this.mesh = BABYLON.MeshBuilder.CreateCapsule("Player", { height: 4, radius: 1 }, scene);
                this.mesh.position.y = 5;
                this.body = new BABYLON.PhysicsBody(this.mesh, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
                const shape = new BABYLON.PhysicsShapeCapsule(new BABYLON.Vector3(0,-1.5,0), new BABYLON.Vector3(0,1.5,0), 1, scene);
                this.body.shape = shape;
                this.body.setMassProperties({ mass: 80 });
                this.body.setLinearDamping(0.5);
                this.body.setAngularDamping(1.0); // 防止人像不倒翁一样乱滚
                shape.filterMembershipMask = FILTERS.Player;
            }

            update(input, cameraRotation) {
                if(!this.mesh.isEnabled()) return;

                let moveVec = BABYLON.Vector3.Zero();
                if (input.forward) moveVec.z = 1;
                if (input.back) moveVec.z = -1;
                if (input.left) moveVec.x = -1;
                if (input.right) moveVec.x = 1;

                if (moveVec.length() > 0) {
                    // 根据相机方向移动
                    const forward = BABYLON.Vector3.TransformCoordinates(BABYLON.Vector3.Forward(), BABYLON.Matrix.RotationY(cameraRotation));
                    const right = BABYLON.Vector3.TransformCoordinates(BABYLON.Vector3.Right(), BABYLON.Matrix.RotationY(cameraRotation));
                    const direction = forward.scale(moveVec.z).add(right.scale(moveVec.x)).normalize();
                    
                    this.body.applyImpulse(direction.scale(20), this.mesh.getAbsolutePosition());
                    // 面对移动方向
                    this.mesh.rotation.y = Math.atan2(direction.x, direction.z);
                }
            }
        }

        // --- 主游戏管理 ---
        async function init() {
            const hkWasm = await HavokPhysics();
            const engine = new BABYLON.Engine(canvas, true);
            const scene = new BABYLON.Scene(engine);
            const havok = new BABYLON.HavokPlugin(false, hkWasm);
            scene.enablePhysics(new BABYLON.Vector3(0, -9.8, 0), havok);

            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            const camera = new BABYLON.ArcRotateCamera("cam", -Math.PI/2, Math.PI/3, 40, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);

            // 地面
            const ground = BABYLON.MeshBuilder.CreateGround("g", {width: 500, height: 500}, scene);
            const groundBody = new BABYLON.PhysicsBody(ground, BABYLON.PhysicsMotionType.STATIC, false, scene);
            const groundShape = new BABYLON.PhysicsShapeMesh(ground, scene);
            groundBody.shape = groundShape;
            groundShape.filterMembershipMask = FILTERS.Environment;

            // 初始化玩家和车
            const player = new Player(scene);
            const car = new Vehicle("GTACar", new BABYLON.Vector3(20, 2, 0), scene, hkWasm);
            
            let currentMode = "player"; // "player" or "car"
            const inputs = { forward:false, back:false, left:false, right:false };

            // 监听键盘
            window.addEventListener("keydown", (e) => {
                if(e.key == "w") inputs.forward = true;
                if(e.key == "s") inputs.back = true;
                if(e.key == "a") inputs.left = true;
                if(e.key == "d") inputs.right = true;
                
                // 上下车逻辑 (F 键)
                if(e.key == "f") {
                    if(currentMode == "player") {
                        const dist = BABYLON.Vector3.Distance(player.mesh.position, car.mesh.position);
                        if(dist < 8) {
                            currentMode = "car";
                            car.isOccupied = true;
                            player.mesh.setEnabled(false); // 隐藏玩家
                            camera.lockedTarget = car.mesh; // 相机切到车
                        }
                    } else {
                        currentMode = "player";
                        car.isOccupied = false;
                        player.mesh.setEnabled(true);
                        player.mesh.position = car.mesh.position.add(new BABYLON.Vector3(8, 2, 0)); // 在车旁边生成
                        camera.lockedTarget = player.mesh; // 相机切回人
                    }
                }
            });
            window.addEventListener("keyup", (e) => {
                if(e.key == "w") inputs.forward = false;
                if(e.key == "s") inputs.back = false;
                if(e.key == "a") inputs.left = false;
                if(e.key == "d") inputs.right = false;
            });

            camera.lockedTarget = player.mesh;

            scene.onBeforeRenderObservable.add(() => {
                if(currentMode == "player") {
                    player.update(inputs, camera.alpha);
                } else {
                    car.update(inputs);
                }
            });

            engine.runRenderLoop(() => scene.render());
        }

        init();
    </script>
</body>
</html>
