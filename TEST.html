<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Havok RC Test - Dual Cars & Physics Props</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        const canvas = document.getElementById("renderCanvas");
        let scene, havokInstance, tyreMaterial;
        const debugColours = [];
        debugColours[0] = new BABYLON.Color4(1, 0, 1, 1);
        debugColours[1] = new BABYLON.Color4(1, 0, 0, 1);
        debugColours[2] = new BABYLON.Color4(0, 1, 0, 1);
        debugColours[3] = new BABYLON.Color4(1, 1, 0, 1);
        debugColours[4] = new BABYLON.Color4(0, 1, 1, 1);
        debugColours[5] = new BABYLON.Color4(0, 0, 1, 1);
        
        const FILTERS = { CarParts: 1, Environment: 2 };

        async function init() {
            const hkWasm = await HavokPhysics();
            havokInstance = new BABYLON.HavokPlugin(false, hkWasm);
            await createScene();
        }

        async function createScene() {
            const engine = new BABYLON.Engine(canvas, true);
            scene = new BABYLON.Scene(engine);

            // 物理引擎配置
            scene.enablePhysics(new BABYLON.Vector3(0, -240, 0), havokInstance);
            scene.getPhysicsEngine().setTimeStep(1 / 500);
            scene.getPhysicsEngine().setSubTimeStep(4.5);

            const camera = new BABYLON.FollowCamera("FollowCam", new BABYLON.Vector3(0, 20, -50), scene);
            camera.radius = 80;
            camera.heightOffset = 30;
            camera.rotationOffset = 180;
            camera.cameraAcceleration = 0.05;
            camera.maxCameraSpeed = 20;

            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);
            light.intensity = 0.8;

            InitTyreMaterial();
            CreateGroundAndWalls();
            CreateTestObjects();

            // 创建两辆车，传入不同的起始位置和键位配置
            const car1 = CreateCar(new BABYLON.Vector3(0, 0.3, 0), {
                up: "w", down: "s", left: "a", right: "d"
            });
            
            const car2 = CreateCar(new BABYLON.Vector3(30, 0.3, 0), {
                up: "i", down: "k", left: "j", right: "l"
            });

            camera.lockedTarget = car1; // 相机默认跟随 1 号车

            engine.runRenderLoop(() => {
                if (scene && scene.activeCamera) {
                    scene.render();
                }
            });

            window.addEventListener('resize', () => engine.resize());
        }

        // =========================================================================
        // 核心逻辑
        // =========================================================================

        function CreateCar(startPos, keys) {
            const carFrame = BABYLON.MeshBuilder.CreateBox("Frame", { height: 1, width: 12, depth: 24, faceColors: debugColours });
            carFrame.position = startPos;
            carFrame.visibility = 0.6;
            const carFrameBody = AddDynamicPhysics(carFrame, 1000, 0, 0);
            FilterMeshCollisions(carFrame);

            const wheelOffsets = [
                { pos: new BABYLON.Vector3(5, 0, 8), steer: true, power: true },   // 前左
                { pos: new BABYLON.Vector3(-5, 0, 8), steer: true, power: true },  // 前右
                { pos: new BABYLON.Vector3(5, 0, -8), steer: false, power: false }, // 后左
                { pos: new BABYLON.Vector3(-5, 0, -8), steer: false, power: false } // 后右
            ];

            const steerJoints = [];
            const motorJoints = [];

            wheelOffsets.forEach(config => {
                const worldPos = startPos.add(config.pos);
                const wheel = CreateWheel(worldPos);
                const axle = CreateAxle(worldPos);
                carFrame.addChild(axle);

                AddAxlePhysics(axle, 100, 0, 0);
                FilterMeshCollisions(axle);
                AddWheelPhysics(wheel, 100, 0.1, 50);
                FilterMeshCollisions(wheel);

                const joint = AttachAxleToFrame(axle.physicsBody, carFrameBody, config.steer);
                if (config.steer) steerJoints.push(joint);

                const mJoint = config.power ? CreatePoweredWheelJoint(axle, wheel) : CreateWheelJoint(axle, wheel);
                if (config.power) motorJoints.push(mJoint);
            });

            InitKeyboardControls(motorJoints[0], motorJoints[1], steerJoints[0], steerJoints[1], keys);
            return carFrame;
        }

        function CreateAxle(position) {
            const axleMesh = BABYLON.MeshBuilder.CreateBox("Axle", { height: 1, width: 2.5, depth: 1, faceColors: debugColours });
            axleMesh.position = position;
            return axleMesh;
        }

        function CreateWheel(position) {
            const faceUV = [
                new BABYLON.Vector4(0, 0, 0, 0),
                new BABYLON.Vector4(0, 1, 1, 0),
                new BABYLON.Vector4(0, 0, 0, 0),
            ];
            const wheelMesh = BABYLON.MeshBuilder.CreateCylinder("Wheel", { height: 1.6, diameter: 4, faceUV: faceUV });
            wheelMesh.rotation = new BABYLON.Vector3(0, 0, Math.PI / 2);
            wheelMesh.bakeCurrentTransformIntoVertices();
            wheelMesh.position = position;
            wheelMesh.material = tyreMaterial;
            return wheelMesh;
        }

        function AttachAxleToFrame(axle, frame, hasSteering) {
            const aPos = axle.transformNode.position.subtract(frame.transformNode.position);
            const joint = new BABYLON.Physics6DoFConstraint({
                pivotA: aPos,
                pivotB: new BABYLON.Vector3(0, 0, 0),
            }, [
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_X, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_Y, minLimit: -0.15, maxLimit: 0.15, stiffness: 100000, damping: 5000 },
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_Z, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_X, minLimit: -0.25, maxLimit: 0.25 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Y, minLimit: hasSteering ? null : 0, maxLimit: hasSteering ? null : 0 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Z, minLimit: -0.05, maxLimit: 0.05 },
            ], scene);
            frame.addConstraint(axle, joint);
            if (hasSteering) {
                joint.setAxisMotorType(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, BABYLON.PhysicsConstraintMotorType.POSITION);
                joint.setAxisMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, 30000000);
            }
            return joint;
        }

        function CreateWheelJoint(axle, wheel) {
            const motorJoint = new BABYLON.Physics6DoFConstraint({}, [
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_DISTANCE, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Y, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Z, minLimit: 0, maxLimit: 0 },
            ], scene);
            axle.physicsBody.addConstraint(wheel.physicsBody, motorJoint);
            return motorJoint;
        }

        function CreatePoweredWheelJoint(axle, wheel) {
            const motorJoint = CreateWheelJoint(axle, wheel);
            motorJoint.setAxisMotorType(BABYLON.PhysicsConstraintAxis.ANGULAR_X, BABYLON.PhysicsConstraintMotorType.VELOCITY);
            motorJoint.setAxisMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_X, 180000);
            motorJoint.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_X, 0);
            return motorJoint;
        }

        function InitKeyboardControls(motorA, motorB, steerA, steerB, keys) {
            let forward = false, back = false, left = false, right = false;
            let currentSpeed = 0, currentSteeringAngle = 0;
            const maxSteeringAngle = Math.PI / 6;

            scene.onKeyboardObservable.add(e => {
                const isDown = e.type == BABYLON.KeyboardEventTypes.KEYDOWN;
                const key = e.event.key.toLowerCase();
                if (key === keys.up) forward = isDown;
                if (key === keys.down) back = isDown;
                if (key === keys.left) left = isDown;
                if (key === keys.right) right = isDown;
            });

            scene.onBeforeRenderObservable.add(() => {
                if (left && currentSteeringAngle < maxSteeringAngle) currentSteeringAngle += 0.01;
                else if (right && currentSteeringAngle > -maxSteeringAngle) currentSteeringAngle -= 0.01;
                else currentSteeringAngle *= 0.98;

                const [inner, outer] = CalculateWheelAngles(currentSteeringAngle);
                steerA.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, outer);
                steerB.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, inner);

                if (forward && currentSpeed < 150) currentSpeed += 8;
                else if (back && currentSpeed > -75) currentSpeed -= 8;
                else currentSpeed *= 0.99;

                motorA.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_X, currentSpeed);
                motorB.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_X, currentSpeed);
            });
        }

        function InitTyreMaterial() {
            tyreMaterial = new BABYLON.StandardMaterial("Tyre", scene);
            tyreMaterial.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
        }

        function CreateGroundAndWalls() {
            // 地面与纹理
            const ground = BABYLON.MeshBuilder.CreateGround("Ground", { height: 1000, width: 1000 });
            ground.position.y = -5;
            const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
            groundMat.diffuseTexture = new BABYLON.Texture("https://www.babylonjs-dtp.com/assets/grid.png", scene);
            groundMat.diffuseTexture.uScale = 50;
            groundMat.diffuseTexture.vScale = 50;
            ground.material = groundMat;
            
            AddStaticPhysics(ground, 300);
            ground.physicsBody.shape.filterMembershipMask = FILTERS.Environment;

            // 围墙
            const wallSize = 1000;
            const wallData = [
                { p: [0, 5, 500], s: [1000, 20, 2] },
                { p: [0, 5, -500], s: [1000, 20, 2] },
                { p: [500, 5, 0], s: [2, 20, 1000] },
                { p: [-500, 5, 0], s: [2, 20, 1000] }
            ];
            wallData.forEach(d => {
                const wall = BABYLON.MeshBuilder.CreateBox("Wall", { width: d.s[0], height: d.s[1], depth: d.s[2] });
                wall.position = new BABYLON.Vector3(d.p[0], d.p[1], d.p[2]);
                AddStaticPhysics(wall, 10);
                wall.physicsBody.shape.filterMembershipMask = FILTERS.Environment;
            });
        }

        function CreateTestObjects() {
            // 1. 动力学大球
            const ball = BABYLON.MeshBuilder.CreateSphere("Ball", { diameter: 12 }, scene);
            ball.position = new BABYLON.Vector3(0, 10, 60);
            const ballBody = new BABYLON.PhysicsBody(ball, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
            const ballShape = new BABYLON.PhysicsShapeSphere(BABYLON.Vector3.Zero(), 6, scene);
            ballShape.material = { restitution: 0.6, friction: 0.2 };
            ballBody.shape = ballShape;
            ballBody.setMassProperties({ mass: 400 });
            ballBody.shape.filterMembershipMask = FILTERS.Environment;
            ballBody.shape.filterCollideMask = FILTERS.CarParts | FILTERS.Environment;

            // 2. 起飞坡
            const ramp = BABYLON.MeshBuilder.CreateBox("Ramp", { width: 30, height: 2, depth: 50 }, scene);
            ramp.position = new BABYLON.Vector3(-40, -1, 120);
            ramp.rotation.x = -Math.PI / 10;
            const rampMat = new BABYLON.StandardMaterial("rampMat", scene);
            rampMat.diffuseColor = new BABYLON.Color3(1, 0.8, 0);
            ramp.material = rampMat;
            AddStaticPhysics(ramp, 10);
            ramp.physicsBody.shape.filterMembershipMask = FILTERS.Environment;

            // 3. 测试房子
            const house = BABYLON.MeshBuilder.CreateBox("House", { size: 20 }, scene);
            house.position = new BABYLON.Vector3(60, 5, 80);
            AddStaticPhysics(house, 10);
            house.physicsBody.shape.filterMembershipMask = FILTERS.Environment;
        }

        // =========================================================================
        // 物理辅助函数 (保留原逻辑)
        // =========================================================================

        function AddWheelPhysics(mesh, mass, bounce, friction) {
            const physicsShape = new BABYLON.PhysicsShapeCylinder(new BABYLON.Vector3(-0.8, 0, 0), new BABYLON.Vector3(0.8, 0, 0), 2, scene);
            const physicsBody = new BABYLON.PhysicsBody(mesh, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
            physicsBody.setMassProperties({ mass: mass });
            physicsShape.material = { restitution: bounce, friction: friction };
            physicsBody.shape = physicsShape;
            return physicsBody;
        }

        function AddAxlePhysics(mesh, mass, bounce, friction) {
            const physicsShape = new BABYLON.PhysicsShapeCylinder(new BABYLON.Vector3(-0.8, 0, 0), new BABYLON.Vector3(0.8, 0, 0), 1.8, scene);
            const physicsBody = new BABYLON.PhysicsBody(mesh, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
            physicsBody.setMassProperties({ mass: mass });
            physicsShape.material = { restitution: bounce, friction: friction };
            physicsBody.shape = physicsShape;
            return physicsBody;
        }

        function AddDynamicPhysics(mesh, mass, bounce, friction) {
            const physicsShape = new BABYLON.PhysicsShapeMesh(mesh, scene);
            const physicsBody = new BABYLON.PhysicsBody(mesh, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
            physicsBody.setMassProperties({ mass: mass });
            physicsShape.material = { restitution: bounce, friction: friction };
            physicsBody.shape = physicsShape;
            return physicsBody;
        }

        function AddStaticPhysics(mesh, friction) {
            const physicsShape = new BABYLON.PhysicsShapeMesh(mesh, scene);
            const physicsBody = new BABYLON.PhysicsBody(mesh, BABYLON.PhysicsMotionType.STATIC, false, scene);
            physicsShape.material = { restitution: 0, friction: friction };
            physicsBody.shape = physicsShape;
            return physicsBody;
        }

        function FilterMeshCollisions(mesh) {
            mesh.physicsBody.shape.filterMembershipMask = FILTERS.CarParts;
            mesh.physicsBody.shape.filterCollideMask = FILTERS.Environment;
        }

        function CalculateWheelAngles(averageAngle) {
            const wheelbase = 16, trackWidth = 11;
            const avgRadius = wheelbase / Math.tan(averageAngle);
            const innerRadius = avgRadius - trackWidth / 2;
            const outerRadius = avgRadius + trackWidth / 2;
            const innerAngle = Math.atan(wheelbase / innerRadius);
            const outerAngle = Math.atan(wheelbase / outerRadius);
            return [isNaN(innerAngle) ? 0 : innerAngle, isNaN(outerAngle) ? 0 : outerAngle];
        }

        init();
    </script>
</body>
</html>
