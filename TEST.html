<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>HYPER DRIVE | HAVOK NATIVE</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #00FFFF; display: flex; 
            align-items: center; justify-content: center; font-family: 'Orbitron';
        }
    </style>
</head>
<body>

    <div id="loading">HAVOK ENGINE BOOTING...</div>
    <canvas id="renderCanvas"></canvas>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>

    <script>
        const canvas = document.getElementById("renderCanvas");
        let engine, scene, carBody, joints = [];
        let inputMap = {};

        // 1. 异步初始化 Havok
        async function init() {
            const havokInstance = await HavokPhysics();
            const hk = new BABYLON.HavokPlugin(true, havokInstance);
            
            engine = new BABYLON.Engine(canvas, true);
            scene = new BABYLON.Scene(engine);
            scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), hk);

            setupEnvironment();
            createPlayerCar();
            setupInputs();

            document.getElementById('loading').style.display = 'none';
            
            engine.runRenderLoop(() => scene.render());
        }

        function setupEnvironment() {
            const camera = new BABYLON.ArcRotateCamera("cam", -Math.PI/2, Math.PI/3, 15, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            
            new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

            // 静态地面
            const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 1000, height: 1000}, scene);
            ground.material = new BABYLON.StandardMaterial("gMat", scene);
            ground.material.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            
            new BABYLON.PhysicsAggregate(ground, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);
        }

        function createPlayerCar() {
            // --- A. 车身 ---
            const chassis = BABYLON.MeshBuilder.CreateBox("chassis", {width: 2, height: 0.6, depth: 4}, scene);
            chassis.position.y = 2;
            
            const chassisAgg = new BABYLON.PhysicsAggregate(chassis, BABYLON.PhysicsShapeType.BOX, { mass: 1500, friction: 0.5 }, scene);
            carBody = chassisAgg.body;

            // 重要：下移重心，防止 Havok 物理模拟时车体过于晃动
            carBody.setMassProperties({ centerOfMass: new BABYLON.Vector3(0, -0.4, 0) });

            // --- B. 车轮与约束 ---
            const wheelPositions = [
                new BABYLON.Vector3(-1.1, -0.3, 1.3),  // 前左
                new BABYLON.Vector3( 1.1, -0.3, 1.3),  // 前右
                new BABYLON.Vector3(-1.1, -0.3, -1.3), // 后左
                new BABYLON.Vector3( 1.1, -0.3, -1.3)  // 后右
            ];

           // --- 核心修正：车轮轴向对齐 ---

wheelPositions.forEach((pos, i) => {
    const isFront = i < 2;
    // 1. 创建圆柱体
    const wheel = BABYLON.MeshBuilder.CreateCylinder("w" + i, { diameter: 0.8, height: 0.4 }, scene);
    
    // 2. 关键：修正视觉旋转，让圆柱体“躺下来”
    wheel.rotation.z = Math.PI / 2; 
    wheel.bakeCurrentTransformIntoVertices(); // 永久固定这个旋转，让它的局部坐标系回归正轨

    wheel.position = chassis.position.add(pos);
    
    // 3. 物理聚合体
    const wheelAgg = new BABYLON.PhysicsAggregate(wheel, BABYLON.PhysicsShapeType.CYLINDER, { mass: 50, friction: 2.0 }, scene);

    // 4. 六自由度约束 (6DoF)
    const constraint = new BABYLON.Physics6DoFConstraint(
        {
            pivotA: pos,
            pivotB: BABYLON.Vector3.Zero(),
            // 重点：告诉引擎，旋转发生在这两个轴之间
            axisA: new BABYLON.Vector3(1, 0, 0), 
            axisB: new BABYLON.Vector3(1, 0, 0), 
            perpAxisA: new BABYLON.Vector3(0, 1, 0),
            perpAxisB: new BABYLON.Vector3(0, 1, 0),
        },
        [
            { axis: BABYLON.PhysicsConstraintAxis.LINEAR_X, minLimit: 0, maxLimit: 0 },
            { axis: BABYLON.PhysicsConstraintAxis.LINEAR_Y, minLimit: -0.1, maxLimit: 0.1 }, // 悬挂
            { axis: BABYLON.PhysicsConstraintAxis.LINEAR_Z, minLimit: 0, maxLimit: 0 },
            
            // 转向轴 (前轮控制 ANGULAR_Y)
            { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_X, minLimit: 0, maxLimit: 0 }, 
            { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Y, minLimit: isFront ? -0.5 : 0, maxLimit: isFront ? 0.5 : 0 },
            // 滚动轴 (动力控制 ANGULAR_Z) - 这样轮子就是前后转了！
            { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Z, minLimit: null, maxLimit: null } 
        ],
        scene
    );

    carBody.addConstraint(wheelAgg.body, constraint);
    joints.push({ constraint, isFront });
});

            // 逻辑循环
            scene.registerBeforeRender(() => {
                let motorSpeed = 0;
                if(inputMap["w"]) motorSpeed = 50;
                if(inputMap["s"]) motorSpeed = -30;

                let steerAngle = 0;
                if(inputMap["a"]) steerAngle = -0.5;
                if(inputMap["d"]) steerAngle = 0.5;

                joints.forEach(j => {
                    // 后轮驱动
                    if(!j.isFront) {
                        j.constraint.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, motorSpeed);
                        j.constraint.setAxisMotorType(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, BABYLON.PhysicsConstraintMotorType.VELOCITY);
                        j.constraint.setAxisMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, 2000);
                    }
                    // 前轮转向
                    if(j.isFront) {
                        j.constraint.setAxisMinLimit(BABYLON.PhysicsConstraintAxis.ANGULAR_X, steerAngle);
                        j.constraint.setAxisMaxLimit(BABYLON.PhysicsConstraintAxis.ANGULAR_X, steerAngle);
                    }
                });
            });
        }

        function setupInputs() {
            window.addEventListener("keydown", e => inputMap[e.key.toLowerCase()] = true);
            window.addEventListener("keyup", e => inputMap[e.key.toLowerCase()] = false);
        }

        init();
    </script>
</body>
</html>
