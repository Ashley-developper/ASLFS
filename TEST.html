<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Babylon GTA - Havok Pro Module</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
        #instructions { position: absolute; top: 20px; left: 20px; color: white; background: rgba(0,0,0,0.5); padding: 10px; pointer-events: none; }
    </style>
</head>
<body>
    <div id="instructions">
        <b>[Walking]</b> WASD to Move, F to Enter Car<br>
        <b>[Driving]</b> WASD to Drive, Space to Brake, F to Exit
    </div>
    <canvas id="renderCanvas"></canvas>

<script>
/**
 * ============================================================
 * 模块 1: 全局配置与输入管理器
 * ============================================================
 */
class InputManager {
    constructor(scene) {
        this.keys = {};
        scene.onKeyboardObservable.add((kbInfo) => {
            this.keys[kbInfo.event.key.toLowerCase()] = kbInfo.type === BABYLON.KeyboardEventTypes.KEYDOWN;
        });
    }
    isPressed(key) { return this.keys[key.toLowerCase()] || false; }
}

/**
 * ============================================================
 * 模块 2: 车辆实体类 (Vehicle)
 * ============================================================
 */
class Vehicle {
    constructor(name, position, scene) {
        this.scene = scene;
        this.steerJoints = [];
        this.motors = [];
        this.isOccupied = false;
        
        // 1. 创建底盘 (使用 Box 碰撞体代替 Mesh 提高性能)
        this.chassis = BABYLON.MeshBuilder.CreateBox(name + "_chassis", { height: 1.2, width: 6, depth: 12 }, scene);
        this.chassis.position = position;
        this.chassis.visibility = 0.6;
        
        const chassisShape = new BABYLON.PhysicsShapeBox(BABYLON.Vector3.Zero(), BABYLON.Quaternion.Identity(), new BABYLON.Vector3(6, 1.2, 12), scene);
        this.body = new BABYLON.PhysicsBody(this.chassis, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
        this.body.setMassProperties({ mass: 1500 });
        this.body.shape = chassisShape;
        chassisShape.material = { friction: 0.2, restitution: 0.1 };

        // 2. 创建车轮与轴
        this._initWheels(position);
    }

    _initWheels(pos) {
        const wheelData = [
            { name: "fl", pos: new BABYLON.Vector3(3, -0.5, 4), steer: true, drive: true },
            { name: "fr", pos: new BABYLON.Vector3(-3, -0.5, 4), steer: true, drive: true },
            { name: "rl", pos: new BABYLON.Vector3(3, -0.5, -4), steer: false, drive: false },
            { name: "rr", pos: new BABYLON.Vector3(-3, -0.5, -4), steer: false, drive: false }
        ];

        wheelData.forEach(data => {
            // 创建轴 (Axle)
            const axle = BABYLON.MeshBuilder.CreateBox("axle", { size: 0.5 }, this.scene);
            axle.position = this.chassis.position.add(data.pos);
            const axleBody = new BABYLON.PhysicsBody(axle, BABYLON.PhysicsMotionType.DYNAMIC, false, this.scene);
            axleBody.shape = new BABYLON.PhysicsShapeBox(BABYLON.Vector3.Zero(), BABYLON.Quaternion.Identity(), new BABYLON.Vector3(0.5, 0.5, 0.5), this.scene);
            axleBody.setMassProperties({ mass: 50 });

            // 创建轮子 (Wheel)
            const wheel = BABYLON.MeshBuilder.CreateCylinder("wheel", { diameter: 2.5, height: 1, tessellation: 24 }, this.scene);
            wheel.rotation.z = Math.PI / 2;
            wheel.bakeCurrentTransformIntoVertices();
            wheel.position = axle.position;
            
            const wheelBody = new BABYLON.PhysicsBody(wheel, BABYLON.PhysicsMotionType.DYNAMIC, false, this.scene);
            const wheelShape = new BABYLON.PhysicsShapeCylinder(new BABYLON.Vector3(-0.5, 0, 0), new BABYLON.Vector3(0.5, 0, 0), 1.25, this.scene);
            wheelShape.material = { friction: 2.0, restitution: 0.1 }; // 增加摩擦力
            wheelBody.shape = wheelShape;
            wheelBody.setMassProperties({ mass: 100 });

            // 6DoF 约束: 轴连到底盘 (悬挂 + 转向)
            const axleJoint = new BABYLON.Physics6DoFConstraint({
                pivotA: data.pos,
                pivotB: BABYLON.Vector3.Zero(),
            }, [
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_Y, minLimit: -0.2, maxLimit: 0.2, stiffness: 50000, damping: 2000 },
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_X, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_Z, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Y, minLimit: data.steer ? -0.5 : 0, maxLimit: data.steer ? 0.5 : 0 },
            ], this.scene);
            this.body.addConstraint(axleBody, axleJoint);

            // 6DoF 约束: 轮子连到轴 (驱动)
            const wheelJoint = new BABYLON.Physics6DoFConstraint({
                pivotA: BABYLON.Vector3.Zero(),
                pivotB: BABYLON.Vector3.Zero(),
            }, [
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_DISTANCE, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Y, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Z, minLimit: 0, maxLimit: 0 },
            ], this.scene);
            axleBody.addConstraint(wheelBody, wheelJoint);

            if (data.steer) {
                axleJoint.setAxisMotorType(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, BABYLON.PhysicsConstraintMotorType.POSITION);
                axleJoint.setAxisMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, 1000000);
                this.steerJoints.push(axleJoint);
            }
            if (data.drive) {
                wheelJoint.setAxisMotorType(BABYLON.PhysicsConstraintAxis.ANGULAR_X, BABYLON.PhysicsConstraintMotorType.VELOCITY);
                wheelJoint.setAxisMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_X, 500000);
                this.motors.push(wheelJoint);
            }
        });
    }

    update(input) {
        if (!this.isOccupied) {
            this.motors.forEach(m => m.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_X, 0));
            return;
        }

        let speed = 0;
        if (input.isPressed("w")) speed = 100;
        if (input.isPressed("s")) speed = -50;
        if (input.isPressed(" ")) speed = 0;

        let steer = 0;
        if (input.isPressed("a")) steer = 0.5;
        if (input.isPressed("d")) steer = -0.5;

        this.motors.forEach(m => m.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_X, speed));
        this.steerJoints.forEach(s => s.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, steer));
    }
}

/**
 * ============================================================
 * 模块 3: 角色实体类 (Player)
 * ============================================================
 */
class Player {
    constructor(position, scene) {
        this.scene = scene;
        this.mesh = BABYLON.MeshBuilder.CreateCapsule("player", { height: 4, radius: 1 }, scene);
        this.mesh.position = position;
        
        const shape = new BABYLON.PhysicsShapeCapsule(new BABYLON.Vector3(0, -1, 0), new BABYLON.Vector3(0, 1, 0), 1, scene);
        this.body = new BABYLON.PhysicsBody(this.mesh, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
        this.body.setMassProperties({ mass: 80 });
        this.body.shape = shape;
        this.body.setLinearDamping(0.5);
        this.body.setAngularDamping(1.0); // 防止人像不倒翁一样乱晃
        
        this.state = "walking"; // walking | driving
    }

    update(input, car) {
        if (this.state === "walking") {
            const force = new BABYLON.Vector3(0, 0, 0);
            const moveSpeed = 800;
            if (input.isPressed("w")) force.z = moveSpeed;
            if (input.isPressed("s")) force.z = -moveSpeed;
            if (input.isPressed("a")) force.x = -moveSpeed;
            if (input.isPressed("d")) force.x = moveSpeed;
            this.body.applyForce(force, this.mesh.getAbsolutePosition());

            // 交互逻辑: 按 F 上车
            if (input.isPressed("f")) {
                const dist = BABYLON.Vector3.Distance(this.mesh.position, car.chassis.position);
                if (dist < 8) this.enterVehicle(car);
            }
        } else if (this.state === "driving") {
            // 人在车里，位置跟随
            this.mesh.position.copyFrom(car.chassis.position);
            
            if (input.isPressed("f")) this.exitVehicle(car);
        }
    }

    enterVehicle(car) {
        this.state = "driving";
        car.isOccupied = true;
        this.body.setMotionType(BABYLON.PhysicsMotionType.ANIMATED); // 关闭物理模拟
        this.mesh.isVisible = false; // 进入车内暂时隐藏模型
        console.log("Entered Vehicle");
    }

    exitVehicle(car) {
        this.state = "walking";
        car.isOccupied = false;
        this.body.setMotionType(BABYLON.PhysicsMotionType.DYNAMIC);
        this.mesh.isVisible = true;
        // 弹射到车门旁边
        this.mesh.position = car.chassis.position.add(new BABYLON.Vector3(8, 2, 0));
        console.log("Exited Vehicle");
    }
}

/**
 * ============================================================
 * 模块 4: 主程序
 * ============================================================
 */
async function runGame() {
    const hkWasm = await HavokPhysics();
    const havokPlugin = new BABYLON.HavokPlugin(true, hkWasm);
    
    const engine = new BABYLON.Engine(document.getElementById("renderCanvas"), true);
    const scene = new BABYLON.Scene(engine);
    
    // 物理环境优化
    scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), havokPlugin);
    // CCD 开启防止穿模 (对高速载具至关重要)
    // subTimeStep 决定了计算精度
    scene.getPhysicsEngine().setSubTimeStep(16); 

    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    const input = new InputManager(scene);

    // 地面
    const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 1000, height: 1000 }, scene);
    const groundBody = new BABYLON.PhysicsBody(ground, BABYLON.PhysicsMotionType.STATIC, false, scene);
    groundBody.shape = new BABYLON.PhysicsShapeMesh(ground, scene);

    // 初始化实体
    const myCar = new Vehicle("GTACar", new BABYLON.Vector3(0, 5, 20), scene);
    const player = new Player(new BABYLON.Vector3(0, 5, 0), scene);

    // 相机跟随系统
    const camera = new BABYLON.FollowCamera("camera", new BABYLON.Vector3(0, 10, -20), scene);
    camera.radius = 30;
    camera.heightOffset = 10;
    camera.cameraAcceleration = 0.1;
    camera.maxCameraSpeed = 50;
    scene.activeCamera = camera;

    scene.onBeforeRenderObservable.add(() => {
        player.update(input, myCar);
        myCar.update(input);

        // 动态相机目标
        if (player.state === "walking") {
            camera.lockedTarget = player.mesh;
        } else {
            camera.lockedTarget = myCar.chassis;
        }
    });

    engine.runRenderLoop(() => scene.render());
    window.addEventListener("resize", () => engine.resize());
}

runGame();
</script>
</body>
</html>
