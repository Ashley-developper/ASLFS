
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>SMASH CITY: TUNED PHYSICS</title>
    <!-- 引入 Babylon.js 和 Havok -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    
    <style>
        /* ==================== 赛博朋克风格 UI ==================== */
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Rajdhani:wght@700&display=swap');

        html, body {
            overflow: hidden; width: 100%; height: 100%; margin: 0; padding: 0;
            background-color: #050505; font-family: 'Rajdhani', sans-serif;
        }

        #renderCanvas {
            width: 100%; height: 100%; touch-action: none; outline: none;
        }

        /* HUD 层 */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px; box-sizing: border-box;
        }

        .hud-top {
            display: flex; justify-content: space-between; align-items: flex-start;
        }

        .metric-box {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00ffcc;
            border-left: 8px solid #00ffcc;
            padding: 10px 20px;
            color: #fff;
            transform: skew(-10deg);
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
        }

        .metric-label { font-size: 14px; color: #00ffcc; text-transform: uppercase; letter-spacing: 2px; }
        .metric-value { font-family: 'Black Ops One', cursive; font-size: 36px; line-height: 1; }

        /* 破坏进度条 */
        #destruction-bar-container {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%) skew(-10deg);
            width: 500px; height: 30px; background: #222; border: 2px solid #ff0055;
        }
        #destruction-fill {
            width: 0%; height: 100%; background: linear-gradient(90deg, #ff0055, #ff9900);
            transition: width 0.1s;
        }
        #destruction-text {
            position: absolute; top: -30px; left: 0; width: 100%; text-align: center;
            color: #ff0055; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px #ff0055;
        }

        /* 游戏结束/开始 遮罩 */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(5px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            pointer-events: auto; z-index: 100;
        }
        
        h1 {
            font-family: 'Black Ops One', cursive; font-size: 80px; color: #ff0055;
            margin: 0; text-shadow: 4px 4px 0px #00ffcc; letter-spacing: 5px;
            text-transform: uppercase;
        }
        
        p { color: #ccc; font-size: 20px; max-width: 600px; text-align: center; margin-bottom: 40px; }

        .btn {
            background: #00ffcc; color: #000; border: none; padding: 15px 50px;
            font-family: 'Black Ops One', cursive; font-size: 24px; cursor: pointer;
            transform: skew(-10deg); transition: 0.2s;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
        }
        .btn:hover { background: #fff; transform: skew(-10deg) scale(1.1); }
        .hidden { display: none !important; }

    </style>
</head>
<body>

    <canvas id="renderCanvas"></canvas>

    <!-- UI 界面 -->
    <div id="hud" class="hidden">
        <div class="hud-top">
            <div class="metric-box">
                <div class="metric-label">Time</div>
                <div class="metric-value" id="ui-time">0.00</div>
            </div>
            <div class="metric-box" style="border-color: #ff9900; border-left-color: #ff9900;">
                <div class="metric-label">Speed</div>
                <div class="metric-value"><span id="ui-speed">0</span> KM/H</div>
            </div>
        </div>
        <div id="destruction-bar-container">
            <div id="destruction-text">DESTRUCTION: 0%</div>
            <div id="destruction-fill"></div>
        </div>
    </div>

    <!-- 开始/结束 菜单 -->
    <div id="overlay">
        <h1 id="title-text">SMASH CITY</h1>
        <p id="subtitle-text">MISSION: DESTROY 90% OF THE BUILDINGS<br>CONTROLS: WASD to Drive | SPACE to Brake | SHIFT for NITRO | V to Toggle Camera</p>
        <button class="btn" onclick="startGame()">START ENGINE</button>
    </div>

    <script>
const canvas = document.getElementById("renderCanvas");

/* ===================== 全局 ===================== */
let engine, scene, havokInstance;
let carBody, carMesh, camera;
let tyreMaterial;
let allWheels = [], allAxles = [];

let isGameActive = false;
let startTime = 0;
let totalBricksCount = 0;
let destroyedCount = 0;
let bricksArray = [];

const inputMap = {};
let currentSpeed = 0;
let currentSteeringAngle = 0;
const maxSpeed = 180;
const maxSteeringAngle = Math.PI / 6;

const FILTERS = { CarParts: 1, Environment: 2 };

/* ===================== UI ===================== */
const uiTime = document.getElementById('ui-time');
const uiSpeed = document.getElementById('ui-speed');
const uiDestruction = document.getElementById('destruction-fill');
const uiDestructionText = document.getElementById('destruction-text');

/* ===================== 物理 & 引擎 ===================== */
async function init() {
    const hk = await HavokPhysics();
    havokInstance = new BABYLON.HavokPlugin(false, hk);

    engine = new BABYLON.Engine(canvas, true);
    scene = createScene();

    engine.runRenderLoop(() => {
        scene.render();
        if (isGameActive) updateGameLogic();
    });

    window.addEventListener("resize", () => engine.resize());

    scene.onKeyboardObservable.add(kb => {
        const k = kb.event.key.toLowerCase();
        inputMap[k] = kb.type === BABYLON.KeyboardEventTypes.KEYDOWN;
        if (k === 'r' && carBody) resetCar();
    });
}

/* ===================== Instancing 核心 ===================== */
let brickRoot;
function initInstancing(scene) {
    const mat = new BABYLON.StandardMaterial("brickMat", scene);
    mat.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.9);
    mat.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.15);

    brickRoot = BABYLON.MeshBuilder.CreateBox("brickRoot", { size: 1.98 }, scene);
    brickRoot.material = mat;
    brickRoot.isVisible = false;
}

function createPhysicsBrick(pos, scene) {
    const inst = brickRoot.createInstance("b_" + bricksArray.length);
    inst.position.copyFrom(pos);

    const agg = new BABYLON.PhysicsAggregate(
        inst,
        BABYLON.PhysicsShapeType.BOX,
        { mass: 5, restitution: 0.1, friction: 0.8 },
        scene
    );
    agg.body.shape.filterMembershipMask = FILTERS.Environment;

    inst.metadata = { originalY: pos.y, isDestroyed: false };
    bricksArray.push({ mesh: inst });
    totalBricksCount++;
}

/* ===================== 建筑体系（你的） ===================== */
function createSkyscraper(pos, w, h, d, scene) {
    const s = 2;
    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            for (let z = 0; z < d; z++) {
                const wall = x === 0 || x === w - 1 || z === 0 || z === d - 1;
                const floor = y % 5 === 0;
                if (wall || (floor && x % 2 === 0 && z % 2 === 0)) {
                    createPhysicsBrick(
                        new BABYLON.Vector3(
                            pos.x + x * s - (w * s) / 2,
                            pos.y + y * s + 1,
                            pos.z + z * s - (d * s) / 2
                        ),
                        scene
                    );
                }
            }
        }
    }
}

function createTwistTower(pos, size, h, scene) {
    const s = 2;
    for (let y = 0; y < h; y++) {
        const a = y * 0.08;
        for (let x = 0; x < size; x++) {
            for (let z = 0; z < size; z++) {
                if (x === 0 || z === 0 || x === size - 1 || z === size - 1) {
                    const rx = (x - size / 2) * Math.cos(a) - (z - size / 2) * Math.sin(a);
                    const rz = (x - size / 2) * Math.sin(a) + (z - size / 2) * Math.cos(a);
                    createPhysicsBrick(
                        new BABYLON.Vector3(pos.x + rx * s, pos.y + y * s + 1, pos.z + rz * s),
                        scene
                    );
                }
            }
        }
    }
}

function createMegaGate(pos, w, h, t, scene) {
    const s = 2;
    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            for (let z = 0; z < t; z++) {
                const pillar = x < 4 || x > w - 5;
                const top = y > h - 6;
                if (pillar || top) {
                    if (x === 0 || x === w - 1 || z === 0 || z === t - 1 || top) {
                        createPhysicsBrick(
                            new BABYLON.Vector3(
                                pos.x + x * s - (w * s) / 2,
                                pos.y + y * s + 1,
                                pos.z + z * s
                            ),
                            scene
                        );
                    }
                }
            }
        }
    }
}

function createStepPyramid(pos, base, h, scene) {
    const s = 2;
    for (let y = 0; y < h; y++) {
        const size = base - Math.floor(y / 2);
        if (size <= 2) break;
        for (let x = 0; x < size; x++) {
            for (let z = 0; z < size; z++) {
                if (x === 0 || z === 0 || x === size - 1 || z === size - 1 || y % 4 === 0) {
                    createPhysicsBrick(
                        new BABYLON.Vector3(
                            pos.x + x * s - (size * s) / 2,
                            pos.y + y * s + 1,
                            pos.z + z * s - (size * s) / 2
                        ),
                        scene
                    );
                }
            }
        }
    }
}

function createArena(pos, r, h, scene) {
    const s = 2;
    const seg = r * 4;
    for (let y = 0; y < h; y++) {
        const rr = r + y * 0.2;
        for (let i = 0; i < seg; i++) {
            const a = (i / seg) * Math.PI * 2;
            createPhysicsBrick(
                new BABYLON.Vector3(
                    pos.x + Math.cos(a) * rr * s,
                    pos.y + y * s + 1,
                    pos.z + Math.sin(a) * rr * s
                ),
                scene
            );
        }
    }
}

function spawnMegaCity(scene) {
    createMegaGate(new BABYLON.Vector3(0, 0, 80), 30, 25, 6, scene);

    createSkyscraper(new BABYLON.Vector3(60, 0, 40), 8, 40, 8, scene);
    createSkyscraper(new BABYLON.Vector3(-60, 0, 40), 8, 40, 8, scene);

    createTwistTower(new BABYLON.Vector3(120, 0, 80), 6, 35, scene);
    createTwistTower(new BABYLON.Vector3(-120, 0, 80), 6, 35, scene);

    createStepPyramid(new BABYLON.Vector3(0, 0, 200), 20, 30, scene);
    createArena(new BABYLON.Vector3(0, 0, -120), 15, 10, scene);
}

/* ===================== Scene ===================== */
function createScene() {
    const scene = new BABYLON.Scene(engine);
    scene.enablePhysics(new BABYLON.Vector3(0, -240, 0), havokInstance);

    const light = new BABYLON.HemisphericLight("h", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.8;

    const ground = BABYLON.MeshBuilder.CreateGround("g", { width: 600, height: 600 }, scene);
    new BABYLON.PhysicsAggregate(ground, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

    initInstancing(scene);
    spawnMegaCity(scene);

    camera = new BABYLON.FollowCamera("cam", new BABYLON.Vector3(0, 15, -30), scene);
    scene.activeCamera = camera;

    createPlayerCar(new BABYLON.Vector3(0, 5, -60));
    return scene;
}

/* ===================== 破坏统计 ===================== */
function updateGameLogic() {
    uiTime.innerText = ((Date.now() - startTime) / 1000).toFixed(2);
    destroyedCount = 0;

    bricksArray.forEach(b => {
        if (Math.abs(b.mesh.position.y - b.mesh.metadata.originalY) > 2) {
            b.mesh.metadata.isDestroyed = true;
            destroyedCount++;
        }
    });

    const p = Math.min(100, destroyedCount / totalBricksCount * 100);
    uiDestruction.style.width = p + "%";
    uiDestructionText.innerText = `DESTRUCTION: ${Math.floor(p)}%`;
}

/* ===================== 启动 ===================== */
function startGame() {
    document.getElementById('overlay').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');
    startTime = Date.now();
    isGameActive = true;
}

init();
</script>

</body>
</html>
