<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Babylon GTA - Full Beast Mode</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
        #ui { position: absolute; top: 20px; left: 20px; color: #0f0; background: rgba(0,0,0,0.7); padding: 15px; border: 1px solid #0f0; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <b>[SYSTEM ACTIVE]</b><br>
        - WALK: WASD | RUN: Shift<br>
        - VEHICLE: F (Enter/Exit)<br>
        - DRIVE: WASD + SPACE (Brake)
    </div>
    <canvas id="renderCanvas"></canvas>

<script>
/**
 * ============================================================
 * üõ†Ô∏è Áâ©ÁêÜ‰∏éÁéØÂ¢ÉÈÖçÁΩÆ (Havok Engine)
 * ============================================================
 */
async function initEngine() {
    const hkWasm = await HavokPhysics();
    const havok = new BABYLON.HavokPlugin(true, hkWasm);
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);

    // ÈíàÂØπÈ´òÈÄüÁâ©‰ΩìÁöÑÂÖ®ÁêÉÁâ©ÁêÜËÆæÂÆö
    scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), havok);
    const physicsEngine = scene.getPhysicsEngine();
    physicsEngine.setTimeStep(1 / 120); // ÊèêÈ´òÁâ©ÁêÜÈ¢ëÁéá
    physicsEngine.setSubTimeStep(10);   // ‰∫öÊ≠•Â¢ûÂä†ÔºåÂΩªÂ∫ïÂëäÂà´Á©øÊ®°

    return { engine, scene, canvas };
}

/**
 * ============================================================
 * üèéÔ∏è ËΩΩÂÖ∑Ê®°Âùó (Vehicle Class) - ÈõÜÊàê Ackermann ËΩ¨Âêë
 * ============================================================
 */
class Vehicle {
    constructor(scene, position) {
        this.scene = scene;
        this.isOccupied = false;
        this.steerJoints = [];
        this.motors = [];
        this.wheelMeshes = [];

        // 1. Â∫ïÁõò (Chassis)
        this.mesh = BABYLON.MeshBuilder.CreateBox("chassis", { width: 6, height: 1.5, depth: 14 }, scene);
        this.mesh.position = position;
        this.body = new BABYLON.PhysicsBody(this.mesh, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
        this.body.shape = new BABYLON.PhysicsShapeBox(BABYLON.Vector3.Zero(), BABYLON.Quaternion.Identity(), new BABYLON.Vector3(6, 1.5, 14), scene);
        this.body.setMassProperties({ mass: 1800, centerOfMass: new BABYLON.Vector3(0, -0.5, 0) }); // ÈáçÂøÉ‰∏ãÁßªÔºåÈò≤Ê≠¢ÁøªËΩ¶

        // 2. ÂàùÂßãÂåñËΩÆËΩ¥ (Axles & Wheels)
        this._buildVehicleSystem();
    }

    _buildVehicleSystem() {
        const wheelData = [
            { name: "fl", pos: new BABYLON.Vector3(3, -0.8, 5), steer: true, drive: true, side: "left" },
            { name: "fr", pos: new BABYLON.Vector3(-3, -0.8, 5), steer: true, drive: true, side: "right" },
            { name: "rl", pos: new BABYLON.Vector3(3, -0.8, -5), steer: false, drive: true, side: "left" },
            { name: "rr", pos: new BABYLON.Vector3(-3, -0.8, -5), steer: false, drive: true, side: "right" }
        ];

        wheelData.forEach(w => {
            // ËΩ¥ (Axle Node)
            const axle = BABYLON.MeshBuilder.CreateBox(w.name + "_axle", { size: 0.4 }, this.scene);
            axle.position = this.mesh.position.add(w.pos);
            const axleBody = new BABYLON.PhysicsBody(axle, BABYLON.PhysicsMotionType.DYNAMIC, false, this.scene);
            axleBody.shape = new BABYLON.PhysicsShapeBox(BABYLON.Vector3.Zero(), BABYLON.Quaternion.Identity(), new BABYLON.Vector3(0.4, 0.4, 0.4), this.scene);
            axleBody.setMassProperties({ mass: 40 });

            // ËΩÆÂ≠ê (Visual)
            const wheel = BABYLON.MeshBuilder.CreateCylinder(w.name + "_wheel", { diameter: 3, height: 1.2 }, this.scene);
            wheel.rotation.z = Math.PI / 2;
            wheel.bakeCurrentTransformIntoVertices();
            wheel.position = axle.position;
            const wheelBody = new BABYLON.PhysicsBody(wheel, BABYLON.PhysicsMotionType.DYNAMIC, false, this.scene);
            wheelBody.shape = new BABYLON.PhysicsShapeCylinder(new BABYLON.Vector3(-0.6, 0, 0), new BABYLON.Vector3(0.6, 0, 0), 1.5, this.scene);
            wheelBody.shape.material = { friction: 1.8, restitution: 0.1 };
            wheelBody.setMassProperties({ mass: 120 });
            this.wheelMeshes.push(wheel);

            // Á∫¶Êùü A: ËΩ¥ËøûÊé•Âà∞Â∫ïÁõò (6DoF - ÊÇ¨Êû∂ + ËΩ¨Âêë)
            const suspension = new BABYLON.Physics6DoFConstraint({
                pivotA: w.pos, pivotB: BABYLON.Vector3.Zero(),
            }, [
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_Y, minLimit: -0.4, maxLimit: 0.4, stiffness: 60000, damping: 2500 },
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_X, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_Z, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Y, minLimit: w.steer ? -0.6 : 0, maxLimit: w.steer ? 0.6 : 0 },
            ], this.scene);
            this.body.addConstraint(axleBody, suspension);

            // Á∫¶Êùü B: ËΩÆÂ≠êËøûÊé•Âà∞ËΩ¥ (È©±Âä®)
            const driveJoint = new BABYLON.Physics6DoFConstraint({
                pivotA: BABYLON.Vector3.Zero(), pivotB: BABYLON.Vector3.Zero(),
            }, [
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_DISTANCE, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Y, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Z, minLimit: 0, maxLimit: 0 },
            ], this.scene);
            axleBody.addConstraint(wheelBody, driveJoint);

            if (w.steer) {
                suspension.setAxisMotorType(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, BABYLON.PhysicsConstraintMotorType.POSITION);
                suspension.setAxisMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, 2000000);
                this.steerJoints.push({ joint: suspension, side: w.side });
            }
            if (w.drive) {
                driveJoint.setAxisMotorType(BABYLON.PhysicsConstraintAxis.ANGULAR_X, BABYLON.PhysicsConstraintMotorType.VELOCITY);
                driveJoint.setAxisMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_X, 800000);
                this.motors.push(driveJoint);
            }
        });
    }

    // Ackermann ËΩ¨ÂêëÊï∞Â≠¶ÂÖ¨ÂºèÂÆûÁé∞
    _calculateAckermann(avgAngle) {
        if (Math.abs(avgAngle) < 0.01) return { left: 0, right: 0 };
        const wheelbase = 10; // ÂâçÂêéËΩ¥Ë∑ù
        const trackWidth = 6; // Â∑¶Âè≥ËΩÆË∑ù
        const radius = wheelbase / Math.tan(avgAngle);
        const angleLeft = Math.atan(wheelbase / (radius + trackWidth / 2));
        const angleRight = Math.atan(wheelbase / (radius - trackWidth / 2));
        return { left: angleLeft, right: angleRight };
    }

    update(keys) {
        if (!this.isOccupied) {
            this.motors.forEach(m => m.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_X, 0));
            return;
        }

        // È©±Âä®ÈÄªËæë
        let targetSpeed = 0;
        if (keys.isPressed("w")) targetSpeed = 120;
        if (keys.isPressed("s")) targetSpeed = -60;
        if (keys.isPressed(" ")) targetSpeed = 0;
        this.motors.forEach(m => m.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_X, targetSpeed));

        // ËΩ¨ÂêëÈÄªËæë (Ackermann)
        let targetSteer = 0;
        if (keys.isPressed("a")) targetSteer = 0.5;
        if (keys.isPressed("d")) targetSteer = -0.5;
        const angles = this._calculateAckermann(targetSteer);
        this.steerJoints.forEach(s => {
            const angle = s.side === "left" ? angles.left : angles.right;
            s.joint.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, angle);
        });
    }
}

/**
 * ============================================================
 * üèÉ ËßíËâ≤Ê®°Âùó (Player Class) - Â∏¶ÊñπÂêëÊúùÂêë‰∏é‰∏äËΩ¶‰∫§‰∫í
 * ============================================================
 */
class Player {
    constructor(scene, position) {
        this.scene = scene;
        this.mesh = BABYLON.MeshBuilder.CreateCapsule("player", { height: 4, radius: 1 }, scene);
        this.mesh.position = position;
        this.body = new BABYLON.PhysicsBody(this.mesh, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
        this.body.shape = new BABYLON.PhysicsShapeCapsule(new BABYLON.Vector3(0, -1, 0), new BABYLON.Vector3(0, 1, 0), 1, scene);
        this.body.setMassProperties({ mass: 80, centerOfMass: BABYLON.Vector3.Zero(), inertia: BABYLON.Vector3.Zero() }); // Èò≤Ê≠¢ÊëîÂÄí
        this.body.setLinearDamping(0.8);
        this.body.setAngularDamping(1.0);
        
        this.state = "walking"; // walking | driving
    }

    update(keys, vehicle) {
        if (this.state === "walking") {
            const moveVec = new BABYLON.Vector3(0, 0, 0);
            const speed = keys.isPressed("shift") ? 1800 : 900;

            if (keys.isPressed("w")) moveVec.z = speed;
            if (keys.isPressed("s")) moveVec.z = -speed;
            if (keys.isPressed("a")) moveVec.x = -speed;
            if (keys.isPressed("d")) moveVec.x = speed;

            if (moveVec.length() > 0) {
                this.body.applyForce(moveVec, this.mesh.getAbsolutePosition());
                // ËΩ¨ÂêëÁßªÂä®ÊñπÂêë
                const targetRotation = Math.atan2(moveVec.x, moveVec.z);
                this.mesh.rotation.y = BABYLON.Scalar.LerpAngle(this.mesh.rotation.y, targetRotation, 0.1);
            }

            if (keys.isPressed("f")) {
                if (BABYLON.Vector3.Distance(this.mesh.position, vehicle.mesh.position) < 10) {
                    this.enter(vehicle);
                }
            }
        } else {
            // Âú®ËΩ¶ÈáåÔºåÂº∫Ë°åÂêåÊ≠•‰ΩçÁΩÆ
            this.mesh.position.copyFrom(vehicle.mesh.position);
            if (keys.isPressed("f")) this.exit(vehicle);
        }
    }

    enter(v) {
        this.state = "driving";
        v.isOccupied = true;
        this.mesh.isVisible = false;
        this.body.setMotionType(BABYLON.PhysicsMotionType.ANIMATED);
    }

    exit(v) {
        this.state = "walking";
        v.isOccupied = false;
        this.mesh.isVisible = true;
        this.body.setMotionType(BABYLON.PhysicsMotionType.DYNAMIC);
        this.mesh.position = v.mesh.position.add(new BABYLON.Vector3(8, 2, 0));
    }
}

/**
 * ============================================================
 * üéÆ ‰∏ªÁ®ãÂ∫èÂÖ•Âè£ (Main Loop)
 * ============================================================
 */
async function start() {
    const { engine, scene } = await initEngine();
    const input = {
        _keys: {},
        isPressed(k) { return this._keys[k.toLowerCase()] || false; }
    };
    scene.onKeyboardObservable.add(kb => {
        input._keys[kb.event.key.toLowerCase()] = kb.type === BABYLON.KeyboardEventTypes.KEYDOWN;
    });

    // ÁéØÂ¢É
    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 2000, height: 2000 }, scene);
    const groundBody = new BABYLON.PhysicsBody(ground, BABYLON.PhysicsMotionType.STATIC, false, scene);
    groundBody.shape = new BABYLON.PhysicsShapeMesh(ground, scene);
    groundBody.shape.material = { friction: 1.0, restitution: 0.1 };

    // ÂÆû‰æãÂåñÂØπË±°
    const myCar = new Vehicle(scene, new BABYLON.Vector3(0, 5, 30));
    const player = new Player(scene, new BABYLON.Vector3(0, 5, 0));

    // Áõ∏Êú∫ (GTA È£éÊ†ºÂπ≥ÊªëË∑üÈöè)
    const camera = new BABYLON.FollowCamera("gtaCam", new BABYLON.Vector3(0, 15, -30), scene);
    camera.radius = 40;
    camera.heightOffset = 15;
    camera.cameraAcceleration = 0.05;
    camera.maxCameraSpeed = 100;
    scene.activeCamera = camera;

    scene.onBeforeRenderObservable.add(() => {
        player.update(input, myCar);
        myCar.update(input);
        camera.lockedTarget = player.state === "walking" ? player.mesh : myCar.mesh;
    });

    engine.runRenderLoop(() => scene.render());
    window.addEventListener("resize", () => engine.resize());
}

start();
</script>
</body>
</html>
