<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>OPEN WORLD HYPER DRIVE (Babylon.js Ver.)</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Rajdhani', sans-serif; color: #E0FFFF; user-select: none; outline: none; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; outline: none; }
        
        /* ... 此处省略重复的 CSS，为了节省你的阅读空间 ... */
        /* ... 请直接复用你原文件中从 #hud-layer 到 .menu-page 的所有样式 ... */
        
        /* 为了演示方便，我在这里补充关键的 UI 样式，实际使用时请把原 CSS 全部贴回来 */
        #hud-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 30px; box-sizing: border-box; z-index: 10; }
        .hud-top-left { display: flex; gap: 20px; flex-wrap: wrap; }
        .instrument { background: rgba(0, 15, 30, 0.7); border: 1px solid rgba(0, 255, 255, 0.2); border-left: 5px solid #00FFFF; padding: 12px 22px; min-width: 120px; border-radius: 4px; color: white;}
        .label { font-family: 'Orbitron'; font-size: 10px; color: #00FFFF; display:block; }
        .value { font-family: 'Orbitron'; font-size: 36px; font-weight: 900; }
        #loading-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; color: #00FFFF; z-index: 1000; display: flex; flex-direction: column; align-items: center; justify-content: center; }
    </style>
</head>
<body>

    <div id="loading-screen">
        <h2 style="font-family:'Orbitron'">SYSTEM INITIALIZING</h2>
        <p>BABYLON.JS ENGINE STARTING...</p>
    </div>

    <div id="hud-layer" style="display:none;">
        <div class="hud-top-left">
            <div class="instrument"><span class="label">Speed</span> <span class="value" id="hud-spd">0</span></div>
            <div class="instrument"><span class="label">RPM</span> <span class="value" id="hud-rpm">0</span></div>
            <div class="instrument"><span class="label">Gear</span> <span class="value" id="hud-gear">P</span></div>
        </div>
        <div style="position: absolute; bottom: 30px; left: 30px; color: #aaa;">
            [WASD] Drive | [SPACE] Brake | [V] Camera | [R] Reset | [I] Debug Layer
        </div>
    </div>

    <canvas id="renderCanvas"></canvas>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

    <script>
        // =============================================================================
        // ** GLOBAL VARIABLES **
        // =============================================================================
        const canvas = document.getElementById("renderCanvas");
        let engine, scene;
        let vehicle, chassisBody;
        let wheelMeshes = [];
        let physicsWorld; // Cannon 原生 World 引用
        
        // 游戏状态
        let isGameRunning = false;
        let inputMap = {};
        
        // UI 元素
        const uiElements = {
            speed: document.getElementById('hud-spd'),
            rpm: document.getElementById('hud-rpm'),
            gear: document.getElementById('hud-gear'),
            loading: document.getElementById('loading-screen'),
            hud: document.getElementById('hud-layer')
        };

        // 车辆参数 (复用你原本的调教)
        const vehicleSettings = {
            chassisMass: 2500,
            engineForce: 9000,
            brakeForce: 40,
            maxSteer: 0.7
        };

        // =============================================================================
        // ** INITIALIZATION **
        // =============================================================================
        
        const createScene = async function () {
            // 1. 创建 Babylon 场景
            const scene = new BABYLON.Scene(engine);
            
            // 2. 物理引擎初始化 (桥接 Cannon)
            const gravityVector = new BABYLON.Vector3(0, -9.82, 0);
            const physicsPlugin = new BABYLON.CannonJSPlugin(true, 10, CANNON);
            scene.enablePhysics(gravityVector, physicsPlugin);
            physicsWorld = physicsPlugin.world; // 获取底层的 Cannon World，以便使用 RaycastVehicle

            // 优化：针对高速运动调整 Cannon 的宽相检测
            physicsWorld.broadphase = new CANNON.SAPBroadphase(physicsWorld);
            physicsWorld.defaultContactMaterial.friction = 0.8;

            // 3. 摄像机与环境
            // 追尾视角 (Follow Camera) - Babylon 内置了这种极其好用的摄像机
            const camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI/2, Math.PI/3, 15, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            
            // 灯光
            const hemiLight = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
            hemiLight.intensity = 0.6;
            
            const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(50, -100, 50), scene);
            dirLight.position = new BABYLON.Vector3(-50, 100, -50);
            dirLight.intensity = 0.8;
            
            // 阴影生成器 (Babylon 的阴影设置非常简单)
            const shadowGenerator = new BABYLON.ShadowGenerator(2048, dirLight);
            shadowGenerator.useBlurExponentialShadowMap = true;

            // 4. 创建环境 (地面)
            const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 3000, height: 3000}, scene);
            const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            ground.material = groundMat;
            ground.receiveShadows = true;
            
            // 赋予地面物理属性
            ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.5, restitution: 0.1 }, scene);

            // 5. 调试工具 (按 I 开启)
            // Babylon 最强大的功能！
            scene.actionManager = new BABYLON.ActionManager(scene);
            scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
                { trigger: BABYLON.ActionManager.OnKeyUpTrigger, parameter: 'i' },
                () => {
                    if (scene.debugLayer.isVisible()) scene.debugLayer.hide();
                    else scene.debugLayer.show();
                }
            ));

            return { scene, shadowGenerator, camera };
        };

        // =============================================================================
        // ** VEHICLE LOGIC (Babylon Mesh + Cannon Physics) **
        // =============================================================================
        
        function createVehicle(scene, shadowGenerator, camera) {
            // --- 1. 视觉模型 (Mesh) ---
            // 注意：如果你有 GLB，用 SceneLoader.ImportMeshAsync 替换这里
            
            // 临时替代车身 (红色方块)
            const chassisMesh = BABYLON.MeshBuilder.CreateBox("chassis", {width: 2.2, height: 1.0, depth: 4.5}, scene);
            const carMat = new BABYLON.StandardMaterial("carMat", scene);
            carMat.diffuseColor = new BABYLON.Color3(0, 0.8, 1); // Cyan
            chassisMesh.material = carMat;
            shadowGenerator.addShadowCaster(chassisMesh);
            
            // --- 2. 物理身体 (Cannon Body) ---
            // 我们手动创建 Cannon Body，就像你在 Three.js 里做的一样
            const chassisShape = new CANNON.Box(new CANNON.Vec3(1.1, 0.5, 2.25));
            chassisBody = new CANNON.Body({ mass: vehicleSettings.chassisMass });
            chassisBody.addShape(chassisShape);
            chassisBody.position.set(0, 5, 0); // 初始位置
            chassisBody.angularDamping = 0.5;
            
            // 关键：将 Cannon Body 链接到 Babylon Mesh
            // Babylon 允许自定义物理链接，这样 Mesh 就会自动跟随物理体移动
            chassisMesh.physicsImpostor = new BABYLON.PhysicsImpostor(chassisMesh, BABYLON.PhysicsImpostor.NoImpostor, { mass: 0 }, scene);
            chassisMesh.physicsImpostor.setParam("body", chassisBody); // 强行绑定原本的 Body
            physicsWorld.addBody(chassisBody);

            // --- 3. 射线车辆配置 (RaycastVehicle) ---
            vehicle = new CANNON.RaycastVehicle({
                chassisBody: chassisBody,
            });

            const wheelOptions = {
                radius: 0.5,
                directionLocal: new CANNON.Vec3(0, -1, 0),
                suspensionStiffness: 30,
                suspensionRestLength: 0.3,
                frictionSlip: 5,
                dampingRelaxation: 2.3,
                dampingCompression: 4.4,
                maxSuspensionForce: 100000,
                rollInfluence: 0.01,
                axleLocal: new CANNON.Vec3(1, 0, 0),
                chassisConnectionPointLocal: new CANNON.Vec3(0, 0, 0),
                maxSuspensionTravel: 0.3,
                customSlidingRotationalSpeed: -30,
                useCustomSlidingRotationalSpeed: true
            };

            // 添加车轮
            const axleWidth = 1.0;
            const wheelDepth = 1.5;
            const height = -0.5;

            // Front Left
            wheelOptions.chassisConnectionPointLocal.set(axleWidth, height, wheelDepth);
            vehicle.addWheel(wheelOptions);
            // Front Right
            wheelOptions.chassisConnectionPointLocal.set(-axleWidth, height, wheelDepth);
            vehicle.addWheel(wheelOptions);
            // Rear Left
            wheelOptions.chassisConnectionPointLocal.set(axleWidth, height, -wheelDepth);
            vehicle.addWheel(wheelOptions);
            // Rear Right
            wheelOptions.chassisConnectionPointLocal.set(-axleWidth, height, -wheelDepth);
            vehicle.addWheel(wheelOptions);

            vehicle.addToWorld(physicsWorld);

            // --- 4. 车轮视觉模型 ---
            const wheelInputs = vehicle.wheelInfos;
            for (let i = 0; i < wheelInputs.length; i++) {
                // 临时车轮 (圆柱)
                const wheelMesh = BABYLON.MeshBuilder.CreateCylinder("wheel"+i, {diameter: 1, height: 0.4, tessellation: 24}, scene);
                wheelMesh.rotation.z = Math.PI / 2; // 旋转圆柱使其像轮子
                const wheelMat = new BABYLON.StandardMaterial("wheelMat", scene);
                wheelMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                wheelMesh.material = wheelMat;
                shadowGenerator.addShadowCaster(wheelMesh);
                
                // 车轮因为要跟随物理骨骼，我们这里做一个 parent 容器来处理旋转
                // 但简单起见，我们在 update 循环里手动同步车轮位置
                wheelMeshes.push(wheelMesh);
            }
            
            // --- 5. 绑定摄像机逻辑 ---
            scene.registerBeforeRender(() => {
                // 摄像机平滑跟随
                const carPos = chassisMesh.position;
                // 简单的跟随逻辑
                camera.target = carPos;
                // 注意：如果要硬核的追尾视角，可以在这里计算 lerp
            });
            
            return chassisMesh;
        }

        // =============================================================================
        // ** GAME LOOP & INPUT **
        // =============================================================================
        
        async function initGame() {
            engine = new BABYLON.Engine(canvas, true);
            const { scene: _scene, shadowGenerator, camera } = await createScene();
            scene = _scene;

            // 监听键盘
            scene.onKeyboardObservable.add((kbInfo) => {
                const key = kbInfo.event.key.toLowerCase();
                const isDown = kbInfo.type === BABYLON.KeyboardEventTypes.KEYDOWN;
                inputMap[key] = isDown;
                
                // 重置车辆
                if (key === 'r' && isDown) respawnCar();
            });

            // 创建车辆
            const carMesh = createVehicle(scene, shadowGenerator, camera);

            // 隐藏 Loading
            uiElements.loading.style.display = 'none';
            uiElements.hud.style.display = 'flex';
            isGameRunning = true;

            // --- 核心循环 (Render Loop) ---
            scene.registerBeforeRender(() => {
                if (!vehicle) return;

                // 1. 物理控制
                let force = 0;
                let steer = 0;
                let brake = 0;

                if (inputMap["w"]) force = -vehicleSettings.engineForce;
                if (inputMap["s"]) force = vehicleSettings.engineForce * 0.5;
                
                if (inputMap["a"]) steer = vehicleSettings.maxSteer;
                if (inputMap["d"]) steer = -vehicleSettings.maxSteer;
                
                if (inputMap[" "]) brake = vehicleSettings.brakeForce;

                vehicle.applyEngineForce(force, 0);
                vehicle.applyEngineForce(force, 1);
                vehicle.applyEngineForce(force, 2); // 四驱
                vehicle.applyEngineForce(force, 3);
                
                vehicle.setSteeringValue(steer, 0);
                vehicle.setSteeringValue(steer, 1);
                
                vehicle.setBrake(brake, 0);
                vehicle.setBrake(brake, 1);
                vehicle.setBrake(brake, 2);
                vehicle.setBrake(brake, 3);

                // 2. 车轮位置同步 (Cannon -> Babylon)
                for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                    vehicle.updateWheelTransform(i);
                    const t = vehicle.wheelInfos[i].worldTransform;
                    
                    // 同步位置
                    wheelMeshes[i].position.set(t.position.x, t.position.y, t.position.z);
                    // 同步旋转 (Cannon 的 Quaternion -> Babylon Quaternion)
                    wheelMeshes[i].rotationQuaternion = new BABYLON.Quaternion(t.quaternion.x, t.quaternion.y, t.quaternion.z, t.quaternion.w);
                    
                    // 修正圆柱体的原生旋转问题 (如果用 GLB 轮胎则不需要这步)
                    wheelMeshes[i].rotate(BABYLON.Axis.Z, Math.PI/2, BABYLON.Space.LOCAL);
                }

                // 3. UI 更新
                const speedKmh = chassisBody.velocity.norm() * 3.6;
                uiElements.speed.textContent = Math.floor(speedKmh);
                uiElements.rpm.textContent = Math.floor(speedKmh * 30); // 假 RPM
                
                // 档位逻辑
                if (force < 0) uiElements.gear.textContent = 'D';
                else if (force > 0) uiElements.gear.textContent = 'R';
                else uiElements.gear.textContent = 'P';
                
            });

            engine.runRenderLoop(() => {
                scene.render();
            });

            window.addEventListener("resize", () => {
                engine.resize();
            });
        }
        
        function respawnCar() {
            if(!chassisBody) return;
            chassisBody.position.set(0, 5, 0);
            chassisBody.velocity.set(0,0,0);
            chassisBody.angularVelocity.set(0,0,0);
            chassisBody.quaternion.set(0,0,0,1);
        }

        // 启动！
        initGame();

    </script>
</body>
</html>
