<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Havok Mega Destruction & Ramp Test</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        const canvas = document.getElementById("renderCanvas");
        let scene, havokInstance, tyreMaterial;
        const debugColours = [];
        debugColours[0] = new BABYLON.Color4(1, 0, 1, 1);
        debugColours[1] = new BABYLON.Color4(1, 0, 0, 1);
        debugColours[2] = new BABYLON.Color4(0, 1, 0, 1);
        debugColours[3] = new BABYLON.Color4(1, 1, 0, 1);
        debugColours[4] = new BABYLON.Color4(0, 1, 1, 1);
        debugColours[5] = new BABYLON.Color4(0, 0, 1, 1);
        
        const FILTERS = { CarParts: 1, Environment: 2 };

        async function init() {
            const hkWasm = await HavokPhysics();
            havokInstance = new BABYLON.HavokPlugin(false, hkWasm);
            await createScene();
        }

        async function createScene() {
            const engine = new BABYLON.Engine(canvas, true);
            scene = new BABYLON.Scene(engine);

            // 物理参数：高重力，高子步长确保碰撞不穿透
            scene.enablePhysics(new BABYLON.Vector3(0, -240, 0), havokInstance);
            scene.getPhysicsEngine().setTimeStep(1 / 500);
            scene.getPhysicsEngine().setSubTimeStep(4);

            const camera = new BABYLON.FollowCamera("FollowCam", new BABYLON.Vector3(0, 20, -30), scene);
            camera.radius = 60;
            camera.heightOffset = 25;
            camera.rotationOffset = 180;
            camera.cameraAcceleration = 0.05;
            camera.maxCameraSpeed = 20;

            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);
            light.intensity = 0.8;

            InitTyreMaterial();
            CreateGroundAndWalls();
            
            const car1 = CreateCar(); 
            const car2 = CreateSecondCar(new BABYLON.Vector3(50, 0.3, 0)); 
            
            camera.lockedTarget = car1;

            engine.runRenderLoop(() => {
                if (scene && scene.activeCamera) {
                    scene.render();
                }
            });

            window.addEventListener('resize', () => engine.resize());
        }

        function CreateCar() {
            const carFrame = BABYLON.MeshBuilder.CreateBox("Frame", { height: 1.5, width: 12, depth: 24, faceColors: debugColours });
            carFrame.position = new BABYLON.Vector3(0, 5, 0);
            const carFrameBody = AddDynamicPhysics(carFrame, 1500, 0.1, 0.5);
            FilterMeshCollisions(carFrame);

            const wheels = [
                {p: new BABYLON.Vector3(6, 0, 9), steer: true},
                {p: new BABYLON.Vector3(-6, 0, 9), steer: true},
                {p: new BABYLON.Vector3(6, 0, -9), steer: false},
                {p: new BABYLON.Vector3(-6, 0, -9), steer: false}
            ];

            let motors = [];
            let steerer = [];

            wheels.forEach((w, i) => {
                const wheel = CreateWheel(w.p);
                const axle = CreateAxle(w.p);
                carFrame.addChild(axle);
                AddAxlePhysics(axle, 150, 0, 0);
                AddWheelPhysics(wheel, 200, 0.2, 80);
                FilterMeshCollisions(axle);
                FilterMeshCollisions(wheel);

                if(w.steer) {
                    const joint = AttachAxleToFrame(axle.physicsBody, carFrameBody, true);
                    const motor = CreatePoweredWheelJoint(axle, wheel);
                    motors.push(motor);
                    steerer.push(joint);
                } else {
                    AttachAxleToFrame(axle.physicsBody, carFrameBody, false);
                    CreateWheelJoint(axle, wheel);
                }
            });

            InitKeyboardControls(motors[0], motors[1], steerer[0], steerer[1]);
            return carFrame;
        }

        function CreateSecondCar(position) {
            const carFrame = BABYLON.MeshBuilder.CreateBox("Frame2", { height: 1.5, width: 12, depth: 24, faceColors: debugColours });
            carFrame.position = position;
            const carFrameBody = AddDynamicPhysics(carFrame, 1500, 0.1, 0.5);
            FilterMeshCollisions(carFrame);

            const wheelConfigs = [new BABYLON.Vector3(6, 0, 9), new BABYLON.Vector3(-6, 0, 9), new BABYLON.Vector3(6, 0, -9), new BABYLON.Vector3(-6, 0, -9)];
            let motors = [];
            let steerer = [];

            wheelConfigs.forEach((p, i) => {
                const wM = CreateWheel(position.add(p));
                const aM = CreateAxle(position.add(p));
                carFrame.addChild(aM);
                AddAxlePhysics(aM, 150, 0, 0);
                AddWheelPhysics(wM, 200, 0.2, 80);
                FilterMeshCollisions(aM);
                FilterMeshCollisions(wM);
                
                if(i < 2) {
                    steerer.push(AttachAxleToFrame(aM.physicsBody, carFrameBody, true));
                    motors.push(CreatePoweredWheelJoint(aM, wM));
                } else {
                    AttachAxleToFrame(aM.physicsBody, carFrameBody, false);
                    CreateWheelJoint(aM, wM);
                }
            });

            InitSecondKeyboardControls(motors[0], motors[1], steerer[0], steerer[1]);
            return carFrame;
        }

        function CreateAxle(position) {
            const mesh = BABYLON.MeshBuilder.CreateBox("Axle", { height: 1, width: 2.5, depth: 1, faceColors: debugColours });
            mesh.position = position;
            return mesh;
        }

        function CreateWheel(position) {
            const faceUV = [new BABYLON.Vector4(0,0,0,0), new BABYLON.Vector4(0,1,1,0), new BABYLON.Vector4(0,0,0,0)];
            const mesh = BABYLON.MeshBuilder.CreateCylinder("Wheel", { height: 2, diameter: 5, faceUV: faceUV });
            mesh.rotation = new BABYLON.Vector3(0, 0, Math.PI / 2);
            mesh.bakeCurrentTransformIntoVertices();
            mesh.position = position;
            mesh.material = tyreMaterial;
            return mesh;
        }

        function AttachAxleToFrame(axle, frame, hasSteering) {
            const aPos = axle.transformNode.position;
            const joint = new BABYLON.Physics6DoFConstraint({
                pivotA: new BABYLON.Vector3(0, 0, 0),
                pivotB: new BABYLON.Vector3(aPos.x, aPos.y, aPos.z),
            }, [
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_X, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_Y, minLimit: -0.2, maxLimit: 0.2, stiffness: 150000, damping: 6000 },
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_Z, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_X, minLimit: -0.2, maxLimit: 0.2 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Y, minLimit: hasSteering ? null : 0, maxLimit: hasSteering ? null : 0 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Z, minLimit: -0.1, maxLimit: 0.1 },
            ], scene);
            axle.addConstraint(frame, joint);
            if (hasSteering) {
                joint.setAxisMotorType(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, BABYLON.PhysicsConstraintMotorType.POSITION);
                joint.setAxisMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, 50000000);
            }
            return joint;
        }

        function CreateWheelJoint(axle, wheel) {
            const j = new BABYLON.Physics6DoFConstraint({}, [
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_DISTANCE, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Y, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Z, minLimit: 0, maxLimit: 0 },
            ], scene);
            axle.physicsBody.addConstraint(wheel.physicsBody, j);
            return j;
        }

        function CreatePoweredWheelJoint(axle, wheel) {
            const j = CreateWheelJoint(axle, wheel);
            j.setAxisMotorType(BABYLON.PhysicsConstraintAxis.ANGULAR_X, BABYLON.PhysicsConstraintMotorType.VELOCITY);
            j.setAxisMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_X, 250000);
            return j;
        }

        function InitKeyboardControls(mA, mB, sA, sB) {
            let f=0, b=0, l=0, r=0, speed=0, angle=0;
            scene.onKeyboardObservable.add(e => {
                let d = e.type == BABYLON.KeyboardEventTypes.KEYDOWN;
                if(e.event.key=="w") f=d; if(e.event.key=="s") b=d; if(e.event.key=="a") l=d; if(e.event.key=="d") r=d;
            });
            scene.onBeforeRenderObservable.add(() => {
                if(l) angle=Math.min(angle+0.02, 0.6); else if(r) angle=Math.max(angle-0.02, -0.6); else angle*=0.9;
                const [iA, oA] = CalculateWheelAngles(angle);
                sA.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, oA);
                sB.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, iA);
                if(f) speed=Math.min(speed+10, 250); else if(b) speed=Math.max(speed-10, -100); else speed*=0.98;
                mA.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_X, speed);
                mB.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_X, speed);
            });
        }

        function InitSecondKeyboardControls(mA, mB, sA, sB) {
            let f=0, b=0, l=0, r=0, speed=0, angle=0;
            scene.onKeyboardObservable.add(e => {
                let d = e.type == BABYLON.KeyboardEventTypes.KEYDOWN;
                if(e.event.key=="i") f=d; if(e.event.key=="k") b=d; if(e.event.key=="j") l=d; if(e.event.key=="l") r=d;
            });
            scene.onBeforeRenderObservable.add(() => {
                if(l) angle=Math.min(angle+0.02, 0.6); else if(r) angle=Math.max(angle-0.02, -0.6); else angle*=0.9;
                const [iA, oA] = CalculateWheelAngles(angle);
                sA.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, oA);
                sB.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, iA);
                if(f) speed=Math.min(speed+10, 250); else if(b) speed=Math.max(speed-10, -100); else speed*=0.98;
                mA.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_X, speed);
                mB.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_X, speed);
            });
        }

        function InitTyreMaterial() {
            tyreMaterial = new BABYLON.StandardMaterial("Tyre", scene);
            tyreMaterial.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
        }

        function CreateGroundAndWalls() {
            // 地面
            const ground = BABYLON.MeshBuilder.CreateGround("Ground", { height: 2000, width: 2000 });
            ground.position.y = -2;
            const groundMat = new BABYLON.StandardMaterial("gMat", scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.15, 0.15, 0.15);
            ground.material = groundMat;
            AddStaticPhysics(ground, 100);

            // 超高坡道
            const rampMat = new BABYLON.StandardMaterial("rampMat", scene);
            rampMat.diffuseColor = new BABYLON.Color3(1, 0.5, 0);
            const makeRamp = (x, z, rot, len, h) => {
                const r = BABYLON.MeshBuilder.CreateBox("Ramp", {width: 40, height: 2, depth: len}, scene);
                r.position.set(x, h, z);
                r.rotation.x = rot;
                r.material = rampMat;
                AddStaticPhysics(r, 10);
                r.physicsBody.shape.filterMembershipMask = FILTERS.Environment;
            };
            makeRamp(0, 150, -Math.PI/6, 100, 15);
            makeRamp(100, 300, -Math.PI/4, 150, 40);

            // 迷你方块楼房 (性能优化版)
            const blockSize = 3.5;
            const blockBase = BABYLON.MeshBuilder.CreateBox("blockBase", {size: blockSize}, scene);
            blockBase.isVisible = false;
            
            const createBuilding = (bx, bz, floors, w, d) => {
                const color = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
                const mat = new BABYLON.StandardMaterial("bMat", scene);
                mat.diffuseColor = color;

                for (let y=0; y<floors; y++) {
                    for (let x=0; x<w; x++) {
                        for (let z=0; z<d; z++) {
                            const inst = blockBase.createInstance("b");
                            inst.position.set(bx + x*blockSize, y*blockSize, bz + z*blockSize);
                            inst.material = mat;
                            
                            const body = new BABYLON.PhysicsBody(inst, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
                            const shape = new BABYLON.PhysicsShapeBox(BABYLON.Vector3.Zero(), BABYLON.Quaternion.Identity(), new BABYLON.Vector3(blockSize, blockSize, blockSize), scene);
                            body.shape = shape;
                            body.setMassProperties({mass: 8});
                            body.shape.filterMembershipMask = FILTERS.Environment;
                        }
                    }
                }
            };

            // 生成多栋楼
            for(let i=0; i<6; i++) {
                createBuilding(-150 + i*60, 100, 15, 4, 4);
                createBuilding(-150 + i*60, -150, 10, 3, 3);
            }

            // 围墙
            const walls = [
                {w:2000, d:10, x:0, z:1000}, {w:2000, d:10, x:0, z:-1000},
                {w:10, d:2000, x:1000, z:0}, {w:10, d:2000, x:-1000, z:0}
            ];
            walls.forEach(c => {
                const w = BABYLON.MeshBuilder.CreateBox("w", {width:c.w, height:100, depth:c.d});
                w.position.set(c.x, 40, c.z);
                AddStaticPhysics(w, 10);
            });
        }

        function AddWheelPhysics(m, mass, b, f) {
            const s = new BABYLON.PhysicsShapeCylinder(new BABYLON.Vector3(-1, 0, 0), new BABYLON.Vector3(1, 0, 0), 2.5, scene);
            const body = new BABYLON.PhysicsBody(m, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
            body.setMassProperties({ mass: mass });
            s.material = { restitution: b, friction: f };
            body.shape = s;
        }

        function AddAxlePhysics(m, mass, b, f) {
            const s = new BABYLON.PhysicsShapeBox(BABYLON.Vector3.Zero(), BABYLON.Quaternion.Identity(), new BABYLON.Vector3(2.5, 1, 1), scene);
            const body = new BABYLON.PhysicsBody(m, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
            body.setMassProperties({ mass: mass });
            body.shape = s;
        }

        function AddDynamicPhysics(m, mass, b, f) {
            const s = new BABYLON.PhysicsShapeMesh(m, scene);
            const body = new BABYLON.PhysicsBody(m, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
            body.setMassProperties({ mass: mass });
            s.material = { restitution: b, friction: f };
            body.shape = s;
            return body;
        }

        function AddStaticPhysics(m, f) {
            const s = new BABYLON.PhysicsShapeMesh(m, scene);
            const body = new BABYLON.PhysicsBody(m, BABYLON.PhysicsMotionType.STATIC, false, scene);
            s.material = { restitution: 0.1, friction: f };
            body.shape = s;
        }

        function FilterMeshCollisions(m) {
            m.physicsBody.shape.filterMembershipMask = FILTERS.CarParts;
            m.physicsBody.shape.filterCollideMask = FILTERS.Environment;
        }

        function CalculateWheelAngles(avg) {
            const wb = 18, tw = 12;
            const r = wb / Math.tan(avg);
            return [Math.atan(wb/(r-tw/2)) || 0, Math.atan(wb/(r+tw/2)) || 0];
        }

        init();
    </script>
</body>
</html>
