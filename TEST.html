<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Havok Pro - City Drive</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
        #status { position: absolute; top: 20px; left: 20px; color: #0f0; font-family: monospace; pointer-events: none; }
    </style>
</head>
<body>
    <div id="status">正在加载城市物理环境...</div>
    <canvas id="renderCanvas"></canvas>

    <script>
        const canvas = document.getElementById("renderCanvas");
        let scene, havokInstance, tyreMaterial;
        const debugColours = [];
        debugColours[0] = new BABYLON.Color4(1, 0, 1, 1);
        debugColours[1] = new BABYLON.Color4(1, 0, 0, 1);
        debugColours[2] = new BABYLON.Color4(0, 1, 0, 1);
        debugColours[3] = new BABYLON.Color4(1, 1, 0, 1);
        debugColours[4] = new BABYLON.Color4(0, 1, 1, 1);
        debugColours[5] = new BABYLON.Color4(0, 0, 1, 1);
        const FILTERS = { CarParts: 1, Environment: 2 };

        (async () => {
            const hkWasm = await HavokPhysics();
            havokInstance = new BABYLON.HavokPlugin(false, hkWasm);
            await createScene();
        })();

        async function createScene() {
            const engine = new BABYLON.Engine(canvas, true);
            scene = new BABYLON.Scene(engine);

            // 你的核心物理参数
            scene.enablePhysics(new BABYLON.Vector3(0, -240, 0), havokInstance);
            scene.getPhysicsEngine().setTimeStep(1 / 500);
            scene.getPhysicsEngine().setSubTimeStep(4.5);

            const camera = new BABYLON.FollowCamera("FollowCam", new BABYLON.Vector3(0, 10, -10), scene);
            camera.radius = 50; camera.heightOffset = 20; camera.rotationOffset = 180;
            camera.cameraAcceleration = 0.035; camera.maxCameraSpeed = 20;

            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);
            light.intensity = 0.8;

            InitTyreMaterial();
            
            // 1. 加载城市并添加碰撞 (Environment)
            await LoadCity("city.glb"); 

            // 2. 创建车辆 (CarParts)
            const carFrame = CreateCar();
            camera.lockedTarget = carFrame;

            engine.runRenderLoop(() => { scene.render(); });
            window.addEventListener('resize', () => engine.resize());
            document.getElementById("status").textContent = "WASD驾驶 | 城市物理已就绪";
        }

        // --- 新增：城市加载逻辑 ---
        async function LoadCity(file) {
            const result = await BABYLON.SceneLoader.ImportMeshAsync("", "./", file, scene);
            result.meshes.forEach(mesh => {
                // 只给可见的、有顶点的模型加碰撞
                if (mesh.getTotalVertices() > 0) {
                    AddStaticPhysics(mesh, 300); // 使用你的 AddStaticPhysics
                    FilterMeshCollisions(mesh);  // 使用你的 FILTERS.Environment
                }
            });
        }

        // --- 以下完全保留你的逻辑函数 ---

        function CreateCar() {
            const carFrame = BABYLON.MeshBuilder.CreateBox("Frame", { height: 1, width: 12, depth: 24, faceColors: debugColours });
            carFrame.position = new BABYLON.Vector3(0, 5, 0); // 从空中落下
            carFrame.visibility = 0.5;
            const carFrameBody = AddDynamicPhysics(carFrame, 1000, 0, 0);
            FilterMeshCollisions(carFrame);

            const flWheel = CreateWheel(new BABYLON.Vector3(5, 0, 8));
            const flAxle = CreateAxle(new BABYLON.Vector3(5, 0, 8));
            const frWheel = CreateWheel(new BABYLON.Vector3(-5, 0, 8));
            const frAxle = CreateAxle(new BABYLON.Vector3(-5, 0, 8));
            const rlWheel = CreateWheel(new BABYLON.Vector3(5, 0, -8));
            const rlAxle = CreateAxle(new BABYLON.Vector3(5, 0, -8));
            const rrWheel = CreateWheel(new BABYLON.Vector3(-5, 0, -8));
            const rrAxle = CreateAxle(new BABYLON.Vector3(-5, 0, -8));

            for (const mesh of [flAxle, frAxle, rlAxle, rrAxle]) {
                carFrame.addChild(mesh);
                AddAxlePhysics(mesh, 100, 0, 0);
                FilterMeshCollisions(mesh);
            }
            for (const mesh of [flWheel, frWheel, rlWheel, rrWheel]) {
                AddWheelPhysics(mesh, 100, 0.1, 50);
                FilterMeshCollisions(mesh);
            }

            const poweredWheelMotorA = CreatePoweredWheelJoint(flAxle, flWheel);
            const poweredWheelMotorB = CreatePoweredWheelJoint(frAxle, frWheel);
            CreateWheelJoint(rlAxle, rlWheel);
            CreateWheelJoint(rrAxle, rrWheel);

            const steerWheelA = AttachAxleToFrame(flAxle.physicsBody, carFrameBody, true);
            const steerWheelB = AttachAxleToFrame(frAxle.physicsBody, carFrameBody, true);
            AttachAxleToFrame(rlAxle.physicsBody, carFrameBody, false);
            AttachAxleToFrame(rrAxle.physicsBody, carFrameBody, false);

            InitKeyboardControls(poweredWheelMotorA, poweredWheelMotorB, steerWheelA, steerWheelB);
            return carFrame;
        }

        function CreateAxle(position) {
            const axleMesh = BABYLON.MeshBuilder.CreateBox("Axle", { height: 1, width: 2.5, depth: 1, faceColors: debugColours });
            axleMesh.position = position;
            return axleMesh;
        }

        function CreateWheel(position) {
            const wheelMesh = BABYLON.MeshBuilder.CreateCylinder("Wheel", { height: 1.6, diameter: 4 });
            wheelMesh.rotation = new BABYLON.Vector3(0, 0, Math.PI / 2);
            wheelMesh.bakeCurrentTransformIntoVertices();
            wheelMesh.position = position;
            wheelMesh.material = tyreMaterial;
            return wheelMesh;
        }

        function AttachAxleToFrame(axle, frame, hasSteering) {
            const aPos = axle.transformNode.position;
            const joint = new BABYLON.Physics6DoFConstraint({
                pivotA: new BABYLON.Vector3(0, 0, 0),
                pivotB: new BABYLON.Vector3(aPos.x, aPos.y, aPos.z),
            }, [
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_X, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_Y, minLimit: -0.15, maxLimit: 0.15, stiffness: 100000, damping: 5000 },
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_Z, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_X, minLimit: -0.25, maxLimit: 0.25 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Y, minLimit: hasSteering ? null : 0, maxLimit: hasSteering ? null : 0 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Z, minLimit: -0.05, maxLimit: 0.05 },
            ], scene);
            axle.addConstraint(frame, joint);
            if (hasSteering) AttachSteering(joint);
            return joint;
        }

        function CreateWheelJoint(axle, wheel) {
            const motorJoint = new BABYLON.Physics6DoFConstraint({}, [
                { axis: BABYLON.PhysicsConstraintAxis.LINEAR_DISTANCE, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Y, minLimit: 0, maxLimit: 0 },
                { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Z, minLimit: 0, maxLimit: 0 },
            ], scene);
            axle.physicsBody.addConstraint(wheel.physicsBody, motorJoint);
            return motorJoint;
        }

        function CreatePoweredWheelJoint(axle, wheel) {
            const motorJoint = CreateWheelJoint(axle, wheel);
            motorJoint.setAxisMotorType(BABYLON.PhysicsConstraintAxis.ANGULAR_X, BABYLON.PhysicsConstraintMotorType.VELOCITY);
            motorJoint.setAxisMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_X, 180000);
            motorJoint.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_X, 0);
            return motorJoint;
        }

        function AttachSteering(joint) {
            joint.setAxisMotorType(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, BABYLON.PhysicsConstraintMotorType.POSITION);
            joint.setAxisMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, 30000000);
            joint.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, 0);
            return joint;
        }

        function CalculateWheelAngles(averageAngle) {
            const wheelbase = 16, trackWidth = 11;
            const avgRadius = wheelbase / Math.tan(averageAngle);
            const innerRadius = avgRadius - trackWidth / 2;
            const outerRadius = avgRadius + trackWidth / 2;
            const innerAngle = Math.atan(wheelbase / innerRadius);
            const outerAngle = Math.atan(wheelbase / outerRadius);
            return [isNaN(innerAngle) ? 0 : innerAngle, isNaN(outerAngle) ? 0 : outerAngle];
        }

        function InitKeyboardControls(motorWheelA, motorWheelB, steerWheelA, steerWheelB) {
            let keys = { w: false, s: false, a: false, d: false, space: false };
            let currentSpeed = 0, currentSteeringAngle = 0, maxSpeed = 150;
            const maxSteeringAngle = Math.PI / 6;

            scene.onKeyboardObservable.add(e => {
                const isDown = e.type == BABYLON.KeyboardEventTypes.KEYDOWN;
                const key = e.event.key.toLowerCase();
                if(key === "w" || key === "arrowup") keys.w = isDown;
                if(key === "s" || key === "arrowdown") keys.s = isDown;
                if(key === "a" || key === "arrowleft") keys.a = isDown;
                if(key === "d" || key === "arrowright") keys.d = isDown;
                if(key === " ") keys.space = isDown;
            });

            scene.onBeforeRenderObservable.add(() => {
                if (keys.a && currentSteeringAngle < maxSteeringAngle) currentSteeringAngle += 0.015;
                else if (keys.d && currentSteeringAngle > -maxSteeringAngle) currentSteeringAngle -= 0.015;
                else currentSteeringAngle *= 0.95;

                const [innerAngle, outerAngle] = CalculateWheelAngles(currentSteeringAngle);
                steerWheelA.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, outerAngle);
                steerWheelB.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, innerAngle);

                if (keys.space) currentSpeed = 0;
                else if (keys.w && currentSpeed < maxSpeed) currentSpeed += 8;
                else if (keys.s && currentSpeed > -maxSpeed * 0.5) currentSpeed -= 8;
                else currentSpeed *= 0.99;

                motorWheelA.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_X, currentSpeed);
                motorWheelB.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_X, currentSpeed);
            });
        }

        function InitTyreMaterial() {
            tyreMaterial = new BABYLON.StandardMaterial("Tyre", scene);
            tyreMaterial.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
        }

        function CreateGroundAndWalls() {
            // 已被 LoadCity 替代，如果需要基础平面可保留
        }

        function AddWheelPhysics(mesh, mass, bounce, friction) {
            const physicsShape = new BABYLON.PhysicsShapeCylinder(new BABYLON.Vector3(-0.8, 0, 0), new BABYLON.Vector3(0.8, 0, 0), 2, scene);
            const physicsBody = new BABYLON.PhysicsBody(mesh, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
            physicsBody.setMassProperties({ mass: mass });
            physicsShape.material = { restitution: bounce, friction: friction };
            physicsBody.shape = physicsShape;
            return physicsBody;
        }

        function AddAxlePhysics(mesh, mass, bounce, friction) {
            const physicsShape = new BABYLON.PhysicsShapeCylinder(new BABYLON.Vector3(-0.8, 0, 0), new BABYLON.Vector3(0.8, 0, 0), 1.8, scene);
            const physicsBody = new BABYLON.PhysicsBody(mesh, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
            physicsBody.setMassProperties({ mass: mass });
            physicsShape.material = { restitution: bounce, friction: friction };
            physicsBody.shape = physicsShape;
            return physicsBody;
        }

        function AddDynamicPhysics(mesh, mass, bounce, friction) {
            const physicsShape = new BABYLON.PhysicsShapeMesh(mesh, scene);
            const physicsBody = new BABYLON.PhysicsBody(mesh, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);
            physicsBody.setMassProperties({ mass: mass });
            physicsShape.material = { restitution: bounce, friction: friction };
            physicsBody.shape = physicsShape;
            return physicsBody;
        }

        function AddStaticPhysics(mesh, friction) {
            const physicsShape = new BABYLON.PhysicsShapeMesh(mesh, scene);
            const physicsBody = new BABYLON.PhysicsBody(mesh, BABYLON.PhysicsMotionType.STATIC, false, scene);
            physicsShape.material = { restitution: 0, friction: friction };
            physicsBody.shape = physicsShape;
            return physicsBody;
        }

        function FilterMeshCollisions(mesh) {
            if(mesh.physicsBody && mesh.physicsBody.shape) {
                mesh.physicsBody.shape.filterMembershipMask = mesh.physicsBody.getMotionType() === BABYLON.PhysicsMotionType.STATIC ? FILTERS.Environment : FILTERS.CarParts;
                mesh.physicsBody.shape.filterCollideMask = mesh.physicsBody.getMotionType() === BABYLON.PhysicsMotionType.STATIC ? FILTERS.CarParts : FILTERS.Environment;
            }
        }
    </script>
</body>
</html>
