<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>HYPER DRIVE | HAVOK NATIVE</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #00FFFF; display: flex; 
            align-items: center; justify-content: center; font-family: 'Orbitron';
        }
    </style>
</head>
<body>

    <div id="loading">HAVOK ENGINE BOOTING...</div>
    <canvas id="renderCanvas"></canvas>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>

    <script>
        const canvas = document.getElementById("renderCanvas");
        let engine, scene, carBody, joints = [];
        let inputMap = {};

        // 1. 异步初始化 Havok
        async function init() {
            const havokInstance = await HavokPhysics();
            const hk = new BABYLON.HavokPlugin(true, havokInstance);
            
            engine = new BABYLON.Engine(canvas, true);
            scene = new BABYLON.Scene(engine);
            scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), hk);

            setupEnvironment();
            createPlayerCar();
            setupInputs();

            document.getElementById('loading').style.display = 'none';
            
            engine.runRenderLoop(() => scene.render());
        }

        function setupEnvironment() {
            const camera = new BABYLON.ArcRotateCamera("cam", -Math.PI/2, Math.PI/3, 15, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            
            new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

            // 静态地面
            const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 1000, height: 1000}, scene);
            ground.material = new BABYLON.StandardMaterial("gMat", scene);
            ground.material.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            
            new BABYLON.PhysicsAggregate(ground, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);
        }

        function createPlayerCar() {
            // --- A. 车身 ---
            const chassis = BABYLON.MeshBuilder.CreateBox("chassis", {width: 2, height: 0.6, depth: 4}, scene);
            chassis.position.y = 2;
            
            const chassisAgg = new BABYLON.PhysicsAggregate(chassis, BABYLON.PhysicsShapeType.BOX, { mass: 1500, friction: 0.5 }, scene);
            carBody = chassisAgg.body;

            // 重要：下移重心，防止 Havok 物理模拟时车体过于晃动
            carBody.setMassProperties({ centerOfMass: new BABYLON.Vector3(0, -0.4, 0) });

            // --- B. 车轮与约束 ---
            const wheelPositions = [
                new BABYLON.Vector3(-1.1, -0.3, 1.3),  // 前左
                new BABYLON.Vector3( 1.1, -0.3, 1.3),  // 前右
                new BABYLON.Vector3(-1.1, -0.3, -1.3), // 后左
                new BABYLON.Vector3( 1.1, -0.3, -1.3)  // 后右
            ];

            wheelPositions.forEach((pos, i) => {
                const isFront = i < 2;
                const wheel = BABYLON.MeshBuilder.CreateCylinder("w"+i, {diameter: 0.8, height: 0.4}, scene);
                wheel.rotation.z = Math.PI / 2;
                wheel.position = chassis.position.add(pos);
                
                const wheelAgg = new BABYLON.PhysicsAggregate(wheel, BABYLON.PhysicsShapeType.CYLINDER, { mass: 50, friction: 1.5 }, scene);

                // 使用 6DoF 约束模拟“真实的机械连接”
                const constraint = new BABYLON.Physics6DoFConstraint(
                    {
                        pivotA: pos,
                        pivotB: BABYLON.Vector3.Zero(),
                        axisA: new BABYLON.Vector3(1, 0, 0), // X轴旋转（滚动）
                        axisB: new BABYLON.Vector3(0, 1, 0), // 针对圆柱体模型的校准
                        perpAxisA: new BABYLON.Vector3(0, 1, 0),
                        perpAxisB: new BABYLON.Vector3(1, 0, 0),
                    },
                    [
                        // 线性限制：锁死位移，仅保留微量 Y 轴缓冲（悬挂）
                        { axis: BABYLON.PhysicsConstraintAxis.LINEAR_X, minLimit: 0, maxLimit: 0 },
                        { axis: BABYLON.PhysicsConstraintAxis.LINEAR_Y, minLimit: -0.1, maxLimit: 0.1 },
                        { axis: BABYLON.PhysicsConstraintAxis.LINEAR_Z, minLimit: 0, maxLimit: 0 },
                        // 旋转限制：
                        { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_X, minLimit: isFront ? -0.5 : 0, maxLimit: isFront ? 0.5 : 0 }, // 转向
                        { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Y, minLimit: null, maxLimit: null }, // 滚动（不限）
                        { axis: BABYLON.PhysicsConstraintAxis.ANGULAR_Z, minLimit: 0, maxLimit: 0 }  
                    ],
                    scene
                );

                carBody.addConstraint(wheelAgg.body, constraint);
                joints.push({ constraint, isFront });
            });

            // 逻辑循环
            scene.registerBeforeRender(() => {
                let motorSpeed = 0;
                if(inputMap["w"]) motorSpeed = 50;
                if(inputMap["s"]) motorSpeed = -30;

                let steerAngle = 0;
                if(inputMap["a"]) steerAngle = -0.5;
                if(inputMap["d"]) steerAngle = 0.5;

                joints.forEach(j => {
                    // 后轮驱动
                    if(!j.isFront) {
                        j.constraint.setAxisMotorTarget(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, motorSpeed);
                        j.constraint.setAxisMotorType(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, BABYLON.PhysicsConstraintMotorType.VELOCITY);
                        j.constraint.setAxisMotorMaxForce(BABYLON.PhysicsConstraintAxis.ANGULAR_Y, 2000);
                    }
                    // 前轮转向
                    if(j.isFront) {
                        j.constraint.setAxisMinLimit(BABYLON.PhysicsConstraintAxis.ANGULAR_X, steerAngle);
                        j.constraint.setAxisMaxLimit(BABYLON.PhysicsConstraintAxis.ANGULAR_X, steerAngle);
                    }
                });
            });
        }

        function setupInputs() {
            window.addEventListener("keydown", e => inputMap[e.key.toLowerCase()] = true);
            window.addEventListener("keyup", e => inputMap[e.key.toLowerCase()] = false);
        }

        init();
    </script>
</body>
</html>
